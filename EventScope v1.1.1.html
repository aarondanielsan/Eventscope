<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>EventScope</title>

    <!-- Google Charts -->
    <script src="https://www.gstatic.com/charts/loader.js"></script>

    <!-- PDF.js for in-browser PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
    <script>
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js";
        }
    </script>

    <!-- Dexie.js for IndexedDB management -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&amp;display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-navy: #0f1f3a;
            --panel: #1c2a55;
            --border: #394c7a;
            --text: #f5f5f5;
            --accent: #2196f3;
            --chart-bg: #ffffff;
            --prev: #dc2626;
            --new: #16a34a;
            --changed: #eab308;
            --tab: #0b1730;
            --tab-active: #173265;
            --muted: #cbd5e1;
            --today: #16a34a;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: var(--bg-navy);
            color: var(--text);
        }

        .container {
            margin: 0 auto;
            padding: 24px;
        }

        h1 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 0 0 12px 0;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 14px;
        }

        /* global controls (uploads) */
        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        label {
            font-size: .9rem;
            opacity: .9
        }

        input[type="file"] {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        input[type="file"]::-webkit-file-upload-button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: .8rem;
        }

        button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: .85rem;
            cursor: pointer;
            transition: .18s ease;
        }

        button:hover {
            filter: brightness(1.08)
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        .spacer {
            flex: 1
        }

        .group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap
        }

        .upload-stack {
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
        }

        .upload-stack label {
            margin-bottom: 2px;
        }

        .upload-stack input[type="file"],
        .upload-stack .report-select {
            width: min(280px, 100%);
        }

        .report-select {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        .report-select:focus {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }

        /* tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin: 12px 0;
        }

        .tab-btn {
            background: var(--tab);
            border: 1px solid var(--border);
            color: #cfe0ff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .tab-btn.active {
            background: var(--tab-active);
            color: #fff;
            border-color: #3e59a1;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* toolbar (calendar + bottom-anchored controls) */
        .toolbar {
            display: flex;
            gap: 20px;
            align-items: stretch;
            background: #182750;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
        }

        .calendar-shell {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px;
            width: 220px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .cal-nav button {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            cursor: pointer;
            font-weight: 700;
        }

        table.cal {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
            font-size: .8rem
        }

        .cal th {
            color: var(--muted);
            font-weight: 600;
            padding: 4px 0
        }

        .cal td {
            padding: 4px;
            border-radius: 6px;
            cursor: pointer
        }

        .cal td:hover {
            background: #2b3f75
        }

        .cal td.active {
            background: #2b3f75;
            outline: 1px solid #4b6bb5
        }

        .cal td.real-today {
            outline: 2px dashed var(--today)
        }

        .cal td.muted {
            color: #7f8ab1
        }

        .week-highlight td.in-week {
            background: #2a3f7c;
        }

        .week-highlight td.in-week.active {
            outline: 2px solid #4b6bb5
        }

        .right-tools {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .controls-bottom {
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-badge {
            display: grid;
            grid-template-columns: 34px minmax(220px, 1fr) 34px;
            align-items: center;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 6px 8px;
            min-width: 320px;
        }

        .nav-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            color: #fff;
            background: var(--accent);
        }

        .date-label {
            text-align: center;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 8px;
        }

        .segmented {
            display: inline-flex;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 3px;
        }

        .segmented button {
            background: transparent;
            border: none;
            color: #cfe0ff;
            padding: 6px 10px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
        }

        .segmented button.active {
            background: var(--accent);
            color: #fff;
        }

        .btn {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .85rem;
        }

        .btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        /* search card (timeline-only filter) */
        .search-card {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            position: relative;
        }

        .search-box input {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            font: inherit;
            min-width: 280px;
        }

        .suggestions {
            position: absolute;
            top: 110%;
            left: 0;
            right: 0;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 180px;
            overflow-y: auto;
            display: none;
            z-index: 20;
        }

        .suggestions div {
            padding: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .suggestions div:hover {
            background: #2b3f75;
        }

        .pill {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 4px 8px;
            font-size: .8rem;
            color: #cfe0ff;
        }

        /* timeline wrapper */
        #timeline-wrapper {
            background: var(--chart-bg);
            border-radius: 10px;
            padding: 10px;
            margin-top: 8px;
        }

        #timeline {
            width: 100%;
            height: 70vh;
            min-height: 400px;
        }

        #timeline text {
            font-weight: 400 !important;
        }

        .google-visualization-tooltip,
        .google-visualization-tooltip * {
            color: #000 !important;
            background: #fff !important;
            font-family: 'Poppins', sans-serif !important;
            font-size: 12px !important;
        }

        .google-visualization-tooltip {
            border: 1px solid #cfcfcf !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, .15) !important;
            border-radius: 6px !important;
        }

        /* Change Log (kept as your working version, pill colors preserved) */
        #changeLogNote {
            background: #eef6ff;
            color: #1e3a8a;
            padding: 6px 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-size: .9rem;
            font-weight: 500;
        }

        .company-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 14px 0 6px;
        }

        .date-header {
            font-size: 1.05rem;
            font-weight: 600;
            margin: 18px 0 6px;
            color: #bfdbfe;
        }

        .event-header {
            font-size: 1rem;
            font-weight: 500;
            margin: 8px 0 4px 8px;
            color: #cbd5e1;
        }

        .change-card {
            background: #fff;
            color: #000;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 6px 0 6px 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .change-card h4 {
            margin: 0 0 6px;
            font-size: .95rem;
            color: #111;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 9999px;
            margin-right: 6px;
            color: #fff;
        }

        .badge-new {
            background-color: #28a745;
        }

        .badge-changed {
            background-color: #ffc107;
        }

        .badge-removed {
            background-color: #dc3545;
        }

        .change-card ul {
            margin: 0;
            padding-left: 16px;
        }

        .change-card li {
            margin: 2px 0;
            font-size: .85rem;
        }

        .change-prev {
            color: var(--prev);
            font-weight: 600;
        }

        .change-new {
            color: var(--new);
            font-weight: 700;
        }

        /* Forecast styles (unchanged) */
        .forecast-card {
            background: #1c2a55;
            padding: 16px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #394c7a;
        }

        .forecast-card h3 {
            margin-top: 0;
            font-size: 1.2rem;
        }

        .company-group {
            margin-bottom: 14px;
            padding: 12px;
            border-radius: 8px;
            background: #223366;
        }

        .company-name {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .event-block {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 6px;
            background: #2a3c6e;
        }

        .event-title {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .space-pill {
            background: #394c7a;
            padding: 3px 8px;
            border-radius: 14px;
            font-size: .8rem;
            margin-right: 6px;
        }

        .happening .section {
            margin-top: 12px;
        }

        .happening strong {
            font-size: 1.05rem;
        }

        .happening .now strong {
            color: #22c55e;
        }

        .happening .next strong {
            color: #3b82f6;
        }

        .happening-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #394c7a;
        }

        .happening-row:last-child {
            border-bottom: none;
        }

        .happening-row span {
            font-size: .9rem;
        }

        .warning-box {
            margin-bottom: 12px;
            padding: 10px;
            border: 1px solid #facc15;
            border-radius: 6px;
            background: #2a2a1c;
            color: #facc15;
        }
    </style>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
</head>

<body>
    <div class="container">
        <h1>EventScope</h1>

        <!-- GLOBAL uploads -->
        <div class="card" id="globalUploads">
            <div class="controls">
                <div class="group upload-stack">
                    <label for="csvFileA">Newest Event Report PDF</label>
                    <input type="file" id="csvFileA" accept=".pdf">
                    <select id="reportHistoryA" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
                <div class="spacer"></div>
                <div class="group upload-stack">
                    <label for="csvFileB">Previous Event Report PDF</label>
                    <input type="file" id="csvFileB" accept=".pdf">
                    <select id="reportHistoryB" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="timelineTab">Timeline</button>
            <button class="tab-btn" data-tab="changeTab">Change Log</button>
            <button class="tab-btn" data-tab="forecastTab">Today’s Forecast</button>
        </div>

        <!-- TIMELINE TAB -->
        <div id="timelineTab" class="tab-content active">
            <div class="card">

                <!-- Toolbar (calendar + bottom-anchored controls) -->
                <div class="toolbar">
                    <!-- Calendar -->
                    <div class="calendar-shell week-highlight">
                        <div class="calendar-header">
                            <div id="calMonthLabel">September 2025</div>
                            <div class="cal-nav">
                                <button id="calPrev" aria-label="Prev Month">‹</button>
                                <button id="calNext" aria-label="Next Month">›</button>
                            </div>
                        </div>
                        <table class="cal" id="calTable">
                            <thead>
                                <tr>
                                    <th>Su</th>
                                    <th>Mo</th>
                                    <th>Tu</th>
                                    <th>We</th>
                                    <th>Th</th>
                                    <th>Fr</th>
                                    <th>Sa</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="7" data-d="31">31</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="1">1</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="2">2</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="3">3</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="4">4</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="5">5</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="6">6</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="7">7</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="8">8</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="9">9</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="10">10</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="11">11</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="12">12</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="13">13</td>
                                </tr>
                                <tr>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="14">14</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="15">15</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="16">16</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="17">17</td>
                                    <td class=" active real-today in-week" data-y="2025" data-m="8" data-d="18">18</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="19">19</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="20">20</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="21">21</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="22">22</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="23">23</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="24">24</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="25">25</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="26">26</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="27">27</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="28">28</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="29">29</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="30">30</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="1">1</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="2">2</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="3">3</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="4">4</td>
                                </tr>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="5">5</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="6">6</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="7">7</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="8">8</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="9">9</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="10">10</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="11">11</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Bottom-anchored tools -->

                </div>

                <!--Main Tools (Date, Toggle, Search, Show -->
                <div class="card" id="searchCard" style="margin-top:12px;">
                    <div class="search-card">

                        <div class="date-badge">
                            <button class="nav-btn" id="prevDay">‹</button>
                            <div class="date-label" id="dateLabel">Thu, Sep 18, 2025</div>
                            <button class="nav-btn" id="nextDay">›</button>
                        </div><button class="btn" id="jumpToday">Today</button>
                        <div class="segmented" id="viewMode">
                            <button data-mode="day" class="active">Daily</button>
                            <button data-mode="week" class="">Weekly</button>
                        </div>
                        <div class="search-box">
                            <input type="text" id="timelineSearch" placeholder="Search company or event…">
                            <div class="suggestions" id="searchSuggest" style="display: none;"></div>
                        </div>
                        <button class="secondary" id="clearSearch">Clear</button>
                        <span id="searchStatus" style="opacity:.7;font-size:.9rem;"></span>
                        <button class="btn secondary" id="toggleShowRooms">Show All Rooms</button>
                    </div>
                </div>

                <!-- Chart -->
                <div id="timeline-wrapper">
                    <div id="timeline">
                        <p style="color:#c00; margin:12px;">No events found for this date.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- CHANGE LOG TAB (unchanged logic & styles you approved) -->
        <div id="changeTab" class="tab-content">
            <div class="card">
                <h2>Change Log</h2>
                <div id="changeLogNote">Comparing overlapping dates: Previous Report ⇄ Newest Report</div>
                <div id="changeLog">
                    <p style="opacity:.8">Upload both reports to see changes.</p>
                </div>
            </div>
        </div>

        <!-- TODAY'S FORECAST TAB (unchanged) -->
        <div id="forecastTab" class="tab-content">
            <div class="card">
                <h2>Today’s Event Forecast</h2>
                <div id="forecast">
                    <p style="opacity:.8">Upload the newest report to view today’s schedule summary.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ========= LOAD CHARTS ========= */
        google.charts.load("current", {
            packages: ["timeline"]
        });

        /* ========= GLOBAL STATE ========= */
        let reportA = [],
            reportB = []; // A = newest, B = previous
        let allEvents = []; // base events (from newest report)
        let currentDate = new Date();
        let showAllRooms = false;
        let viewMode = "day"; // 'day' | 'week'
        let searchTerm = ""; // timeline-only filter
        let suggestionsList = []; // autosuggest values

        /* ========= REPORT HISTORY (IndexedDB) ========= */
        const REPORT_HISTORY_LIMIT = 10;
        const reportDB = window.Dexie ? new Dexie("eventscopeReports") : null;
        if (reportDB) {
            reportDB.version(1).stores({
                reports: "++id, uploadedAt"
            });
            reportDB.version(2).stores({
                reports: "++id, date, savedAt"
            }).upgrade(async tx => {
                await tx.table("reports").toCollection().modify(entry => {
                    const fallbackRaw = entry.fileTimestamp ?? entry.uploadedAt ?? Date.now();
                    const fallbackNumber = Number(fallbackRaw);
                    const fallbackDate = Number.isFinite(fallbackNumber) ? new Date(fallbackNumber) : new Date();
                    const savedValue = entry.uploadedDate ?? (entry.uploadedAt ? new Date(Number(entry.uploadedAt)).toISOString() : new Date().toISOString());
                    entry.fileName = entry.fileName || entry.filename || "Report";
                    entry.date = entry.date || fallbackDate.toISOString();
                    entry.savedAt = entry.savedAt || savedValue;
                    if (entry.events === undefined && entry.rows !== undefined) {
                        entry.events = entry.rows;
                    }
                    delete entry.filename;
                    delete entry.uploadedAt;
                    delete entry.uploadedDate;
                    delete entry.fileTimestamp;
                    delete entry.rows;
                });
            });
        }

        function entryDateValue(entry) {
            if (!entry) return 0;
            const candidate = entry.date ?? entry.savedAt;
            if (candidate !== undefined && candidate !== null) {
                const parsed = typeof candidate === "number" ? candidate : Date.parse(candidate);
                if (!Number.isNaN(parsed)) return parsed;
            }
            const fallback = entry.fileTimestamp ?? entry.uploadedAt ?? entry.lastModified;
            if (fallback !== undefined && fallback !== null) {
                const numeric = typeof fallback === "number" ? fallback : Number(fallback);
                if (Number.isFinite(numeric)) return numeric;
            }
            return 0;
        }

        function formatReportOption(entry) {
            const dateValue = entryDateValue(entry);
            const dt = dateValue ? new Date(dateValue) : null;
            const dateStr = dt ? dt.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "Unknown date";
            const name = entry.fileName || entry.filename || "Report";
            return `${dateStr} – ${name}`;
        }

        async function getStoredReports() {
            if (!reportDB) return [];
            try {
                const all = await reportDB.reports.toArray();
                const usable = all.filter(entry => entry && entry.events !== undefined);
                usable.sort((a, b) => {
                    const diff = entryDateValue(b) - entryDateValue(a);
                    if (diff !== 0) return diff;
                    return (b.id || 0) - (a.id || 0);
                });
                return usable.slice(0, REPORT_HISTORY_LIMIT);
            } catch (err) {
                console.error("Unable to read stored reports", err);
                return [];
            }
        }

        async function pruneExcessReports() {
            if (!reportDB) return;
            try {
                const all = await reportDB.reports.toArray();
                if (all.length <= REPORT_HISTORY_LIMIT) return;
                all.sort((a, b) => {
                    const diff = entryDateValue(b) - entryDateValue(a);
                    if (diff !== 0) return diff;
                    return (b.id || 0) - (a.id || 0);
                });
                const keep = new Set(all.slice(0, REPORT_HISTORY_LIMIT).map(entry => entry.id));
                const toDelete = all.filter(entry => !keep.has(entry.id)).map(entry => entry.id);
                if (toDelete.length) {
                    await reportDB.reports.bulkDelete(toDelete);
                }
            } catch (err) {
                console.error("Unable to prune stored reports", err);
            }
        }

        async function populateReportDropdowns({ selectAId, selectBId } = {}) {
            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            if (!selectA || !selectB) return [];
            const data = await getStoredReports();
            [
                { element: selectA, override: selectAId },
                { element: selectB, override: selectBId }
            ].forEach(({ element, override }) => {
                const previous = element.value;
                const desired = override !== undefined ? (override == null ? "" : String(override)) : previous;
                element.innerHTML = "<option value=\"\">Select a saved report…</option>";
                data.forEach(item => {
                    const opt = document.createElement("option");
                    opt.value = String(item.id);
                    opt.textContent = formatReportOption(item);
                    opt.dataset.fileName = item.fileName || "";
                    opt.dataset.date = item.date || "";
                    opt.dataset.savedAt = item.savedAt || "";
                    element.appendChild(opt);
                });
                if (desired) {
                    element.value = desired;
                    if (element.value !== desired) {
                        element.selectedIndex = 0;
                    }
                } else {
                    element.selectedIndex = 0;
                }
                const selectedOption = element.options[element.selectedIndex];
                element.title = selectedOption ? selectedOption.textContent : "";
            });
            return data;
        }

        async function saveParsedReport(file, rows, target) {
            if (!reportDB || !file) return null;
            try {
                const now = new Date();
                const hasLastModified = typeof file.lastModified === "number" && !Number.isNaN(file.lastModified);
                const fileDate = hasLastModified ? new Date(file.lastModified) : now;
                const fileDateIso = fileDate.toISOString();
                const events = Array.isArray(rows) ? rows.filter(r => r && r["Day of Event"]) : [];
                const clonedEvents = JSON.parse(JSON.stringify(events));
                const existing = await reportDB.reports
                    .where("date")
                    .equals(fileDateIso)
                    .filter(entry => (entry?.fileName || "") === file.name)
                    .first();
                const selectionTarget = target === "A" ? "selectAId" : "selectBId";
                if (existing?.id) {
                    await reportDB.reports.update(existing.id, {
                        events: clonedEvents,
                        savedAt: now.toISOString()
                    });
                    await pruneExcessReports();
                    await populateReportDropdowns({ [selectionTarget]: existing.id });
                    return existing.id;
                }
                const payload = {
                    fileName: file.name,
                    date: fileDateIso,
                    savedAt: now.toISOString(),
                    events: clonedEvents
                };
                const id = await reportDB.reports.add(payload);
                await pruneExcessReports();
                await populateReportDropdowns({ [selectionTarget]: id });
                return id;
            } catch (err) {
                console.error("Unable to save parsed report", err);
                return null;
            }
        }

        async function loadReportFromHistory(entryOrId, target) {
            if (!reportDB) return false;
            try {
                let entry = entryOrId;
                if (!entry || typeof entry !== "object") {
                    const idNum = Number(entryOrId);
                    if (!idNum) return false;
                    entry = await reportDB.reports.get(idNum);
                }
                if (!entry || entry.events === undefined) {
                    console.warn("Stored report is missing event data.");
                    return false;
                }
                const events = Array.isArray(entry.events) ? entry.events : [];
                const cloned = JSON.parse(JSON.stringify(events));
                ingestRows(target, cloned);
                return true;
            } catch (err) {
                console.error("Unable to load stored report", err);
                return false;
            }
        }

        async function initializeReportHistory() {
            await pruneExcessReports();
            const inputA = document.getElementById("csvFileA");
            const inputB = document.getElementById("csvFileB");
            if (inputA) inputA.value = "";
            if (inputB) inputB.value = "";
            const reports = await populateReportDropdowns({ selectBId: null });
            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            if (selectB) {
                selectB.value = "";
                selectB.selectedIndex = 0;
                const optionB = selectB.options[selectB.selectedIndex];
                selectB.title = optionB ? optionB.textContent : "";
            }
            if (!selectA || !reports.length) {
                if (selectA) {
                    selectA.selectedIndex = 0;
                    const optionA = selectA.options[selectA.selectedIndex];
                    selectA.title = optionA ? optionA.textContent : "";
                }
                return;
            }
            const latest = reports[0];
            const desired = String(latest.id);
            selectA.value = desired;
            if (selectA.value !== desired) {
                selectA.selectedIndex = 0;
            }
            const option = selectA.options[selectA.selectedIndex];
            selectA.title = option ? option.textContent : "";
            const loaded = await loadReportFromHistory(latest, "A");
            if (!loaded) {
                selectA.value = "";
                selectA.selectedIndex = 0;
                const fallbackOption = selectA.options[selectA.selectedIndex];
                selectA.title = fallbackOption ? fallbackOption.textContent : "";
            }
        }

        /* ========= PDF PARSING HEURISTICS ========= */
        const FUNCTION_TYPES = [
            "Meeting", "Breakout", "Breakfast", "Lunch", "Dinner", "Reception",
            "Cocktail Reception", "Board Meeting", "General Session", "Set Up",
            "Holding Room", "Dance", "Ceremony", "Brunch", "Box Lunch",
            "PM Break", "AM Break", "Coffee Break", "Continuous Break",
            "Hospitality Room", "24 Hour Hold", "Storage", "Office",
            "Registration", "Rehearsal", "Special", "Buffet", "Exhibits",
            "Continental Breakfast", "Teardown", "No Agenda Hold"
        ];

        const FUNCTION_SPACES_HINTS = [
            "Director's Room", "The Founders Room",
            "Legacy Ballroom", "Legacy Ballroom I", "Legacy Ballroom II",
            "Legacy I", "Legacy II", "Legacy Prefunction",
            "The Gallery", "Gallery", "Gallery I", "Gallery II",
            "Gallery Prefunction", "Gallery I Prefunction", "Gallery II Prefunction",
            "The Gallery Lounge",
            "Trade Root Restaurant", "Boardroom", "Envoy", "Diplomat", "Ambassador",
            "Plaza I", "Plaza II", "Plaza III", "Plaza II & III", "Plaza", "Plaza Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V",
            "Salon VI", "Salon VII", "Salon VIII",
            "Prefunction", "2nd Floor Prefunction", "Whitley Prefunction",
            "Consulate", "Delegate", "Attache", "Charge",
            "The Whitley Ballroom", "Whitley Ballroom"
        ];

        const SETUP_STYLES = [
            "Conference", "Rounds of 10", "Rounds of 8", "Rounds of 6",
            "Chevron Theatre", "Schoolroom", "U-Shape", "Hollow Square",
            "Cocktail Rounds", "Theatre", "Special",
            "Crescent Rounds", "Lounge", "Storage"
        ];

        const MATCH_HYPHEN_RE = /[\u2010-\u2015]/g;

        function normalizeForMatch(value) {
            return (value ?? "")
                .toString()
                .replace(MATCH_HYPHEN_RE, "-")
                .replace(/\s+/g, " ")
                .trim()
                .toLowerCase();
        }

        const KNOWN_TYPE_LOOKUP = new Map(FUNCTION_TYPES.map(type => [normalizeForMatch(type), type]));
        const KNOWN_SETUP_LOOKUP = new Map(SETUP_STYLES.map(style => [normalizeForMatch(style), style]));
        const KNOWN_SPACE_LOOKUP = new Map(FUNCTION_SPACES_HINTS.map(space => [normalizeForMatch(space), space]));

        const GROUPINGS = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
        };

        const ROMAN_ORDER = { I: 1, II: 2, III: 3, IV: 4, V: 5, VI: 6, VII: 7, VIII: 8 };

        const MEAL_BREAK_TYPES = new Set([
            "Breakfast", "Lunch", "Dinner", "AM Break", "PM Break",
            "Coffee Break", "Continuous Break", "Box Lunch", "Buffet", "Continental Breakfast"
        ]);

        const FALLBACK_TYPES = new Set([...MEAL_BREAK_TYPES, "Meeting", "Rehearsal", "Exhibits"]);

        const TIME_RANGE_RE = /(\d{1,2}:\d{2}\s?[AP]M)\s*[-–—]\s*(\d{1,2}:\d{2}\s?[AP]M)/i;
        const DATE_LINE_RE = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), .* \d{4}$/i;
        const COUNTS_RE = /^\d+\/\d+\/(?:\d+|__)$/;
        const POST_AS_RE = /Post As[:\-]?\s*(.+)/i;

        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function romanToInt(r) {
            return ROMAN_ORDER[r] ?? 999;
        }

        function splitRomanList(str) {
            const cleaned = str.replace(/\s*(?:&|and)\s*/gi, ",");
            return cleaned
                .split(",")
                .map(p => p.trim().toUpperCase())
                .filter(p => p && /^[IVX]+$/.test(p));
        }

        function expandCompoundPrefix(lineText) {
            const found = new Set();
            const checks = [
                { prefix: "Salon", regex: /\bSalon\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Plaza", regex: /\bPlaza\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Legacy", regex: /\bLegacy\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
            ];
            checks.forEach(({ prefix, regex }) => {
                let match;
                while ((match = regex.exec(lineText))) {
                    splitRomanList(match[1]).forEach(r => found.add(`${prefix} ${r}`));
                }
            });
            return Array.from(found);
        }

        function expandGroupedSpace(lineText, primary) {
            const compound = new Set(expandCompoundPrefix(lineText));

            Object.entries(GROUPINGS).forEach(([ballroom, subs]) => {
                subs.forEach(sub => {
                    const re = new RegExp(`\\b${escapeRegExp(sub)}\\b`);
                    if (re.test(lineText)) compound.add(sub);
                });
            });

            if (/\bAttache\b/i.test(lineText) && /\bCharge\b/i.test(lineText)) {
                return "Attache Charge";
            }

            if (!compound.size) {
                return primary ? primary.trim() : primary;
            }

            const whitley = Array.from(compound).filter(s => s.startsWith("Salon "));
            const plaza = Array.from(compound).filter(s => s.startsWith("Plaza "));
            const legacy = Array.from(compound).filter(s => s.startsWith("Legacy "));

            if (whitley.length) {
                const romans = Array.from(new Set(whitley.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Whitley Ballroom (${romans.map(r => `Salon ${r}`).join(", ")})`;
            }
            if (plaza.length) {
                const romans = Array.from(new Set(plaza.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Plaza Ballroom (${romans.map(r => `Plaza ${r}`).join(", ")})`;
            }
            if (legacy.length) {
                const romans = Array.from(new Set(legacy.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Legacy Ballroom (${romans.map(r => `Legacy ${r}`).join(", ")})`;
            }

            return primary ? primary.trim() : primary;
        }

        function detectFunctionType(text) {
            if (/\bContinental\b/i.test(text)) return "Continental Breakfast";
            const sorted = [...FUNCTION_TYPES].sort((a, b) => b.length - a.length);
            for (const f of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(f)}\\b`, "i");
                if (re.test(text)) return f;
            }
            return null;
        }

        function detectSetupStyle(text) {
            const sorted = [...SETUP_STYLES].sort((a, b) => b.length - a.length);
            for (const s of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(s)}\\b`, "i");
                if (re.test(text)) return s;
            }
            return null;
        }

        function detectSpace(text) {
            for (const hint of FUNCTION_SPACES_HINTS) {
                const re = new RegExp(`\\b${escapeRegExp(hint)}\\b`);
                if (re.test(text)) return hint;
            }
            return null;
        }

        function cleanTimeString(raw) {
            if (!raw) return "";
            const match = raw.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
            if (!match) return raw.trim();
            const hour = String(Number(match[1]));
            const minute = match[2];
            const mod = match[3].toUpperCase();
            return `${hour}:${minute} ${mod}`;
        }

        /* ========= ROOM ORDERING ========= */
        const ROOM_ORDER = [
            "Whitley Ballroom", "Whitley Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII",
            "Plaza Ballroom", "Plaza Prefunction", "Plaza I", "Plaza II", "Plaza III",
            "Gallery", "Gallery Prefunction", "Gallery I", "Gallery II",
            "Legacy Ballroom", "Legacy Prefunction", "Legacy I", "Legacy II",
            "Ambassador", "Attache", "Attache Charge", "Boardroom", "Charge", "Consulate",
            "Delegate", "Diplomat", "Director's Room", "Envoy", "The Founders Room"
        ];
        const SUBORDER = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
            "Gallery": ["Gallery I", "Gallery II"]
        };
        const PARENT_MAP = {};
        Object.entries(SUBORDER).forEach(([p, subs]) => subs.forEach(s => PARENT_MAP[s] = p));

        /* ========= UTILS ========= */
        function parseDayOfEvent(str) {
            if (!str) return null;
            let d = new Date(str);
            if (isNaN(d)) d = new Date(String(str).replace(/^[A-Za-z]+,\s*/, ""));
            return isNaN(d) ? null : d;
        }

        function parseTime(str) {
            if (!str) return [0, 0];
            const parts = String(str).trim().split(" ");
            const timePart = parts[0] || "0:00";
            const mod = (parts[1] || "").toUpperCase();
            const hhmm = timePart.split(":");
            let h = Number(hhmm[0] || 0),
                m = Number(hhmm[1] || 0);
            if (mod === "PM" && h < 12) h += 12;
            if (mod === "AM" && h === 12) h = 0;
            return [h, m];
        }

        function toLocalISODate(d) {
            return d.getFullYear() + "-" + String(d.getMonth() + 1).padStart(2, "0") + "-" + String(d.getDate()).padStart(2, "0");
        }

        function sameDay(a, b) {
            return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
        }

        function formatAMPM(d) {
            let h = d.getHours(),
                m = d.getMinutes(),
                ampm = h >= 12 ? "PM" : "AM";
            h = h % 12;
            h = h ? h : 12;
            m = m < 10 ? "0" + m : m;
            return `${h}:${m} ${ampm}`;
        }

        function monthLabel(d) {
            return d.toLocaleString("en-US", {
                month: "long",
                year: "numeric"
            });
        }

        function weekStart(d) {
            const x = new Date(d);
            const day = x.getDay();
            x.setDate(x.getDate() - day);
            x.setHours(0, 0, 0, 0);
            return x;
        } // Sunday 00:00
        function weekEnd(d) {
            const ws = weekStart(d);
            const we = new Date(ws);
            we.setDate(ws.getDate() + 6);
            we.setHours(23, 59, 59, 999);
            return we;
        }

        function shortTick(d) {
            return d.toLocaleDateString("en-US", {
                weekday: "short",
                month: "numeric",
                day: "numeric"
            });
        }

        function condenseSubs(list) {
            if (!list.length) return "";
            const m = list[0].match(/^([A-Za-z]+(?:\s[A-Za-z]+)?)\s+/);
            let prefix = m ? m[1] + " " : "";
            if (prefix && !list.every(x => x.startsWith(prefix))) prefix = "";
            if (!prefix) return list.join(", ");
            const rest = list.map(x => x.slice(prefix.length)).join(", ");
            return prefix + rest;
        }

        function normalizeRooms(raw) {
            if (!raw) return [];
            let s = String(raw).trim();
            if (s === "The Whitley Ballroom") s = "Whitley Ballroom";
            if (s === "The Gallery") s = "Gallery";
            if (s === "Plaza") s = "Plaza Ballroom";
            if (s === "Founder's Room" || s === "Founders Room") s = "The Founders Room";
            if (s === "Legacy Ballroom I") s = "Legacy I";
            if (s === "Legacy Ballroom II") s = "Legacy II";
            if (s.toLowerCase() === "attache charge") return ["Attache Charge"];
            if (s === "Prefunction") return ["Whitley Prefunction"];
            if (s.includes("(") && s.includes(")")) {
                const inner = s.slice(s.indexOf("(") + 1, s.lastIndexOf(")")).trim();
                if (inner) return inner.split(",").map(x => x.trim());
            }
            if (s.includes(",")) return s.split(",").map(p => p.trim());
            return [s];
        }

        function groupRoomsToLabels(rooms) {
            const byBase = new Map();
            rooms.forEach(r => {
                const base = PARENT_MAP[r] || r;
                const isSub = !!PARENT_MAP[r];
                if (!byBase.has(base)) byBase.set(base, {
                    base,
                    subs: new Set()
                });
                if (isSub) byBase.get(base).subs.add(r);
            });
            const out = [];
            for (const {
                    base,
                    subs
                }
                of byBase.values()) {
                if (subs.size > 0) {
                    const all = SUBORDER[base] || [];
                    if (subs.size === all.length) {
                        out.push({
                            label: base,
                            base
                        });
                    } else {
                        let list = Array.from(subs);
                        if (all.length) list.sort((a, b) => all.indexOf(a) - all.indexOf(b));
                        const condensed = condenseSubs(list);
                        out.push({
                            label: `${base} (${condensed})`,
                            base
                        });
                    }
                } else out.push({
                    label: base,
                    base
                });
            }
            return out;
        }
        // Convert "YYYY-MM-DD" into a Date at LOCAL midnight
        function fromISODateLocal(iso) {
            const [y, m, d] = iso.split("-").map(Number);
            return new Date(y, m - 1, d, 0, 0, 0, 0);
        }

        /* ======== SEARCH FILTER (timeline-only) ======== */
        function buildSuggestions() {
            const names = new Set();
            (reportA || []).forEach(r => {
                if (r["Company Name"]) names.add(r["Company Name"].trim());
                if (r["Event Name"]) names.add(r["Event Name"].trim());
            });
            suggestionsList = Array.from(names).sort((a, b) => a.localeCompare(b));
        }

        function applySearchFilter(rows) {
            if (!searchTerm) return rows;
            const q = searchTerm.toLowerCase();
            // Filter by company OR event name
            return rows.filter(ev => {
                const c = (ev["Company Name"] || "").toLowerCase();
                const e = (ev["Event Name"] || "").toLowerCase();
                return c.includes(q) || e.includes(q);
            });
        }

        /* ========= TOOLTIP FOR DAILY ========= */
        function groupTooltip(room, items, status) {
            items.sort((a, b) => a.start - b.start);
            let html = `<div style="padding:6px;">`;
            if (items[0]?.event) html += `<div style="font-weight:700; margin-bottom:4px;">${items[0].event}</div>`;
            if (status) html += `<div style="margin-bottom:6px"><span style="padding:2px 6px;border-radius:6px;background:#eef;border:1px solid #ccd">${status}</span></div>`;
            html += `<div style="font-weight:600; margin-bottom:4px;">${room}</div>`;
            items.forEach(e => {
                const time = `${formatAMPM(e.start)} – ${formatAMPM(e.end)}`;
                html += `<div><b>${e.function||""}</b> · ${time} · ${e.setup||""}</div>`;
            });
            html += `</div>`;
            return html;
        }

        /* ========= TIMELINE DRAWERS ========= */
        function drawDaily(selectedDateISO) {
            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Room"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(selectedDateISO + "T00:00:00");
            currentDate = chosen;

            const groups = {};
            let dataMin = null,
                dataMax = null;

            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const status = (ev["Event Status"] || "").toString().trim();
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const rooms = normalizeRooms(ev["Function Space"]);
                const company = ev["Company Name"] || "";
                const eventName = ev["Event Name"] || "";
                const labels = groupRoomsToLabels(rooms);

                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        if (sameDay(d, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: start,
                                max: midnight
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start,
                                end: midnight
                            });
                            if (start < groups[key].min) groups[key].min = start;
                            if (midnight > groups[key].max) groups[key].max = midnight;
                            if (!dataMin || start < dataMin) dataMin = start;
                            if (!dataMax || midnight > dataMax) dataMax = midnight;
                        }
                        if (sameDay(nextDay, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + nextDay.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: nextDay,
                                max: endNext
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start: nextDay,
                                end: endNext
                            });
                            if (nextDay < groups[key].min) groups[key].min = nextDay;
                            if (endNext > groups[key].max) groups[key].max = endNext;
                            if (!dataMin || nextDay < dataMin) dataMin = nextDay;
                            if (!dataMax || endNext > dataMax) dataMax = endNext;
                        }
                    });
                    return;
                }

                if (sameDay(d, chosen)) {
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                        if (!groups[key]) groups[key] = {
                            roomLabel: label,
                            base,
                            company,
                            status,
                            items: [],
                            min: start,
                            max: end
                        };
                        groups[key].items.push({
                            event: eventName,
                            function: ev["Function Type"],
                            setup: ev["Setup Style"],
                            start,
                            end
                        });
                        if (start < groups[key].min) groups[key].min = start;
                        if (end > groups[key].max) groups[key].max = end;
                    });
                    if (!dataMin || start < dataMin) dataMin = start;
                    if (!dataMax || end > dataMax) dataMax = end;
                }
            });

            const rows = [];
            const usedBases = new Set();
            ROOM_ORDER.forEach(roomBase => {
                Object.values(groups).forEach(g => {
                    if (g.base === roomBase && sameDay(g.min, chosen)) {
                        usedBases.add(roomBase);
                        rows.push([g.roomLabel, g.company || g.items[0]?.event || "", groupTooltip(g.roomLabel, g.items, g.status), "", g.min, g.max]);
                    }
                });
                if (showAllRooms && !usedBases.has(roomBase)) {
                    const base = dataMin || new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 8, 0);
                    rows.push([roomBase, "", "", "color:#E5E7EB;", base, new Date(base.getTime() + 60000)]);
                }
            });
            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No events found for this date.</p>";
                return;
            }

            dt.addRows(rows);

            // full-day window
            const startHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 0, 0, 0, 0);
            const endHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 23, 59, 59, 999);
            const ticks = [];
            let t = new Date(startHour);
            while (t <= endHour) {
                ticks.push(new Date(t));
                t.setHours(t.getHours() + 1);
            }

            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "h a",
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: startHour,
                        max: endHour
                    }
                },
                timeline: {
                    showBarLabels: true,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });
        }

        /* Weekly: Sun→Sat columns always visible; per company, add day segments (filled when present) */
        function drawWeekly(anyDateISO) {
            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Company"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(anyDateISO + "T00:00:00");
            currentDate = chosen;
            const ws = weekStart(chosen); // Sun 00:00
            const we = weekEnd(chosen); // Sat 23:59:59.999

            // Per-company occupancy by day (from filtered events)
            const perCompany = new Map(); // company -> Map(dayISO -> Set(rooms))
            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const company = ev["Company Name"] || "";
                const rooms = normalizeRooms(ev["Function Space"]);

                const spans = [];
                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    spans.push({
                        s: start,
                        e: midnight
                    });
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    spans.push({
                        s: new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), 0, 0, 0, 0),
                        e: endNext
                    });
                } else {
                    spans.push({
                        s: start,
                        e: end
                    });
                }

                spans.forEach(({
                    s,
                    e
                }) => {
                    // iterate each day from s..e; collect rooms for any day that intersects week
                    let cursor = new Date(s);
                    while (cursor <= e) {
                        const dayStart = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 0, 0, 0, 0);
                        const dayEnd = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 23, 59, 59, 999);
                        if (dayEnd >= ws && dayStart <= we) {
                            if (!perCompany.has(company)) perCompany.set(company, new Map());
                            const dayIso = toLocalISODate(dayStart);
                            if (!perCompany.get(company).has(dayIso)) perCompany.get(company).set(dayIso, new Set());
                            rooms.forEach(r => perCompany.get(company).get(dayIso).add(r));
                        }
                        cursor.setDate(cursor.getDate() + 1);
                        cursor.setHours(0, 0, 0, 0);
                    }
                });
            });

            // Compute overall in-house span per company
            const companySpans = new Map();
            for (const [company, days] of perCompany.entries()) {
                const allDates = Array.from(days.keys()).map(d => fromISODateLocal(d));
                if (allDates.length) {
                    allDates.sort((a, b) => a - b); // earliest to latest
                    companySpans.set(company, {
                        start: allDates[0],
                        end: allDates[allDates.length - 1]
                    });
                }
            }

            // Rows: each company gets 7 day segments (Sun..Sat), filled if they have rooms
            const rows = [];
            const companies = Array.from(perCompany.keys()).sort((a, b) => a.localeCompare(b));
            companies.forEach(company => {
                for (let i = 0; i < 7; i++) {
                    const d = new Date(ws);
                    d.setDate(ws.getDate() + i);
                    const dayIso = toLocalISODate(d);
                    const has = perCompany.get(company).has(dayIso) && perCompany.get(company).get(dayIso).size > 0;
                    const roomsList = has ? Array.from(perCompany.get(company).get(dayIso)).sort() : [];
                    const segStart = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
                    const segEnd = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);
                    const style = has ? "" : "color:#E5E7EB;";

                    const weekRange = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
                    const span = companySpans.get(company);
                    const spanText = span ?
                        `${span.start.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${span.end.toLocaleDateString("en-US",{month:"short",day:"numeric"})}` :
                        "";

                    const tip = `
  <div style="padding:6px;max-width:260px;">
    <div style="font-weight:700;margin-bottom:4px;">${company}</div>
    <div><b>${d.toLocaleDateString("en-US",{weekday:"short", month:"short", day:"numeric"})}</b></div>
    <div style="margin:6px 0;"><i>In-house:</i> ${spanText}</div>
    <div><b>Rooms:</b> ${roomsList.join(", ")}</div>
  </div>
`.trim();


                    rows.push([company, "", tip, style, segStart, segEnd]);
                }
            });

            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No companies intersect this week.</p>";
                return;
            }
            dt.addRows(rows);

            // Axis ticks: always Sun..Sat, labels like "Sun 9/21"
            const ticks = [];
            for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                d.setHours(0, 0, 0, 0); // midnight, not noon
                ticks.push(d);
            }


            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "EEE M/d", // <-- fixed: use pattern, not function
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: new Date(ws),
                        max: new Date(we)
                    }
                },
                timeline: {
                    showBarLabels: false,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });
        }

        /* ========= CHANGE LOG =========
           (Rewritten to compare structured events instead of raw line order.) */
        function generateChangeLog(reportA, reportB) {
            const container = document.getElementById("changeLog");
            container.innerHTML = "";

            if (!reportA.length || !reportB.length) {
                container.innerHTML = "<p style='opacity:.8'>Upload both reports to see changes.</p>";
                return;
            }

            const HYPHEN_RE = /[\u2010-\u2015]/g;

            const cleanValue = value => (value ?? "").toString().replace(HYPHEN_RE, "-").replace(/\s+/g, " ").trim();

            const normalizeText = value => cleanValue(value).toLowerCase();

            const appendNewMarker = (value, isNew) => {
                const base = value || "";
                if (!base || !isNew) return base;
                if (/\(new\)$/i.test(base)) return base;
                return `${base} (new)`;
            };

            const isKnownType = value => {
                const normalized = normalizeForMatch(value);
                return !!normalized && KNOWN_TYPE_LOOKUP.has(normalized);
            };

            const isKnownSetup = value => {
                const normalized = normalizeForMatch(value);
                return !!normalized && KNOWN_SETUP_LOOKUP.has(normalized);
            };

            const isKnownSpace = value => {
                const normalized = normalizeForMatch(value);
                if (!normalized) return false;
                if (KNOWN_SPACE_LOOKUP.has(normalized)) return true;
                const base = value.includes("(") ? value.split("(")[0].trim() : "";
                if (base) {
                    const baseNorm = normalizeForMatch(base);
                    if (KNOWN_SPACE_LOOKUP.has(baseNorm)) return true;
                }
                return false;
            };

            function normalizeStatus(value) {
                const raw = normalizeText(value);
                if (!raw) return "";
                if (raw.includes("definite")) return "definite";
                if (raw === "t1/t2" || raw === "t1t2") return "t1/t2";
                if (raw === "t1") return "t1";
                if (raw === "t2") return "t2";
                if (raw === "hold" || raw === "holding" || raw === "tentative") return "hold";
                return raw;
            }

            function normalizeTime(value) {
                const raw = cleanValue(value);
                if (!raw) return { key: "", minutes: null, display: "" };

                const compactMatch = raw.match(/^(\d{1,2})(?::(\d{1,2}))?\s*(AM|PM)?$/i);
                if (compactMatch) {
                    let h = Number(compactMatch[1]);
                    let m = Number(compactMatch[2] || "0");
                    const mod = (compactMatch[3] || "").toUpperCase();
                    if (!Number.isNaN(h) && !Number.isNaN(m)) {
                        if (mod === "PM" && h < 12) h += 12;
                        if (mod === "AM" && h === 12) h = 0;
                        const key = `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
                        const stub = new Date(2000, 0, 1, h, m);
                        return { key, minutes: h * 60 + m, display: formatAMPM(stub) };
                    }
                }

                const [ph, pm] = parseTime(raw);
                if (!Number.isNaN(ph) && !Number.isNaN(pm)) {
                    const key = `${String(ph).padStart(2, "0")}:${String(pm).padStart(2, "0")}`;
                    const stub = new Date(2000, 0, 1, ph, pm);
                    return { key, minutes: ph * 60 + pm, display: formatAMPM(stub) };
                }

                return { key: raw.toLowerCase(), minutes: null, display: raw };
            }

            function normalizeDate(value) {
                const raw = cleanValue(value);
                const parsed = parseDayOfEvent(raw);
                const display = raw || (parsed ? parsed.toLocaleDateString("en-US", {
                    weekday: "long",
                    month: "long",
                    day: "numeric",
                    year: "numeric"
                }) : "");
                const key = parsed ? toLocalISODate(parsed) : display.toLowerCase();
                return { parsed, key, display };
            }

            const buildKey = parts => parts.map(p => p || "").join("||");

            function eventRange(events) {
                let start = null;
                let end = null;
                events.forEach(ev => {
                    const d = parseDayOfEvent(ev["Day of Event"]);
                    if (!d) return;
                    if (!start || d < start) start = d;
                    if (!end || d > end) end = d;
                });
                return start && end ? { start, end } : null;
            }

            function intersectRanges(a, b) {
                if (!a || !b) return null;
                const start = a.start > b.start ? a.start : b.start;
                const end = a.end < b.end ? a.end : b.end;
                return start > end ? null : { start, end };
            }

            const rangeA = eventRange(reportA);
            const rangeB = eventRange(reportB);
            const overlap = intersectRanges(rangeA, rangeB);

            if (!overlap) {
                container.innerHTML = "<p style='opacity:.7'>No overlapping dates between the reports.</p>";
                return;
            }

            const withinOverlap = parsedDate => parsedDate && parsedDate >= overlap.start && parsedDate <= overlap.end;

            const buildEvent = (ev, index) => {
                const dateInfo = normalizeDate(ev["Day of Event"]);
                if (!withinOverlap(dateInfo.parsed)) return null;

                const startInfo = normalizeTime(ev["Start Time"]);
                const endInfo = normalizeTime(ev["End Time"]);

                const flags = ev.__flags || {};
                const rawSpace = cleanValue(ev["Function Space"]);
                const rawType = cleanValue(ev["Function Type"]);
                const rawSetup = cleanValue(ev["Setup Style"]);
                const spaceIsNew = flags.spaceNew !== undefined ? flags.spaceNew : (!!rawSpace && !isKnownSpace(rawSpace));
                const typeIsNew = flags.typeNew !== undefined ? flags.typeNew : (!!rawType && !isKnownType(rawType));
                const setupIsNew = flags.setupNew !== undefined ? flags.setupNew : (!!rawSetup && !isKnownSetup(rawSetup));
                const companyDisplay = cleanValue(ev["Company Name"]);
                const eventDisplay = cleanValue(ev["Event Name"]);
                const spaceDisplay = appendNewMarker(rawSpace, spaceIsNew);
                const typeDisplay = appendNewMarker(rawType, typeIsNew);
                const setupDisplay = appendNewMarker(rawSetup, setupIsNew);
                const postAsDisplay = cleanValue(ev["Post As"]);
                const statusDisplay = cleanValue(ev["Event Status"]);

                const normalizedCompany = normalizeText(ev["Company Name"]);
                const normalizedEvent = normalizeText(ev["Event Name"]);
                const normalizedSpace = normalizeText(ev["Function Space"]);
                const normalizedType = normalizeText(ev["Function Type"]);
                const normalizedSetup = normalizeText(ev["Setup Style"]);
                const normalizedPostAs = normalizeText(ev["Post As"]);
                const normalizedStatus = normalizeStatus(statusDisplay);

                const keys = {
                    full: buildKey([normalizedCompany, dateInfo.key, startInfo.key, endInfo.key, normalizedSpace, normalizedType, normalizedSetup, normalizedPostAs]),
                    withoutStart: buildKey([normalizedCompany, dateInfo.key, endInfo.key, normalizedSpace, normalizedType, normalizedSetup, normalizedPostAs]),
                    withoutEnd: buildKey([normalizedCompany, dateInfo.key, startInfo.key, normalizedSpace, normalizedType, normalizedSetup, normalizedPostAs]),
                    withoutTime: buildKey([normalizedCompany, dateInfo.key, normalizedSpace, normalizedType, normalizedSetup, normalizedPostAs]),
                    withoutSpace: buildKey([normalizedCompany, dateInfo.key, startInfo.key, endInfo.key, normalizedType, normalizedSetup, normalizedPostAs]),
                    withoutType: buildKey([normalizedCompany, dateInfo.key, startInfo.key, endInfo.key, normalizedSpace, normalizedSetup, normalizedPostAs]),
                    withoutSetup: buildKey([normalizedCompany, dateInfo.key, startInfo.key, endInfo.key, normalizedSpace, normalizedType, normalizedPostAs]),
                    withoutPost: buildKey([normalizedCompany, dateInfo.key, startInfo.key, endInfo.key, normalizedSpace, normalizedType, normalizedSetup]),
                    eventTitle: normalizedEvent ? buildKey([normalizedCompany, dateInfo.key, normalizedEvent]) : "",
                    postTitle: normalizedPostAs ? buildKey([normalizedCompany, dateInfo.key, normalizedPostAs]) : "",
                    companyDate: buildKey([normalizedCompany, dateInfo.key])
                };

                return {
                    index,
                    normalized: {
                        company: normalizedCompany,
                        event: normalizedEvent,
                        dateKey: dateInfo.key,
                        start: startInfo.key,
                        end: endInfo.key,
                        startMinutes: startInfo.minutes,
                        endMinutes: endInfo.minutes,
                        space: normalizedSpace,
                        type: normalizedType,
                        setup: normalizedSetup,
                        postAs: normalizedPostAs,
                        status: normalizedStatus
                    },
                    display: {
                        date: dateInfo.display,
                        start: startInfo.display,
                        end: endInfo.display,
                        company: companyDisplay,
                        event: eventDisplay,
                        space: spaceDisplay,
                        type: typeDisplay,
                        setup: setupDisplay,
                        postAs: postAsDisplay,
                        status: statusDisplay
                    },
                    keys,
                    dateValue: dateInfo.parsed ? dateInfo.parsed.getTime() : Infinity,
                    startValue: startInfo.minutes != null ? startInfo.minutes : Infinity,
                    endValue: endInfo.minutes != null ? endInfo.minutes : Infinity,
                    matched: false
                };
            };

            const previousEvents = reportB.map((ev, index) => buildEvent(ev, index)).filter(Boolean);
            const newestEvents = reportA.map((ev, index) => buildEvent(ev, index)).filter(Boolean);

            if (!previousEvents.length && !newestEvents.length) {
                container.innerHTML = "<p style='opacity:.7'>✅ No changes detected between the reports.</p>";
                return;
            }

            const compareNumbers = (a, b) => {
                const valA = Number.isFinite(a) ? a : Infinity;
                const valB = Number.isFinite(b) ? b : Infinity;
                if (valA === valB) return 0;
                return valA < valB ? -1 : 1;
            };

            const compareStable = (a, b) => {
                const dateDiff = compareNumbers(a.dateValue, b.dateValue);
                if (dateDiff) return dateDiff;
                const startDiff = compareNumbers(a.startValue, b.startValue);
                if (startDiff) return startDiff;
                const endDiff = compareNumbers(a.endValue, b.endValue);
                if (endDiff) return endDiff;
                const spaceDiff = a.normalized.space.localeCompare(b.normalized.space);
                if (spaceDiff) return spaceDiff;
                const typeDiff = a.normalized.type.localeCompare(b.normalized.type);
                if (typeDiff) return typeDiff;
                const setupDiff = a.normalized.setup.localeCompare(b.normalized.setup);
                if (setupDiff) return setupDiff;
                const postDiff = a.normalized.postAs.localeCompare(b.normalized.postAs);
                if (postDiff) return postDiff;
                const companyDiff = a.normalized.company.localeCompare(b.normalized.company);
                if (companyDiff) return companyDiff;
                return a.normalized.event.localeCompare(b.normalized.event);
            };

            const sortForSignature = events => events.slice().sort(compareStable);

            const computeReportHash = events => {
                const canonical = sortForSignature(events).map(ev => ({
                    company: ev.normalized.company || "",
                    date: ev.normalized.dateKey || "",
                    start: ev.normalized.start || "",
                    end: ev.normalized.end || "",
                    space: ev.normalized.space || "",
                    type: ev.normalized.type || "",
                    setup: ev.normalized.setup || "",
                    postAs: ev.normalized.postAs || "",
                    status: ev.normalized.status || "",
                    event: ev.normalized.event || ""
                }));
                const payload = JSON.stringify(canonical);
                let hash = 0x811c9dc5;
                for (let i = 0; i < payload.length; i++) {
                    hash ^= payload.charCodeAt(i);
                    hash = (hash * 0x01000193) >>> 0;
                }
                return hash.toString(16);
            };

            const previousHash = computeReportHash(previousEvents);
            const newestHash = computeReportHash(newestEvents);

            if (previousHash === newestHash) {
                container.innerHTML = "<p style='opacity:.7'>✅ No changes detected between the reports.</p>";
                return;
            }

            const variantOrder = [
                "full",
                "withoutStart",
                "withoutEnd",
                "withoutTime",
                "withoutSpace",
                "withoutType",
                "withoutSetup",
                "withoutPost",
                "eventTitle",
                "postTitle",
                "companyDate"
            ];

            const indexes = variantOrder.reduce((acc, key) => {
                acc[key] = new Map();
                return acc;
            }, {});

            const register = ev => {
                variantOrder.forEach(variant => {
                    const key = ev.keys[variant];
                    if (!key) return;
                    if (!indexes[variant].has(key)) indexes[variant].set(key, []);
                    indexes[variant].get(key).push(ev);
                });
            };

            newestEvents
                .slice()
                .sort(compareStable)
                .forEach(register);

            const takeMatch = (variant, prevEvent) => {
                const key = prevEvent.keys[variant];
                if (!key) return null;
                const bucket = indexes[variant].get(key);
                if (!bucket) return null;
                if (variant === "companyDate") {
                    const available = bucket.filter(ev => !ev.matched);
                    if (available.length !== 1) return null;
                    const candidate = available[0];
                    candidate.matched = true;
                    return candidate;
                }
                for (const candidate of bucket) {
                    if (!candidate.matched) {
                        candidate.matched = true;
                        return candidate;
                    }
                }
                return null;
            };

            const makeFieldDiff = (field, prevValue, newValue) => ({
                type: "field",
                field,
                prev: prevValue || "—",
                newest: newValue || "—"
            });

            const describeEventSnapshot = snapshot => {
                if (!snapshot) return "—";
                const pieces = [];
                const startLabel = snapshot.display?.start;
                const endLabel = snapshot.display?.end;
                if (startLabel || endLabel) {
                    if (startLabel && endLabel) {
                        pieces.push(`${startLabel} – ${endLabel}`);
                    } else {
                        pieces.push(startLabel || endLabel);
                    }
                }
                if (snapshot.display?.space) pieces.push(snapshot.display.space);
                if (snapshot.display?.setup) pieces.push(snapshot.display.setup);
                const detail = pieces.filter(Boolean).join(" · ");
                return detail || snapshot.display?.date || "—";
            };

            const formatHeader = (space, type) => {
                if (space && type) return `${space} — ${type}`;
                return space || type || "";
            };

            const buildChange = (kind, latest, previous, diffs) => {
                const newest = latest || null;
                const older = previous || null;
                const companyDisplay = newest?.display.company || older?.display.company || "—";
                const eventDisplay = newest?.display.event || older?.display.event || newest?.display.postAs || older?.display.postAs || "";
                const postLabel = newest?.display.postAs || older?.display.postAs || "";
                let header = "";

                if (kind === "removed") {
                    header = formatHeader(older?.display.space, older?.display.type);
                } else if (kind === "added") {
                    header = formatHeader(newest?.display.space, newest?.display.type);
                } else {
                    const prevHeader = formatHeader(older?.display.space, older?.display.type);
                    const newHeader = formatHeader(newest?.display.space, newest?.display.type);
                    if (newest && older && (newest.normalized.space !== older.normalized.space || newest.normalized.type !== older.normalized.type)) {
                        header = prevHeader && newHeader ? `${prevHeader} → ${newHeader}` : newHeader || prevHeader;
                    } else {
                        header = newHeader || prevHeader;
                    }
                }

                const dateText = kind === "removed" ? (older?.display.date || "") : (newest?.display.date || "");
                const dateValue = kind === "removed" ? (older?.dateValue ?? Infinity) : (newest?.dateValue ?? Infinity);
                const startValue = kind === "removed" ? (older?.startValue ?? Infinity) : (newest?.startValue ?? Infinity);
                const endValue = kind === "removed" ? (older?.endValue ?? Infinity) : (newest?.endValue ?? Infinity);
                const rangeStart = Math.min(older?.dateValue ?? Infinity, newest?.dateValue ?? Infinity);
                const rangeEnd = Math.max(older?.dateValue ?? -Infinity, newest?.dateValue ?? -Infinity);
                const companyKey = newest?.normalized.company || older?.normalized.company || "";
                const eventKey = newest?.normalized.event || older?.normalized.event || newest?.normalized.postAs || older?.normalized.postAs || "";

                let badge = null;
                if (kind === "added") {
                    badge = { label: "New", className: "badge-new" };
                } else if (kind === "removed") {
                    badge = { label: "Removed", className: "badge-removed" };
                } else if (kind === "updated") {
                    badge = { label: "Changed", className: "badge-changed" };
                }

                return {
                    company: companyDisplay,
                    companyKey,
                    eventName: eventDisplay,
                    eventKey,
                    header,
                    pas: postLabel,
                    badge,
                    date: dateText,
                    diffs,
                    dateValue,
                    startValue,
                    endValue,
                    rangeStart,
                    rangeEnd
                };
            };

            const computeDiffs = (latest, previous) => {
                const diffs = [];
                if (latest.normalized.type !== previous.normalized.type) {
                    diffs.push(makeFieldDiff("Function Type", previous.display.type, latest.display.type));
                }
                if (latest.normalized.start !== previous.normalized.start) {
                    diffs.push(makeFieldDiff("Start Time", previous.display.start, latest.display.start));
                }
                if (latest.normalized.end !== previous.normalized.end) {
                    diffs.push(makeFieldDiff("End Time", previous.display.end, latest.display.end));
                }
                if (latest.normalized.space !== previous.normalized.space) {
                    diffs.push(makeFieldDiff("Function Space", previous.display.space, latest.display.space));
                }
                if (latest.normalized.setup !== previous.normalized.setup) {
                    diffs.push(makeFieldDiff("Setup Style", previous.display.setup, latest.display.setup));
                }
                if (latest.normalized.postAs !== previous.normalized.postAs) {
                    diffs.push(makeFieldDiff("Post As", previous.display.postAs, latest.display.postAs));
                }
                if (latest.normalized.status !== previous.normalized.status) {
                    diffs.push(makeFieldDiff("Status", previous.display.status, latest.display.status));
                }
                return diffs;
            };

            const changes = [];

            previousEvents.forEach(prev => {
                let match = null;
                for (const variant of variantOrder) {
                    match = takeMatch(variant, prev);
                    if (match) break;
                }

                if (match) {
                    const diffs = computeDiffs(match, prev);
                    if (diffs.length) {
                        changes.push(buildChange("updated", match, prev, diffs));
                    }
                } else {
                    const detail = describeEventSnapshot(prev);
                    changes.push(buildChange("removed", null, prev, [{ type: "note", message: `Event removed: ${detail}` }]));
                }
            });

            newestEvents.forEach(ev => {
                if (!ev.matched) {
                    const detail = describeEventSnapshot(ev);
                    changes.push(buildChange("added", ev, null, [{ type: "note", message: `New event added: ${detail}` }]));
                }
            });

            if (!changes.length) {
                container.innerHTML = "<p style='opacity:.7'>✅ No changes detected between the reports.</p>";
                return;
            }

            const anchorValue = overlap.start.getTime();
            const companyBuckets = new Map();

            changes.forEach(change => {
                const key = change.company || "—";
                if (!companyBuckets.has(key)) {
                    companyBuckets.set(key, {
                        company: key,
                        companyKey: change.companyKey || "",
                        events: [],
                        rangeStart: change.rangeStart,
                        rangeEnd: change.rangeEnd
                    });
                }
                const bucket = companyBuckets.get(key);
                bucket.events.push(change);
                if (Number.isFinite(change.rangeStart) && (bucket.rangeStart === undefined || change.rangeStart < bucket.rangeStart)) {
                    bucket.rangeStart = change.rangeStart;
                }
                if (Number.isFinite(change.rangeEnd) && (bucket.rangeEnd === undefined || change.rangeEnd > bucket.rangeEnd)) {
                    bucket.rangeEnd = change.rangeEnd;
                }
            });

            const companies = Array.from(companyBuckets.values()).map(bucket => {
                const start = Number.isFinite(bucket.rangeStart) ? bucket.rangeStart : Infinity;
                const end = Number.isFinite(bucket.rangeEnd) ? bucket.rangeEnd : -Infinity;
                bucket.inHouse = start <= anchorValue && end >= anchorValue;
                bucket.startSort = start;
                return bucket;
            }).sort((a, b) => {
                if (a.inHouse !== b.inHouse) return a.inHouse ? -1 : 1;
                const startCompare = compareNumbers(a.startSort, b.startSort);
                if (startCompare) return startCompare;
                return (a.companyKey || "").localeCompare(b.companyKey || "");
            });

            companies.forEach(bucket => {
                const compHeader = document.createElement("div");
                compHeader.className = "company-header";
                compHeader.textContent = bucket.company;
                container.appendChild(compHeader);

                bucket.events.sort((a, b) => {
                    const dateCompare = compareNumbers(a.dateValue, b.dateValue);
                    if (dateCompare) return dateCompare;
                    const startCompare = compareNumbers(a.startValue, b.startValue);
                    if (startCompare) return startCompare;
                    const endCompare = compareNumbers(a.endValue, b.endValue);
                    if (endCompare) return endCompare;
                    return (a.eventKey || "").localeCompare(b.eventKey || "");
                });

                let lastEventKey = null;
                bucket.events.forEach(change => {
                    if (change.eventName && change.eventKey !== lastEventKey) {
                        const eventHeader = document.createElement("div");
                        eventHeader.className = "event-header";
                        eventHeader.textContent = change.eventName;
                        container.appendChild(eventHeader);
                        lastEventKey = change.eventKey;
                    } else if (change.eventKey !== lastEventKey) {
                        lastEventKey = change.eventKey;
                    }

                    const card = document.createElement("div");
                    card.className = "change-card";
                    const badgeHtml = change.badge ? `<span class="badge ${change.badge.className}">${change.badge.label}</span>` : "";
                    const headerText = (change.header || "").trim();
                    const hasHeaderText = headerText.length > 0;
                    const postSpacing = change.pas ? (hasHeaderText ? " " : (badgeHtml ? " " : "")) : "";
                    const postPrefix = change.pas ? (hasHeaderText ? "· " : "") : "";
                    const postHtml = change.pas ? `${postSpacing}<span class="post-label">${postPrefix}${change.pas}</span>` : "";
                    card.innerHTML = `
            <h4>${badgeHtml}${headerText}${postHtml}</h4>
            <div style="font-size:.8rem;color:#555;margin-bottom:4px;">${change.date}</div>
            <ul>
              ${change.diffs.map(d => {
                        if (d.type === "note") {
                            return `<li>${d.message}</li>`;
                        }
                        const label = d.field ? `${d.field}: ` : "";
                        const prev = d.prev !== undefined ? `<span class="change-prev">${d.prev}</span>` : "";
                        const newest = d.newest !== undefined ? `<span class="change-new">${d.newest}</span>` : "";
                        const arrow = prev && newest ? " → " : "";
                        return `<li>${label}${prev}${arrow}${newest}</li>`;
                    }).join("") }
            </ul>`;
                    container.appendChild(card);
                });
            });
        }
        /* ========= FORECAST (unchanged) ========= */
        function renderForecast() {
            const host = document.getElementById("forecast");
            host.innerHTML = "";

            if (!reportA.length) {
                host.innerHTML = "<p style='opacity:.8'>Upload the newest report to view today’s schedule summary.</p>";
                return;
            }

            const now = new Date();
            const todayISO = toLocalISODate(now);

            const todays = reportA.filter(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                return d && toLocalISODate(d) === todayISO;
            });

            if (!todays.length) {
                host.innerHTML = "<p style='opacity:.8'>No events scheduled for today.</p>";
                return;
            }

            const entries = todays.map(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                return {
                    company: ev["Company Name"] || "",
                    event: ev["Event Name"] || "",
                    space: ev["Function Space"] || "",
                    start: new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm),
                    end: new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em),
                };
            });

            const merged = (() => {
                const map = new Map();
                entries.forEach(e => {
                    const key = `${e.company}||${e.space}`;
                    if (!map.has(key)) {
                        map.set(key, {
                            company: e.company,
                            space: e.space,
                            start: new Date(e.start),
                            end: new Date(e.end),
                            events: [e.event]
                        });
                    } else {
                        const g = map.get(key);
                        if (e.start < g.start) g.start = new Date(e.start);
                        if (e.end > g.end) g.end = new Date(e.end);
                        g.events.push(e.event);
                    }
                });
                return Array.from(map.values()).sort((a, b) => a.start - b.start);
            })();

            const companyGroups = {};
            entries.forEach(ev => {
                if (!companyGroups[ev.company]) companyGroups[ev.company] = {};
                if (!companyGroups[ev.company][ev.event]) companyGroups[ev.company][ev.event] = new Set();
                companyGroups[ev.company][ev.event].add(ev.space);
            });

            const compCard = document.createElement("div");
            compCard.className = "forecast-card";
            compCard.innerHTML = "<h3>Companies & Function Spaces</h3>";
            for (const [company, events] of Object.entries(companyGroups)) {
                const group = document.createElement("div");
                group.className = "company-group";
                group.innerHTML = `<div class="company-name">${company}</div>`;
                for (const [event, spaces] of Object.entries(events)) {
                    const evBlock = document.createElement("div");
                    evBlock.className = "event-block";
                    evBlock.innerHTML = `<div class="event-title">${event}</div><div>${Array.from(spaces).map(s=>`<span class="space-pill">${s}</span>`).join("")}</div>`;
                    group.appendChild(evBlock);
                }
                compCard.appendChild(group);
            }
            host.appendChild(compCard);

            const nowList = merged.filter(e => now >= e.start && now < e.end);
            const nextList = merged.filter(e => e.start > now);

            const happeningCard = document.createElement("div");
            happeningCard.className = "forecast-card happening";
            happeningCard.innerHTML = "<h3>What's Happening</h3>";

            const renderSection = (title, list, cls) => {
                const sec = document.createElement("div");
                sec.className = `section ${cls}`;
                sec.innerHTML = `<strong>${title}</strong>`;
                if (!list.length) {
                    sec.innerHTML += `<p style='opacity:.7;font-size:.85rem'>No events</p>`;
                } else {
                    list.forEach(e => {
                        const row = document.createElement("div");
                        row.className = "happening-row";
                        row.innerHTML = `<span><b>${e.company}</b> — ${e.space}</span><span>${formatAMPM(e.start)} – ${formatAMPM(e.end)}</span>`;
                        sec.appendChild(row);
                    });
                }
                happeningCard.appendChild(sec);
            };

            renderSection("Now", nowList, "now");
            renderSection("Next", nextList, "next");
            host.appendChild(happeningCard);

            const byRoom = {};
            entries.forEach(e => {
                (byRoom[e.space] ||= []).push(e);
            });
            const flips = [];
            Object.values(byRoom).forEach(list => {
                list.sort((a, b) => a.start - b.start);
                for (let i = 1; i < list.length; i++) {
                    const prev = list[i - 1],
                        curr = list[i];
                    const gap = (curr.start - prev.end) / 60000;
                    if (gap >= 0 && gap <= 30 && prev.company !== curr.company) {
                        flips.push({
                            room: curr.space,
                            prev,
                            curr,
                            gap
                        });
                    }
                }
            });
            if (flips.length) {
                const warn = document.createElement("div");
                warn.className = "warning-box";
                warn.innerHTML = "<h3 style='margin:0 0 8px 0;color:#facc15;'>Warnings: Quick Room Flips</h3>";
                flips.forEach(f => {
                    const box = document.createElement("div");
                    box.innerHTML = `<strong>${f.room}</strong> ${f.prev.company} (${formatAMPM(f.prev.start)} – ${formatAMPM(f.prev.end)}) → ${f.curr.company} (${formatAMPM(f.curr.start)} – ${formatAMPM(f.curr.end)})`;
                    warn.appendChild(box);
                });
                host.appendChild(warn);
            }
        }

        /* ========= PDF UPLOAD ========= */
        async function extractPdfLines(file) {
            if (!window.pdfjsLib) {
                throw new Error("PDF.js library is not available");
            }
            const data = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data }).promise;
            const lines = [];

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();
                const items = textContent.items
                    .map(item => ({
                        text: (item.str || "").trim(),
                        x: item.transform?.[4] ?? 0,
                        y: item.transform?.[5] ?? 0
                    }))
                    .filter(item => item.text);

                items.sort((a, b) => {
                    const yDiff = Math.abs(b.y - a.y);
                    if (yDiff > 2) {
                        return b.y - a.y; // top to bottom
                    }
                    return a.x - b.x; // left to right
                });

                let currentY = null;
                let row = [];
                items.forEach(item => {
                    if (currentY === null || Math.abs(item.y - currentY) <= 2) {
                        row.push({ text: item.text, x: item.x });
                        currentY = item.y;
                    } else {
                        if (row.length) lines.push(row);
                        row = [{ text: item.text, x: item.x }];
                        currentY = item.y;
                    }
                });
                if (row.length) {
                    lines.push(row);
                }
            }

            return lines;
        }

        async function loadPDF(file, target) {
            const lines = await extractPdfLines(file);
            const rows = [];

            let currentCompany = null;
            let currentEvent = null;
            let currentDateStr = null;
            let currentStatus = null;
            let inEventHeader = false;
            let inEventBody = false;
            const lastSpaceByEvent = new Map();
            const columnAnchors = [];
            const COLUMN_TOLERANCE = 18;
            const TIME_CELL_RE = /^\d{1,2}:\d{2}\s*[AP]M$/i;
            const TIME_VALUE_RE = /(\d{1,2}:\d{2}\s*[AP]M)/i;

            const columnIndexFor = x => {
                for (let i = 0; i < columnAnchors.length; i++) {
                    if (Math.abs(columnAnchors[i] - x) <= COLUMN_TOLERANCE) {
                        return i;
                    }
                }
                columnAnchors.push(x);
                return columnAnchors.length - 1;
            };

            const looksLikeSpace = text => /room|ballroom|prefunction|salon|plaza|gallery|terrace|suite|boardroom|hall|lounge|garden|patio|veranda|atrium|club|floor|court|center|centre|rooftop|pool/i.test(text);
            const looksLikeSetup = text => /round|theatre|theater|school|class|u-shape|hollow|conference|board|lounge|cocktail|banquet|reception|square|chevron|crescent|classroom|set/i.test(text);

            for (const parts of lines) {
                const lineText = parts.map(item => item.text).join(' ').replace(/\s+/g, ' ').trim();
                if (!lineText) {
                    continue;
                }

                if (lineText.includes("Quote #:")) {
                    currentCompany = lineText.split("Quote #:")[0].trim();
                    inEventHeader = true;
                    inEventBody = false;
                    continue;
                }

                if (lineText.includes("Status:")) {
                    const statusMatch = lineText.match(/Status:\s*(\w+)/i);
                    if (statusMatch) {
                        currentStatus = statusMatch[1].trim();
                    }
                    continue;
                }

                if (lineText.includes("Folio #:")) {
                    const evMatch = lineText.match(/(.+?)\s+Folio #:/);
                    if (evMatch) {
                        currentEvent = evMatch[1].trim();
                        inEventHeader = true;
                        inEventBody = false;
                    }
                    continue;
                }

                if (DATE_LINE_RE.test(lineText)) {
                    currentDateStr = lineText.trim();
                    continue;
                }

                const postMatch = lineText.match(POST_AS_RE);
                if (postMatch && rows.length && inEventBody) {
                    const last = rows[rows.length - 1];
                    if (last["Function Space"] && !last["Post As"]) {
                        last["Post As"] = postMatch[1].trim();
                    }
                    continue;
                }
                if (postMatch && inEventHeader) {
                    continue;
                }

                const timeRangeMatch = lineText.match(TIME_RANGE_RE);
                const cellTimes = parts
                    .map(item => {
                        const match = item.text.match(TIME_VALUE_RE);
                        return match ? cleanTimeString(match[1]) : null;
                    })
                    .filter(Boolean);

                const hasTime = !!timeRangeMatch || cellTimes.length >= 2;
                if (!hasTime) {
                    continue;
                }

                let startTime = timeRangeMatch ? cleanTimeString(timeRangeMatch[1]) : (cellTimes[0] || "");
                let endTime = timeRangeMatch ? cleanTimeString(timeRangeMatch[2]) : (cellTimes[1] || "");
                if (!startTime || !endTime) {
                    continue;
                }

                const columns = [];
                parts.forEach(item => {
                    const token = item.text;
                    if (!token || /^[-–—]$/.test(token)) {
                        return;
                    }
                    const idx = columnIndexFor(item.x);
                    if (!columns[idx]) {
                        columns[idx] = [];
                    }
                    columns[idx].push(token);
                });

                const columnTexts = columns.map(col => (col || []).join(' ').replace(/\s+/g, ' ').trim());
                const columnMeta = columnTexts.map((text, idx) => {
                    const normalized = normalizeForMatch(text);
                    const isEmpty = !text;
                    const isTime = !!text && TIME_CELL_RE.test(text);
                    const normalizedNoSpace = text.replace(/\s+/g, '');
                    return {
                        idx,
                        text,
                        normalized,
                        isEmpty,
                        isTime,
                        typeKnown: normalized ? KNOWN_TYPE_LOOKUP.has(normalized) : false,
                        setupKnown: normalized ? KNOWN_SETUP_LOOKUP.has(normalized) : false,
                        spaceKnown: normalized ? KNOWN_SPACE_LOOKUP.has(normalized) : false,
                        looksLikeSpace: text ? looksLikeSpace(text) : false,
                        looksLikeSetup: text ? looksLikeSetup(text) : false,
                        isCount: normalizedNoSpace ? COUNTS_RE.test(normalizedNoSpace) : false
                    };
                });

                let startIndex = null;
                let endIndex = null;
                columnMeta.forEach(meta => {
                    if (meta.isTime && startIndex === null) {
                        startIndex = meta.idx;
                    } else if (meta.isTime && endIndex === null) {
                        endIndex = meta.idx;
                    }
                });

                inEventHeader = false;
                inEventBody = true;

                const valueColumns = columnMeta
                    .filter(meta => !meta.isEmpty && !meta.isTime && !meta.isCount)
                    .sort((a, b) => a.idx - b.idx);

                const remainingMetas = [...valueColumns];
                const pullMeta = predicate => {
                    const index = remainingMetas.findIndex(predicate);
                    if (index === -1) return null;
                    return remainingMetas.splice(index, 1)[0];
                };

                let spaceMeta = pullMeta(meta => meta.spaceKnown);
                if (!spaceMeta) spaceMeta = pullMeta(meta => meta.looksLikeSpace);

                let typeMeta = pullMeta(meta => meta.typeKnown);
                if (!typeMeta) typeMeta = pullMeta(meta => !meta.looksLikeSpace && !meta.looksLikeSetup);

                let setupMeta = pullMeta(meta => meta.setupKnown);
                if (!setupMeta) setupMeta = pullMeta(meta => meta.looksLikeSetup);

                if (!spaceMeta && remainingMetas.length) spaceMeta = remainingMetas.shift();
                if (!typeMeta && remainingMetas.length) typeMeta = remainingMetas.shift();
                if (!setupMeta && remainingMetas.length) setupMeta = remainingMetas.shift();

                const columnTypeText = typeMeta ? typeMeta.text : "";
                const columnSpaceText = spaceMeta ? spaceMeta.text : "";
                const columnSetupText = setupMeta ? setupMeta.text : "";

                const detectedType = detectFunctionType(lineText);
                let functionType = "";
                if (columnTypeText) {
                    const normalizedType = normalizeForMatch(columnTypeText);
                    if (normalizedType && KNOWN_TYPE_LOOKUP.has(normalizedType)) {
                        functionType = KNOWN_TYPE_LOOKUP.get(normalizedType);
                    } else {
                        functionType = columnTypeText;
                    }
                } else if (detectedType) {
                    functionType = detectedType;
                }

                const detectedSetup = detectSetupStyle(lineText);
                let setupStyle = "";
                if (columnSetupText) {
                    const normalizedSetup = normalizeForMatch(columnSetupText);
                    if (normalizedSetup && KNOWN_SETUP_LOOKUP.has(normalizedSetup)) {
                        setupStyle = KNOWN_SETUP_LOOKUP.get(normalizedSetup);
                    } else {
                        setupStyle = columnSetupText;
                    }
                } else if (detectedSetup) {
                    setupStyle = detectedSetup;
                }

                let functionSpace = "";
                let spaceSourceKnown = false;
                if (columnSpaceText) {
                    if (spaceMeta?.spaceKnown) {
                        spaceSourceKnown = true;
                    }
                    const normalizedSpaceColumn = normalizeForMatch(columnSpaceText);
                    if (normalizedSpaceColumn && KNOWN_SPACE_LOOKUP.has(normalizedSpaceColumn)) {
                        functionSpace = KNOWN_SPACE_LOOKUP.get(normalizedSpaceColumn);
                        spaceSourceKnown = true;
                    } else {
                        functionSpace = columnSpaceText;
                    }
                } else {
                    const detectedSpace = detectSpace(lineText);
                    if (detectedSpace) {
                        const expanded = expandGroupedSpace(lineText, detectedSpace) || detectedSpace;
                        functionSpace = expanded;
                        spaceSourceKnown = true;
                    }
                }

                if (functionSpace && !spaceSourceKnown) {
                    const normalizedSpace = normalizeForMatch(functionSpace);
                    if (normalizedSpace && KNOWN_SPACE_LOOKUP.has(normalizedSpace)) {
                        functionSpace = KNOWN_SPACE_LOOKUP.get(normalizedSpace);
                        spaceSourceKnown = true;
                    } else if (functionSpace.includes("(") && !spaceSourceKnown) {
                        const base = functionSpace.split("(")[0].trim();
                        const baseNorm = normalizeForMatch(base);
                        if (baseNorm && KNOWN_SPACE_LOOKUP.has(baseNorm)) {
                            spaceSourceKnown = true;
                        }
                    }
                }

                functionType = functionType ? functionType.trim() : "";
                setupStyle = setupStyle ? setupStyle.trim() : "";
                functionSpace = functionSpace ? functionSpace.trim() : "";

                if (functionSpace && COUNTS_RE.test(functionSpace.replace(/\s+/g, ''))) {
                    functionSpace = null;
                }

                const eventKey = `${currentCompany || ""}||${currentEvent || ""}`;
                let spaceIsNew = false;
                if (functionSpace) {
                    const normalizedSpace = normalizeForMatch(functionSpace);
                    spaceIsNew = !(spaceSourceKnown || KNOWN_SPACE_LOOKUP.has(normalizedSpace));
                }
                if (!functionSpace && functionType && FALLBACK_TYPES.has(functionType)) {
                    const lastSpace = lastSpaceByEvent.get(eventKey);
                    if (lastSpace) {
                        functionSpace = lastSpace.space;
                        spaceIsNew = lastSpace.isNew;
                    }
                }

                if (!functionSpace) {
                    continue;
                }

                const typeIsNew = functionType ? !KNOWN_TYPE_LOOKUP.has(normalizeForMatch(functionType)) : false;
                const setupIsNew = setupStyle ? !KNOWN_SETUP_LOOKUP.has(normalizeForMatch(setupStyle)) : false;

                lastSpaceByEvent.set(eventKey, { space: functionSpace, isNew: spaceIsNew });

                rows.push({
                    "Company Name": currentCompany || "",
                    "Event Name": currentEvent || "",
                    "Event Status": currentStatus || "",
                    "Day of Event": currentDateStr || "",
                    "Start Time": startTime,
                    "End Time": endTime,
                    "Function Type": functionType || "",
                    "Function Space": functionSpace || "",
                    "Setup Style": setupStyle || "",
                    "Post As": "",
                    "Raw Line": lineText,
                    "__flags": {
                        spaceNew: !!spaceIsNew,
                        typeNew: !!typeIsNew,
                        setupNew: !!setupIsNew
                    }
                });
            }

            ingestRows(target, rows);
            return rows;
        }

        function ingestRows(target, rows) {
            const filtered = rows.filter(r => r && r["Day of Event"]);
            if (target === "A") {
                reportA = filtered;
                allEvents = filtered;
                buildSuggestions();
                redraw();
                renderForecast();
            } else {
                reportB = filtered;
            }
            if (reportA.length && reportB.length) {
                generateChangeLog(reportA, reportB);
            }
        }

        async function processPdfUpload(file, target) {
            if (!file) return;
            try {
                const rows = await loadPDF(file, target);
                if (!rows.length) {
                    alert(`No events were recognized in ${file.name}.`);
                }
                await saveParsedReport(file, rows, target);
            } catch (err) {
                console.error(err);
                alert(`Unable to parse ${file.name}: ${err?.message || err}`);
            }
        }

        /* ========= DATE / VIEW CONTROLS ========= */
        function syncDateLabel() {
            const label = document.getElementById("dateLabel");
            if (viewMode === "day") {
                label.textContent = currentDate.toLocaleDateString("en-US", {
                    weekday: "short",
                    month: "short",
                    day: "numeric",
                    year: "numeric"
                });
            } else {
                const ws = weekStart(currentDate),
                    we = weekEnd(currentDate);
                label.textContent = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
            }
        }

        function redraw() {
            if (!google?.charts) return;
            if (viewMode === "day") drawDaily(toLocalISODate(currentDate));
            else drawWeekly(toLocalISODate(currentDate));
        }

        function changeDay(offset) {
            const nd = new Date(currentDate);
            nd.setDate(currentDate.getDate() + offset);
            currentDate = nd;
            syncDateUI(currentDate);
            redraw();
        }

        /* ========= CALENDAR ========= */
        const calTable = document.getElementById("calTable");
        const calMonthLabel = document.getElementById("calMonthLabel");

        function renderCalendar(focusDate) {
            const year = focusDate.getFullYear(),
                month = focusDate.getMonth();
            calMonthLabel.textContent = monthLabel(focusDate);
            const first = new Date(year, month, 1);
            const startDay = first.getDay(); // Sun=0
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const prevMonthDays = new Date(year, month, 0).getDate();
            const cells = [];

            for (let i = 0; i < startDay; i++) {
                cells.push({
                    d: new Date(year, month - 1, prevMonthDays - startDay + 1 + i),
                    muted: true
                });
            }
            for (let d = 1; d <= daysInMonth; d++) {
                cells.push({
                    d: new Date(year, month, d),
                    muted: false
                });
            }
            while (cells.length < 42) {
                const nextDay = cells.length - (startDay + daysInMonth) + 1;
                cells.push({
                    d: new Date(year, month + 1, nextDay),
                    muted: true
                });
            }

            const ws = weekStart(currentDate),
                we = weekEnd(currentDate);

            let html = "<thead><tr>" + ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map(d => `<th>${d}</th>`).join("") + "</tr></thead><tbody>";
            for (let r = 0; r < 6; r++) {
                html += "<tr>";
                for (let c = 0; c < 7; c++) {
                    const idx = r * 7 + c,
                        cell = cells[idx];
                    const isActive = cell.d.toDateString() === currentDate.toDateString();
                    const isRealToday = (new Date()).toDateString() === cell.d.toDateString();
                    const inWeek = cell.d >= ws && cell.d <= we;
                    html += `<td class="${cell.muted?"muted":""} ${isActive?"active":""} ${isRealToday?"real-today":""} ${inWeek?"in-week":""}"
        data-y="${cell.d.getFullYear()}" data-m="${cell.d.getMonth()}" data-d="${cell.d.getDate()}">${cell.d.getDate()}</td>`;
                }
                html += "</tr>";
            }
            html += "</tbody>";
            calTable.innerHTML = html;
            calTable.parentElement.classList.add("week-highlight");

            calTable.querySelectorAll("td").forEach(td => {
                td.addEventListener("click", () => {
                    const y = +td.getAttribute("data-y"),
                        m = +td.getAttribute("data-m"),
                        d = +td.getAttribute("data-d");
                    currentDate = new Date(y, m, d);
                    syncDateUI(currentDate);
                    redraw();
                });
            });
        }

        function syncDateUI(d) {
            renderCalendar(d);
            syncDateLabel();
        }

        /* ========= SEARCH UI (autosuggest) ========= */
        function wireSearch() {
            const input = document.getElementById("timelineSearch");
            const box = document.getElementById("searchSuggest");
            const status = document.getElementById("searchStatus");
            const clearBtn = document.getElementById("clearSearch");

            function closeSuggest() {
                box.style.display = "none";
            }

            function openSuggest() {
                box.style.display = "block";
            }

            function renderSuggest() {
                const q = (input.value || "").trim().toLowerCase();
                if (!q) {
                    closeSuggest();
                    return;
                }
                const matches = suggestionsList.filter(s => s.toLowerCase().includes(q)).slice(0, 12);
                if (!matches.length) {
                    closeSuggest();
                    return;
                }
                box.innerHTML = matches.map(m => `<div data-v="${m}">${m}</div>`).join("");
                openSuggest();
                box.querySelectorAll("div").forEach(div => {
                    div.addEventListener("click", () => {
                        input.value = div.getAttribute("data-v");
                        searchTerm = input.value.trim();
                        status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                        closeSuggest();
                        redraw(); // timeline-only
                    });
                });
            }

            input.addEventListener("input", () => {
                searchTerm = input.value.trim();
                status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                renderSuggest();
                redraw();
            });
            input.addEventListener("focus", renderSuggest);
            document.addEventListener("click", (e) => {
                if (!box.contains(e.target) && e.target !== input) closeSuggest();
            });

            clearBtn.addEventListener("click", () => {
                input.value = "";
                searchTerm = "";
                status.textContent = "";
                closeSuggest();
                redraw();
            });
        }

        /* ========= EVENT HOOKS ========= */
        async function initUI() {
            document.getElementById("csvFileA").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "A");
            });
            document.getElementById("csvFileB").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "B");
            });

            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");

            if (selectA) {
                selectA.addEventListener("change", async () => {
                    const option = selectA.options[selectA.selectedIndex];
                    selectA.title = option ? option.textContent : "";
                    const id = selectA.value;
                    if (!id) return;
                    const loaded = await loadReportFromHistory(id, "A");
                    if (!loaded) {
                        alert("Unable to load the selected report from history.");
                        selectA.value = "";
                        selectA.selectedIndex = 0;
                        const resetOption = selectA.options[selectA.selectedIndex];
                        selectA.title = resetOption ? resetOption.textContent : "";
                    }
                });
            }

            if (selectB) {
                selectB.addEventListener("change", async () => {
                    const option = selectB.options[selectB.selectedIndex];
                    selectB.title = option ? option.textContent : "";
                    const id = selectB.value;
                    if (!id) return;
                    const loaded = await loadReportFromHistory(id, "B");
                    if (!loaded) {
                        alert("Unable to load the selected report from history.");
                        selectB.value = "";
                        selectB.selectedIndex = 0;
                        const resetOption = selectB.options[selectB.selectedIndex];
                        selectB.title = resetOption ? resetOption.textContent : "";
                    }
                });
            }

            await initializeReportHistory();

            // Segmented control
            document.querySelectorAll("#viewMode button").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll("#viewMode button").forEach(b => b.classList.remove("active"));
                    btn.classList.add("active");
                    viewMode = btn.dataset.mode;
                    syncDateUI(currentDate);
                    redraw();
                });
            });

            document.getElementById("prevDay").addEventListener("click", () => changeDay(viewMode === "day" ? -1 : -7));
            document.getElementById("nextDay").addEventListener("click", () => changeDay(viewMode === "day" ? +1 : +7));
            document.getElementById("jumpToday").addEventListener("click", () => {
                currentDate = new Date();
                syncDateUI(currentDate);
                redraw();
            });
            document.getElementById("toggleShowRooms").addEventListener("click", () => {
                showAllRooms = !showAllRooms;
                document.getElementById("toggleShowRooms").textContent = showAllRooms ? "Hide Unused Rooms" : "Show All Rooms";
                if (viewMode === "day") redraw(); // weekly ignores this
            });

            document.getElementById("calPrev").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() - 1);
                renderCalendar(d); // move focus month; selection unchanged
            });
            document.getElementById("calNext").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() + 1);
                renderCalendar(d);
            });

            // Tabs
            document.querySelectorAll(".tab-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
                    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
                    btn.classList.add("active");
                    document.getElementById(btn.dataset.tab).classList.add("active");
                    if (btn.dataset.tab === "timelineTab") redraw();
                    if (btn.dataset.tab === "changeTab" && reportA.length && reportB.length) generateChangeLog(reportA, reportB);
                    if (btn.dataset.tab === "forecastTab") renderForecast();
                });
            });

            // Search
            wireSearch();

            // initial
            syncDateUI(currentDate);
            google.charts.setOnLoadCallback(() => redraw());
        }
        window.addEventListener("resize", () => redraw());

        /* ========= BOOT ========= */
        initUI().catch(err => console.error("Failed to initialize UI", err));
    </script>






</body>

</html>