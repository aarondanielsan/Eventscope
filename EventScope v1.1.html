<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>EventScope</title>

    <!-- Google Charts -->
    <script src="https://www.gstatic.com/charts/loader.js"></script>

    <!-- PDF.js for in-browser PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
    <script>
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js";
        }
    </script>

    <!-- Dexie.js for IndexedDB management -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&amp;display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-navy: #0f1f3a;
            --panel: #1c2a55;
            --border: #394c7a;
            --text: #f5f5f5;
            --accent: #2196f3;
            --chart-bg: #ffffff;
            --prev: #dc2626;
            --new: #16a34a;
            --changed: #eab308;
            --tab: #0b1730;
            --tab-active: #173265;
            --muted: #cbd5e1;
            --today: #16a34a;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: var(--bg-navy);
            color: var(--text);
        }

        .container {
            margin: 0 auto;
            padding: 24px;
        }

        h1 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 0 0 12px 0;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 14px;
        }

        /* global controls (uploads) */
        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        label {
            font-size: .9rem;
            opacity: .9
        }

        input[type="file"] {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        input[type="file"]::-webkit-file-upload-button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: .8rem;
        }

        button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: .85rem;
            cursor: pointer;
            transition: .18s ease;
        }

        button:hover {
            filter: brightness(1.08)
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        .spacer {
            flex: 1
        }

        .group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap
        }

        .upload-stack {
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
        }

        .upload-stack label {
            margin-bottom: 2px;
        }

        .upload-stack input[type="file"],
        .upload-stack .report-select {
            width: min(280px, 100%);
        }

        .report-select {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        .report-select:focus {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }

        /* tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin: 12px 0;
        }

        .tab-btn {
            background: var(--tab);
            border: 1px solid var(--border);
            color: #cfe0ff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .tab-btn.active {
            background: var(--tab-active);
            color: #fff;
            border-color: #3e59a1;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* toolbar (calendar + bottom-anchored controls) */
        .toolbar {
            display: flex;
            gap: 20px;
            align-items: stretch;
            background: #182750;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
        }

        .calendar-shell {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px;
            width: 220px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .cal-nav button {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            cursor: pointer;
            font-weight: 700;
        }

        table.cal {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
            font-size: .8rem
        }

        .cal th {
            color: var(--muted);
            font-weight: 600;
            padding: 4px 0
        }

        .cal td {
            padding: 4px;
            border-radius: 6px;
            cursor: pointer
        }

        .cal td:hover {
            background: #2b3f75
        }

        .cal td.active {
            background: #2b3f75;
            outline: 1px solid #4b6bb5
        }

        .cal td.real-today {
            outline: 2px dashed var(--today)
        }

        .cal td.muted {
            color: #7f8ab1
        }

        .week-highlight td.in-week {
            background: #2a3f7c;
        }

        .week-highlight td.in-week.active {
            outline: 2px solid #4b6bb5
        }

        .right-tools {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .controls-bottom {
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-badge {
            display: grid;
            grid-template-columns: 34px minmax(220px, 1fr) 34px;
            align-items: center;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 6px 8px;
            min-width: 320px;
        }

        .nav-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            color: #fff;
            background: var(--accent);
        }

        .date-label {
            text-align: center;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 8px;
        }

        .segmented {
            display: inline-flex;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 3px;
        }

        .segmented button {
            background: transparent;
            border: none;
            color: #cfe0ff;
            padding: 6px 10px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
        }

        .segmented button.active {
            background: var(--accent);
            color: #fff;
        }

        .btn {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .85rem;
        }

        .btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        /* search card (timeline-only filter) */
        .search-card {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            position: relative;
        }

        .search-box input {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            font: inherit;
            min-width: 280px;
        }

        .toolbar-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            width: 100%;
        }

        .toolbar-actions .search-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            flex: 1;
            min-width: 260px;
        }

        .toolbar-actions .search-box {
            flex: 1;
        }

        .toolbar-actions .search-box input {
            width: 100%;
        }

        .toolbar-action {
            background: #394c7a;
            color: #fff;
            border: 1px solid #394c7a;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font: inherit;
            font-size: .85rem;
            transition: .18s ease;
        }

        .toolbar-action:hover {
            filter: brightness(1.08);
        }

        .toolbar-action.secondary {
            background: transparent;
        }

        .toolbar-action.active {
            background: #3cc47c;
            border-color: #3cc47c;
            color: #0f1f3a;
        }

        .toolbar-status {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: .85rem;
        }

        #searchStatus {
            display: block;
        }

        #lighthouseStatus {
            opacity: .85;
        }

        #lighthouseStatus.info {
            color: #60a5fa;
        }

        #lighthouseStatus.success {
            color: #34d399;
        }

        #lighthouseStatus.error {
            color: #f87171;
        }

        .suggestions {
            position: absolute;
            top: 110%;
            left: 0;
            right: 0;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 180px;
            overflow-y: auto;
            display: none;
            z-index: 20;
        }

        .suggestions div {
            padding: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .suggestions div:hover {
            background: #2b3f75;
        }

        .pill {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 4px 8px;
            font-size: .8rem;
            color: #cfe0ff;
        }

        /* timeline wrapper */
        #timeline-wrapper {
            background: var(--chart-bg);
            border-radius: 10px;
            padding: 10px;
            margin-top: 8px;
        }

        #timeline {
            width: 100%;
            height: 70vh;
            min-height: 400px;
        }

        #timeline text {
            font-weight: 400 !important;
        }

        .google-visualization-tooltip,
        .google-visualization-tooltip * {
            color: #000 !important;
            background: #fff !important;
            font-family: 'Poppins', sans-serif !important;
            font-size: 12px !important;
        }

        .google-visualization-tooltip {
            border: 1px solid #cfcfcf !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, .15) !important;
            border-radius: 6px !important;
        }

        /* Change Log (kept as your working version, pill colors preserved) */
        #changeLogNote {
            background: #eef6ff;
            color: #1e3a8a;
            padding: 6px 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-size: .9rem;
            font-weight: 500;
        }

        .company-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 14px 0 6px;
        }

        .event-header {
            font-size: 1rem;
            font-weight: 500;
            margin: 8px 0 4px 8px;
            color: #cbd5e1;
        }

        .change-card {
            background: #fff;
            color: #000;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 6px 0 6px 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .change-card h4 {
            margin: 0 0 6px;
            font-size: .95rem;
            color: #111;
        }

        .change-card ul {
            margin: 0;
            padding-left: 16px;
        }

        .change-card li {
            margin: 2px 0;
            font-size: .85rem;
        }

        .change-prev {
            color: var(--prev);
            font-weight: 600;
        }

        .change-new {
            color: var(--new);
            font-weight: 700;
        }

        /* Forecast styles (unchanged) */
        .forecast-card {
            background: #1c2a55;
            padding: 16px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #394c7a;
        }

        .forecast-card h3 {
            margin-top: 0;
            font-size: 1.2rem;
        }

        .company-group {
            margin-bottom: 14px;
            padding: 12px;
            border-radius: 8px;
            background: #223366;
        }

        .company-name {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .event-block {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 6px;
            background: #2a3c6e;
        }

        #avPanel {
            margin-top: 16px;
            background: #1c2a55;
            border-top: 3px solid #394c7a;
            border-radius: 0 0 10px 10px;
            padding: 16px;
            display: none;
        }

        #avPanelHeader {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        #avPanelContent {
            display: grid;
            gap: 12px;
        }

        .av-section h4 {
            margin: 0 0 6px 0;
            font-size: 1rem;
        }

        .av-list {
            margin: 0;
            padding-left: 18px;
        }

        .av-table {
            width: 100%;
            border-collapse: collapse;
            font-size: .85rem;
        }

        .av-table th,
        .av-table td {
            text-align: left;
            padding: 6px 8px;
        }

        .av-table tbody tr:nth-child(even) {
            background: rgba(57, 76, 122, 0.3);
        }

        .av-job {
            padding: 12px;
            border: 1px solid #394c7a;
            border-radius: 10px;
            background: rgba(57, 76, 122, 0.25);
        }

        .av-job + .av-job {
            margin-top: 10px;
        }

        .av-job-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .av-meta {
            font-size: .85rem;
            opacity: .85;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .av-sub strong {
            display: block;
            font-size: .9rem;
            margin-bottom: 4px;
        }

        .event-title {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .space-pill {
            background: #394c7a;
            padding: 3px 8px;
            border-radius: 14px;
            font-size: .8rem;
            margin-right: 6px;
        }

        .happening .section {
            margin-top: 12px;
        }

        .happening strong {
            font-size: 1.05rem;
        }

        .happening .now strong {
            color: #22c55e;
        }

        .happening .next strong {
            color: #3b82f6;
        }

        .happening-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #394c7a;
        }

        .happening-row:last-child {
            border-bottom: none;
        }

        .happening-row span {
            font-size: .9rem;
        }

        .warning-box {
            margin-bottom: 12px;
            padding: 10px;
            border: 1px solid #facc15;
            border-radius: 6px;
            background: #2a2a1c;
            color: #facc15;
        }
    </style>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
</head>

<body>
    <div class="container">
        <h1>EventScope</h1>

        <!-- GLOBAL uploads -->
        <div class="card" id="globalUploads">
            <div class="controls">
                <div class="group upload-stack">
                    <label for="csvFileA">Newest Event Report PDF</label>
                    <input type="file" id="csvFileA" accept=".pdf">
                    <select id="reportHistoryA" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
                <div class="spacer"></div>
                <div class="group upload-stack">
                    <label for="csvFileB">Previous Event Report PDF</label>
                    <input type="file" id="csvFileB" accept=".pdf">
                    <select id="reportHistoryB" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="timelineTab">Timeline</button>
            <button class="tab-btn" data-tab="changeTab">Change Log</button>
            <button class="tab-btn" data-tab="forecastTab">Today’s Forecast</button>
        </div>

        <!-- TIMELINE TAB -->
        <div id="timelineTab" class="tab-content active">
            <div class="card">

                <!-- Toolbar (calendar + bottom-anchored controls) -->
                <div class="toolbar">
                    <!-- Calendar -->
                    <div class="calendar-shell week-highlight">
                        <div class="calendar-header">
                            <div id="calMonthLabel">September 2025</div>
                            <div class="cal-nav">
                                <button id="calPrev" aria-label="Prev Month">‹</button>
                                <button id="calNext" aria-label="Next Month">›</button>
                            </div>
                        </div>
                        <table class="cal" id="calTable">
                            <thead>
                                <tr>
                                    <th>Su</th>
                                    <th>Mo</th>
                                    <th>Tu</th>
                                    <th>We</th>
                                    <th>Th</th>
                                    <th>Fr</th>
                                    <th>Sa</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="7" data-d="31">31</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="1">1</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="2">2</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="3">3</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="4">4</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="5">5</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="6">6</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="7">7</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="8">8</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="9">9</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="10">10</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="11">11</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="12">12</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="13">13</td>
                                </tr>
                                <tr>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="14">14</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="15">15</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="16">16</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="17">17</td>
                                    <td class=" active real-today in-week" data-y="2025" data-m="8" data-d="18">18</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="19">19</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="20">20</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="21">21</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="22">22</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="23">23</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="24">24</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="25">25</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="26">26</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="27">27</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="28">28</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="29">29</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="30">30</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="1">1</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="2">2</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="3">3</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="4">4</td>
                                </tr>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="5">5</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="6">6</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="7">7</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="8">8</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="9">9</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="10">10</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="11">11</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Bottom-anchored tools -->

                </div>

                <!--Main Tools (Date, Toggle, Search, Show -->
                <div class="card" id="searchCard" style="margin-top:12px;">
                    <div class="search-card">

                        <div class="date-badge">
                            <button class="nav-btn" id="prevDay">‹</button>
                            <div class="date-label" id="dateLabel">Thu, Sep 18, 2025</div>
                            <button class="nav-btn" id="nextDay">›</button>
                        </div>
                        <button class="btn" id="jumpToday">Today</button>
                        <div class="segmented" id="viewMode">
                            <button data-mode="day" class="active">Daily</button>
                            <button data-mode="week" class="">Weekly</button>
                        </div>
                        <div class="toolbar-actions">
                            <div class="search-group">
                                <div class="search-box">
                                    <input type="text" id="timelineSearch" placeholder="Search company or event…">
                                    <div class="suggestions" id="searchSuggest" style="display: none;"></div>
                                </div>
                                <button class="toolbar-action secondary" id="clearSearch">Clear</button>
                            </div>
                            <button class="toolbar-action secondary" id="toggleShowRooms">Show All Rooms</button>
                            <button class="toolbar-action" id="toggleHighlightAV">Highlight AV</button>
                            <button class="toolbar-action" id="lighthouseSync">Lighthouse Sync</button>
                        </div>
                        <div class="toolbar-status">
                            <span id="searchStatus" style="opacity:.7;font-size:.9rem;"></span>
                            <span id="lighthouseStatus" class="info"></span>
                        </div>
                    </div>
                </div>

                <!-- Chart -->
                <div id="timeline-wrapper">
                    <div id="timeline">
                        <p style="color:#c00; margin:12px;">No events found for this date.</p>
                    </div>
                </div>
                <div id="avPanel">
                    <div id="avPanelHeader"></div>
                    <div id="avPanelContent"></div>
                </div>
            </div>
        </div>

        <!-- CHANGE LOG TAB (unchanged logic & styles you approved) -->
        <div id="changeTab" class="tab-content">
            <div class="card">
                <h2>Change Log</h2>
                <div id="changeLogNote">Comparing overlapping dates: Previous Report ⇄ Newest Report</div>
                <div id="changeLog">
                    <p style="opacity:.8">Upload both reports to see changes.</p>
                </div>
            </div>
        </div>

        <!-- TODAY'S FORECAST TAB (unchanged) -->
        <div id="forecastTab" class="tab-content">
            <div class="card">
                <h2>Today’s Event Forecast</h2>
                <div id="forecast">
                    <p style="opacity:.8">Upload the newest report to view today’s schedule summary.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ========= LOAD CHARTS ========= */
        google.charts.load("current", {
            packages: ["timeline"]
        });

        /* ========= GLOBAL STATE ========= */
        let reportA = [],
            reportB = []; // A = newest, B = previous
        let allEvents = []; // base events (from newest report)
        let currentDate = new Date();
        let showAllRooms = false;
        let viewMode = "day"; // 'day' | 'week'
        let searchTerm = ""; // timeline-only filter
        let suggestionsList = []; // autosuggest values
        let highlightAV = false;
        let currentTimelineChart = null;
        let currentTimelineData = null;
        let currentTimelineMetadata = [];
        let currentTimelineMode = "day";
        let lastSelectionMeta = null;
        let lighthouseStatusTimer = null;

        const AV_STYLE = "fill-color: #3cc47c; stroke-color: #ffffff; stroke-width: 2;";
        const LIGHTHOUSE_LOGIN_URL = "https://lighthouse2.psav.com";
        const LIGHTHOUSE_PROXY_ENDPOINT = "/lighthouse/getactions";
        const LIGHTHOUSE_ROOM_GUIDE_URL = "lighthouse-room-guide.json";

        const lighthouseState = {
            enabled: false,
            fetching: false,
            rawByDate: new Map(),
            byDate: new Map(),
            jobsById: new Map(),
            roomGuide: new Map(),
            lastSync: null,
            autoFetch: false
        };

        /* ========= REPORT HISTORY (IndexedDB) ========= */
        const REPORT_HISTORY_LIMIT = 10;
        const reportDB = window.Dexie ? new Dexie("eventscopeReports") : null;
        const lighthouseCacheDB = window.Dexie ? new Dexie("eventscopeLighthouse") : null;
        if (reportDB) {
            reportDB.version(1).stores({
                reports: "++id, uploadedAt"
            });
            reportDB.version(2).stores({
                reports: "++id, date, savedAt"
            }).upgrade(async tx => {
                await tx.table("reports").toCollection().modify(entry => {
                    const fallbackRaw = entry.fileTimestamp ?? entry.uploadedAt ?? Date.now();
                    const fallbackNumber = Number(fallbackRaw);
                    const fallbackDate = Number.isFinite(fallbackNumber) ? new Date(fallbackNumber) : new Date();
                    const savedValue = entry.uploadedDate ?? (entry.uploadedAt ? new Date(Number(entry.uploadedAt)).toISOString() : new Date().toISOString());
                    entry.fileName = entry.fileName || entry.filename || "Report";
                    entry.date = entry.date || fallbackDate.toISOString();
                    entry.savedAt = entry.savedAt || savedValue;
                    if (entry.events === undefined && entry.rows !== undefined) {
                        entry.events = entry.rows;
                    }
                    delete entry.filename;
                    delete entry.uploadedAt;
                    delete entry.uploadedDate;
                    delete entry.fileTimestamp;
                    delete entry.rows;
                });
            });
        }

        if (lighthouseCacheDB) {
            lighthouseCacheDB.version(1).stores({
                actions: "iso, savedAt"
            });
        }

        function entryDateValue(entry) {
            if (!entry) return 0;
            const candidate = entry.date ?? entry.savedAt;
            if (candidate !== undefined && candidate !== null) {
                const parsed = typeof candidate === "number" ? candidate : Date.parse(candidate);
                if (!Number.isNaN(parsed)) return parsed;
            }
            const fallback = entry.fileTimestamp ?? entry.uploadedAt ?? entry.lastModified;
            if (fallback !== undefined && fallback !== null) {
                const numeric = typeof fallback === "number" ? fallback : Number(fallback);
                if (Number.isFinite(numeric)) return numeric;
            }
            return 0;
        }

        function formatReportOption(entry) {
            const dateValue = entryDateValue(entry);
            const dt = dateValue ? new Date(dateValue) : null;
            const dateStr = dt ? dt.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "Unknown date";
            const name = entry.fileName || entry.filename || "Report";
            return `${dateStr} – ${name}`;
        }

        async function getStoredReports() {
            if (!reportDB) return [];
            try {
                const all = await reportDB.reports.toArray();
                const usable = all.filter(entry => entry && entry.events !== undefined);
                usable.sort((a, b) => {
                    const diff = entryDateValue(b) - entryDateValue(a);
                    if (diff !== 0) return diff;
                    return (b.id || 0) - (a.id || 0);
                });
                return usable.slice(0, REPORT_HISTORY_LIMIT);
            } catch (err) {
                console.error("Unable to read stored reports", err);
                return [];
            }
        }

        async function pruneExcessReports() {
            if (!reportDB) return;
            try {
                const all = await reportDB.reports.toArray();
                if (all.length <= REPORT_HISTORY_LIMIT) return;
                all.sort((a, b) => {
                    const diff = entryDateValue(b) - entryDateValue(a);
                    if (diff !== 0) return diff;
                    return (b.id || 0) - (a.id || 0);
                });
                const keep = new Set(all.slice(0, REPORT_HISTORY_LIMIT).map(entry => entry.id));
                const toDelete = all.filter(entry => !keep.has(entry.id)).map(entry => entry.id);
                if (toDelete.length) {
                    await reportDB.reports.bulkDelete(toDelete);
                }
            } catch (err) {
                console.error("Unable to prune stored reports", err);
            }
        }

        async function populateReportDropdowns({ selectAId, selectBId } = {}) {
            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            if (!selectA || !selectB) return [];
            const data = await getStoredReports();
            [
                { element: selectA, override: selectAId },
                { element: selectB, override: selectBId }
            ].forEach(({ element, override }) => {
                const previous = element.value;
                const desired = override !== undefined ? (override == null ? "" : String(override)) : previous;
                element.innerHTML = "<option value=\"\">Select a saved report…</option>";
                data.forEach(item => {
                    const opt = document.createElement("option");
                    opt.value = String(item.id);
                    opt.textContent = formatReportOption(item);
                    opt.dataset.fileName = item.fileName || "";
                    opt.dataset.date = item.date || "";
                    opt.dataset.savedAt = item.savedAt || "";
                    element.appendChild(opt);
                });
                if (desired) {
                    element.value = desired;
                    if (element.value !== desired) {
                        element.selectedIndex = 0;
                    }
                } else {
                    element.selectedIndex = 0;
                }
                const selectedOption = element.options[element.selectedIndex];
                element.title = selectedOption ? selectedOption.textContent : "";
            });
            return data;
        }

        async function saveParsedReport(file, rows, target) {
            if (!reportDB || !file) return null;
            try {
                const now = new Date();
                const hasLastModified = typeof file.lastModified === "number" && !Number.isNaN(file.lastModified);
                const fileDate = hasLastModified ? new Date(file.lastModified) : now;
                const fileDateIso = fileDate.toISOString();
                const events = Array.isArray(rows) ? rows.filter(r => r && r["Day of Event"]) : [];
                const clonedEvents = JSON.parse(JSON.stringify(events));
                const existing = await reportDB.reports
                    .where("date")
                    .equals(fileDateIso)
                    .filter(entry => (entry?.fileName || "") === file.name)
                    .first();
                const selectionTarget = target === "A" ? "selectAId" : "selectBId";
                if (existing?.id) {
                    await reportDB.reports.update(existing.id, {
                        events: clonedEvents,
                        savedAt: now.toISOString()
                    });
                    await pruneExcessReports();
                    await populateReportDropdowns({ [selectionTarget]: existing.id });
                    return existing.id;
                }
                const payload = {
                    fileName: file.name,
                    date: fileDateIso,
                    savedAt: now.toISOString(),
                    events: clonedEvents
                };
                const id = await reportDB.reports.add(payload);
                await pruneExcessReports();
                await populateReportDropdowns({ [selectionTarget]: id });
                return id;
            } catch (err) {
                console.error("Unable to save parsed report", err);
                return null;
            }
        }

        async function loadReportFromHistory(entryOrId, target) {
            if (!reportDB) return false;
            try {
                let entry = entryOrId;
                if (!entry || typeof entry !== "object") {
                    const idNum = Number(entryOrId);
                    if (!idNum) return false;
                    entry = await reportDB.reports.get(idNum);
                }
                if (!entry || entry.events === undefined) {
                    console.warn("Stored report is missing event data.");
                    return false;
                }
                const events = Array.isArray(entry.events) ? entry.events : [];
                const cloned = JSON.parse(JSON.stringify(events));
                ingestRows(target, cloned);
                return true;
            } catch (err) {
                console.error("Unable to load stored report", err);
                return false;
            }
        }

        async function initializeReportHistory() {
            await pruneExcessReports();
            const inputA = document.getElementById("csvFileA");
            const inputB = document.getElementById("csvFileB");
            if (inputA) inputA.value = "";
            if (inputB) inputB.value = "";
            const reports = await populateReportDropdowns({ selectBId: null });
            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            if (selectB) {
                selectB.value = "";
                selectB.selectedIndex = 0;
                const optionB = selectB.options[selectB.selectedIndex];
                selectB.title = optionB ? optionB.textContent : "";
            }
            if (!selectA || !reports.length) {
                if (selectA) {
                    selectA.selectedIndex = 0;
                    const optionA = selectA.options[selectA.selectedIndex];
                    selectA.title = optionA ? optionA.textContent : "";
                }
                return;
            }
            const latest = reports[0];
            const desired = String(latest.id);
            selectA.value = desired;
            if (selectA.value !== desired) {
                selectA.selectedIndex = 0;
            }
            const option = selectA.options[selectA.selectedIndex];
            selectA.title = option ? option.textContent : "";
            const loaded = await loadReportFromHistory(latest, "A");
            if (!loaded) {
                selectA.value = "";
                selectA.selectedIndex = 0;
                const fallbackOption = selectA.options[selectA.selectedIndex];
                selectA.title = fallbackOption ? fallbackOption.textContent : "";
            }
        }

        /* ========= LIGHTHOUSE INTEGRATION ========= */
        function updateLighthouseStatus(message = "", variant = "info", persist = false) {
            const statusEl = document.getElementById("lighthouseStatus");
            if (!statusEl) return;
            statusEl.textContent = message || "";
            statusEl.classList.remove("info", "success", "error");
            if (message) statusEl.classList.add(variant || "info");
            if (lighthouseStatusTimer) {
                clearTimeout(lighthouseStatusTimer);
                lighthouseStatusTimer = null;
            }
            if (message && !persist) {
                lighthouseStatusTimer = setTimeout(() => {
                    if (statusEl.textContent === message) {
                        statusEl.textContent = "";
                        statusEl.classList.remove("info", "success", "error");
                    }
                }, 6000);
            }
        }

        function cloneForStorage(value) {
            if (typeof structuredClone === "function") {
                try {
                    return structuredClone(value);
                } catch (err) {
                    // structuredClone unavailable for the payload; fall through to JSON method
                }
            }
            try {
                return JSON.parse(JSON.stringify(value));
            } catch (err) {
                return value;
            }
        }

        async function persistLighthouseCacheEntries(entries) {
            if (!lighthouseCacheDB || !Array.isArray(entries) || !entries.length) return;
            const timestamp = new Date().toISOString();
            try {
                await lighthouseCacheDB.table("actions").bulkPut(entries.map(entry => ({
                    iso: entry.iso,
                    savedAt: entry.savedAt || timestamp,
                    payload: cloneForStorage(entry.payload)
                })));
            } catch (err) {
                console.warn("Failed to persist Lighthouse cache", err);
            }
        }

        async function loadLighthouseCache() {
            if (!lighthouseCacheDB) return;
            try {
                const cached = await lighthouseCacheDB.table("actions").toArray();
                if (!cached.length) return;
                cached.forEach(entry => {
                    if (!entry || !entry.iso) return;
                    let payload = [];
                    if (Array.isArray(entry.payload)) {
                        payload = entry.payload;
                    } else if (typeof entry.payload === "string") {
                        try {
                            const parsed = JSON.parse(entry.payload);
                            if (Array.isArray(parsed)) payload = parsed;
                            else return;
                        } catch (err) {
                            return;
                        }
                    } else if (entry.payload && typeof entry.payload === "object") {
                        payload = Array.isArray(entry.payload.value) ? entry.payload.value : Array.isArray(entry.payload.data) ? entry.payload.data : [];
                    }
                    if (!Array.isArray(payload)) return;
                    lighthouseState.rawByDate.set(entry.iso, payload);
                    if (entry.savedAt) {
                        const saved = Date.parse(entry.savedAt);
                        if (!Number.isNaN(saved)) {
                            if (!lighthouseState.lastSync || saved > lighthouseState.lastSync.getTime()) {
                                lighthouseState.lastSync = new Date(saved);
                            }
                        }
                    }
                });
                if (lighthouseState.rawByDate.size) {
                    recomputeLighthouseState();
                    lighthouseState.enabled = true;
                    lighthouseState.autoFetch = false;
                }
            } catch (err) {
                console.warn("Failed to load Lighthouse cache", err);
            }
        }

        async function loadLighthouseRoomGuide() {
            try {
                if (window.LIGHTHOUSE_ROOM_GUIDE && typeof window.LIGHTHOUSE_ROOM_GUIDE === "object") {
                    Object.entries(window.LIGHTHOUSE_ROOM_GUIDE).forEach(([guid, name]) => {
                        if (guid) lighthouseState.roomGuide.set(String(guid).toLowerCase(), name);
                    });
                    return;
                }
                const res = await fetch(LIGHTHOUSE_ROOM_GUIDE_URL, { credentials: "include" }).catch(() => null);
                if (!res || !res.ok) return;
                const data = await res.json();
                if (data && typeof data === "object") {
                    Object.entries(data).forEach(([guid, name]) => {
                        if (guid) lighthouseState.roomGuide.set(String(guid).toLowerCase(), name);
                    });
                }
            } catch (err) {
                console.warn("Unable to load Lighthouse room guide", err);
            }
        }

        function normalizeSimple(value) {
            return (value || "").toString().trim().toLowerCase().replace(/\s+/g, " ");
        }

        function deepGet(source, path) {
            return path.split(".").reduce((acc, part) => (acc && acc[part] !== undefined ? acc[part] : null), source);
        }

        function pickField(source, paths) {
            for (const path of paths) {
                const value = deepGet(source, path);
                if (value !== undefined && value !== null && value !== "") {
                    return value;
                }
            }
            return null;
        }

        function parseLighthouseDate(value) {
            if (!value && value !== 0) return null;
            if (value instanceof Date) return value;
            if (typeof value === "number") {
                const date = new Date(value);
                return isNaN(date) ? null : date;
            }
            const str = String(value).trim();
            const msMatch = str.match(/\/Date\((\d+)\)\//);
            if (msMatch) {
                const date = new Date(Number(msMatch[1]));
                return isNaN(date) ? null : date;
            }
            const parsed = Date.parse(str);
            if (!Number.isNaN(parsed)) return new Date(parsed);
            return null;
        }

        function parseQuantity(value) {
            if (value === undefined || value === null || value === "") return 0;
            if (typeof value === "number") return value;
            const numeric = Number(String(value).replace(/[^0-9.-]/g, ""));
            return Number.isFinite(numeric) ? numeric : 0;
        }

        function getRoomNameFromGuide(guid, fallback) {
            if (!guid) return fallback || "";
            const key = String(guid).toLowerCase();
            if (lighthouseState.roomGuide.has(key)) {
                return lighthouseState.roomGuide.get(key);
            }
            return fallback || "";
        }

        function normalizeLighthouseRoom(roomGuid, rawName) {
            const guided = getRoomNameFromGuide(roomGuid, rawName);
            const name = guided || rawName || "";
            const rooms = normalizeRooms(name);
            const matches = new Set();
            rooms.forEach(room => {
                matches.add(room);
                const base = PARENT_MAP[room];
                if (base) matches.add(base);
            });
            return {
                displayName: name || (rooms[0] || ""),
                matches
            };
        }

        function ensureJobMaps(job) {
            if (!job._contactKeys) job._contactKeys = new Set();
            if (!job._equipmentMap) job._equipmentMap = new Map();
            if (!job._laborKeys) job._laborKeys = new Set();
            if (!job._fallbackDates) job._fallbackDates = new Set();
        }

        function ingestLighthouseAction(action, iso) {
            if (!action || typeof action !== "object") return;
            const jobNumber = pickField(action, ["jobNumber", "jobNo", "job.jobNumber", "job.number", "orderNumber", "order.orderNumber"]);
            const orderName = pickField(action, ["orderName", "order.name", "jobName", "eventName"]);
            const clientName = pickField(action, ["clientName", "customerName", "accountName", "order.accountName"]);
            const roomGuid = pickField(action, ["roomGuid", "roomGUID", "room.guid", "room.roomGuid", "roomId"]);
            const roomName = pickField(action, ["roomName", "room.name", "roomDescription", "room.roomName"]);
            const startRaw = pickField(action, ["orderStartDateTime", "order.startDateTime", "startDateTime", "start"]);
            const endRaw = pickField(action, ["orderEndDateTime", "order.endDateTime", "endDateTime", "end"]);
            const start = parseLighthouseDate(startRaw);
            const end = parseLighthouseDate(endRaw);

            const jobIdBase = jobNumber || pickField(action, ["orderId", "order.id", "jobId", "job.id", "id"]);
            const jobId = roomGuid ? `${jobIdBase || orderName || clientName || ""}::${roomGuid}` : (jobIdBase || orderName || clientName || "");
            if (!jobId) return;

            let job = lighthouseState.jobsById.get(jobId);
            if (!job) {
                const roomInfo = normalizeLighthouseRoom(roomGuid, roomName);
                job = {
                    id: jobId,
                    jobNumber: jobNumber || "",
                    orderName: orderName || "",
                    normalizedOrderName: normalizeSimple(orderName || ""),
                    clientName: clientName || "",
                    normalizedClient: normalizeSimple(clientName || ""),
                    roomGuid: roomGuid || "",
                    roomName: roomInfo.displayName || roomName || "",
                    matchRooms: roomInfo.matches,
                    start: start || null,
                    end: end || null,
                    contacts: [],
                    equipment: [],
                    labor: [],
                    hasEquipment: false
                };
                lighthouseState.jobsById.set(jobId, job);
            } else {
                if (start && (!job.start || start < job.start)) job.start = start;
                if (end && (!job.end || end > job.end)) job.end = end;
            }

            ensureJobMaps(job);
            if (iso) job._fallbackDates.add(iso);
            mergeContacts(job, action);
            mergeEquipment(job, action);
            mergeLabor(job, action);
        }

        function mergeContacts(job, action) {
            const pools = [];
            if (Array.isArray(action.contacts)) pools.push(action.contacts);
            if (Array.isArray(action.orderContacts)) pools.push(action.orderContacts);
            if (Array.isArray(action.contactDetails)) pools.push(action.contactDetails);
            pools.forEach(list => {
                list.forEach(contact => {
                    if (!contact) return;
                    const name = pickField(contact, ["fullName", "name", "displayName", "contactName"]);
                    const role = pickField(contact, ["role", "title", "contactRole"]);
                    if (!name) return;
                    const key = `${normalizeSimple(name)}::${normalizeSimple(role || "")}`;
                    if (job._contactKeys.has(key)) return;
                    job.contacts.push({
                        name,
                        role: role || ""
                    });
                    job._contactKeys.add(key);
                });
            });
            job.contacts.sort((a, b) => a.name.localeCompare(b.name));
        }

        function mergeEquipment(job, action) {
            const sections = [];
            if (Array.isArray(action.equipmentSections)) sections.push(...action.equipmentSections);
            if (action.equipment && Array.isArray(action.equipment.sections)) sections.push(...action.equipment.sections);
            if (Array.isArray(action.equipment)) sections.push(...action.equipment);
            sections.forEach(section => {
                if (!section) return;
                const category = (pickField(section, ["categoryName", "sectionName", "name", "category"]) || "").toLowerCase();
                if (category.includes("internet")) return;
                const items = [];
                if (Array.isArray(section.items)) items.push(...section.items);
                if (Array.isArray(section.equipmentDetails)) items.push(...section.equipmentDetails);
                if (Array.isArray(section.equipmentItems)) items.push(...section.equipmentItems);
                if (!items.length && section.item) items.push(section.item);
                items.forEach(item => {
                    if (!item) return;
                    const desc = pickField(item, ["itemDescription", "description", "name", "productName", "displayName"]);
                    if (!desc) return;
                    const qty = parseQuantity(pickField(item, ["quantity", "qty", "amount", "totalQty", "count", "hours"]));
                    const key = normalizeSimple(desc);
                    const existing = job._equipmentMap.get(key) || {
                        name: desc,
                        normalizedName: key,
                        quantity: 0,
                        category: category || ""
                    };
                    existing.quantity += qty;
                    if (!existing.category && category) existing.category = category;
                    job._equipmentMap.set(key, existing);
                });
            });
            job.equipment = Array.from(job._equipmentMap.values()).filter(item => item.quantity > 0).sort((a, b) => {
                if (b.quantity !== a.quantity) return b.quantity - a.quantity;
                return a.name.localeCompare(b.name);
            });
            job.hasEquipment = job.equipment.length > 0;
        }

        function mergeLabor(job, action) {
            const sections = [];
            if (Array.isArray(action.laborSections)) sections.push(...action.laborSections);
            if (Array.isArray(action.labor)) sections.push(...action.labor);
            if (action.laborDetails && Array.isArray(action.laborDetails)) sections.push(...action.laborDetails);
            sections.forEach(section => {
                if (!section) return;
                const entries = [];
                if (Array.isArray(section.laborDetails)) entries.push(...section.laborDetails);
                if (Array.isArray(section.items)) entries.push(...section.items);
                if (Array.isArray(section.assignments)) entries.push(...section.assignments);
                if (!entries.length && typeof section === "object" && !Array.isArray(section)) entries.push(section);
                entries.forEach(entry => {
                    if (!entry) return;
                    const role = pickField(entry, ["roleName", "role", "position", "description"]) || pickField(section, ["sectionName", "name"]) || "";
                    const start = parseLighthouseDate(pickField(entry, ["startDateTime", "start", "onSiteTime"]));
                    const end = parseLighthouseDate(pickField(entry, ["endDateTime", "end", "offSiteTime"]));
                    const key = `${normalizeSimple(role)}::${start ? start.getTime() : 0}::${end ? end.getTime() : 0}`;
                    if (job._laborKeys.has(key)) return;
                    job.labor.push({
                        role: role || "",
                        start: start || null,
                        end: end || null
                    });
                    job._laborKeys.add(key);
                });
            });
            job.labor.sort((a, b) => {
                const aStart = a.start ? a.start.getTime() : 0;
                const bStart = b.start ? b.start.getTime() : 0;
                return aStart - bStart;
            });
        }

        function computeActiveDates(job) {
            const dates = new Set();
            if (job.start && job.end) {
                const cursor = new Date(job.start.getFullYear(), job.start.getMonth(), job.start.getDate(), 0, 0, 0, 0);
                const end = new Date(job.end.getFullYear(), job.end.getMonth(), job.end.getDate(), 0, 0, 0, 0);
                while (cursor <= end) {
                    dates.add(toLocalISODate(cursor));
                    cursor.setDate(cursor.getDate() + 1);
                }
            }
            if (job._fallbackDates) {
                job._fallbackDates.forEach(d => dates.add(d));
            }
            return Array.from(dates).sort();
        }

        function normalizeLighthouseActions(payload) {
            if (!payload) return [];
            if (Array.isArray(payload)) return payload;
            if (Array.isArray(payload.actions)) return payload.actions;
            if (Array.isArray(payload.data)) return payload.data;
            if (payload.result) {
                if (Array.isArray(payload.result)) return payload.result;
                if (Array.isArray(payload.result.actions)) return payload.result.actions;
            }
            if (Array.isArray(payload.value)) return payload.value;
            if (payload.items && Array.isArray(payload.items)) return payload.items;
            return [];
        }

        function recomputeLighthouseState() {
            lighthouseState.jobsById.clear();
            lighthouseState.byDate.clear();

            for (const [iso, actions] of lighthouseState.rawByDate.entries()) {
                actions.forEach(action => ingestLighthouseAction(action, iso));
            }

            for (const job of lighthouseState.jobsById.values()) {
                const dates = computeActiveDates(job);
                dates.forEach(iso => {
                    if (!lighthouseState.byDate.has(iso)) lighthouseState.byDate.set(iso, []);
                    lighthouseState.byDate.get(iso).push(job);
                });
            }

            for (const jobs of lighthouseState.byDate.values()) {
                jobs.sort((a, b) => {
                    const aStart = a.start ? a.start.getTime() : 0;
                    const bStart = b.start ? b.start.getTime() : 0;
                    return aStart - bStart;
                });
            }
        }


        function formatQuantity(qty) {
            if (!Number.isFinite(Number(qty))) return qty || 0;
            return Number(qty).toLocaleString();
        }

        function setAVPanel(title, html) {
            const panel = document.getElementById("avPanel");
            const header = document.getElementById("avPanelHeader");
            const content = document.getElementById("avPanelContent");
            if (!panel || !header || !content) return;
            if (!html) {
                clearAVPanel();
                return;
            }
            header.textContent = title;
            content.innerHTML = html;
            panel.style.display = "block";
        }

        function clearAVPanel() {
            const panel = document.getElementById("avPanel");
            const header = document.getElementById("avPanelHeader");
            const content = document.getElementById("avPanelContent");
            if (!panel || !header || !content) return;
            panel.style.display = "none";
            header.textContent = "";
            content.innerHTML = "";
        }

        function jobDetailHtml(job) {
            if (!job) return "";
            const metaLines = [];
            if (job.clientName) metaLines.push(`Client: ${escapeHTML(job.clientName)}`);
            if (job.jobNumber) metaLines.push(`Job #: ${escapeHTML(job.jobNumber)}`);
            if (job.roomName) metaLines.push(`Room: ${escapeHTML(job.roomName)}`);
            if (job.start || job.end) {
                const start = job.start ? formatAMPM(job.start) : "";
                const end = job.end ? formatAMPM(job.end) : "";
                const schedule = start && end ? `${escapeHTML(start)} – ${escapeHTML(end)}` : escapeHTML(start || end);
                if (schedule) metaLines.push(`Schedule: ${schedule}`);
            }
            const parts = [
                `<div class="av-job-title">${escapeHTML(job.orderName || job.jobNumber || "Lighthouse Job")}</div>`
            ];
            if (metaLines.length) {
                parts.push(`<div class="av-meta">${metaLines.join("<br>")}</div>`);
            }
            if (job.contacts && job.contacts.length) {
                parts.push(`<div class="av-sub"><strong>Contacts</strong><ul class="av-list">${job.contacts.map(c => `<li>${escapeHTML(c.name)}${c.role ? ` — ${escapeHTML(c.role)}` : ""}</li>`).join("")}</ul></div>`);
            }
            if (job.equipment && job.equipment.length) {
                parts.push(`<div class="av-sub"><strong>Equipment</strong><table class="av-table"><tbody>${job.equipment.map(item => `<tr><td>${escapeHTML(item.name)}</td><td>${formatQuantity(item.quantity)}</td></tr>`).join("")}</tbody></table></div>`);
            } else {
                parts.push(`<div class="av-sub"><strong>Equipment</strong><p style='opacity:.7;'>No AV gear listed.</p></div>`);
            }
            if (job.labor && job.labor.length) {
                parts.push(`<div class="av-sub"><strong>Labor</strong><table class="av-table"><thead><tr><th>Role</th><th>Start</th><th>End</th></tr></thead><tbody>${job.labor.map(item => `<tr><td>${escapeHTML(item.role || "")}</td><td>${item.start ? escapeHTML(formatAMPM(item.start)) : ""}</td><td>${item.end ? escapeHTML(formatAMPM(item.end)) : ""}</td></tr>`).join("")}</tbody></table></div>`);
            }
            return `<div class="av-job">${parts.join("")}</div>`;
        }

        function renderDailyAVPanel(meta) {
            if (!meta || !Array.isArray(meta.jobs) || !meta.jobs.length) {
                if (!highlightAV) clearAVPanel();
                return;
            }
            const labelParts = [];
            if (meta.room) labelParts.push(meta.room);
            if (meta.company) labelParts.push(meta.company);
            const title = labelParts.length ? `${labelParts.join(" — ")} AV Details` : "Lighthouse AV Details";
            const html = meta.jobs.map(jobDetailHtml).join("<div style='height:8px;'></div>");
            setAVPanel(title, html);
        }

        function buildWeeklySummary() {
            const ws = weekStart(currentDate);
            const summaryDays = [];
            for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                summaryDays.push({ iso: toLocalISODate(d), label: d.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric" }) });
            }
            const weeklyTotals = new Map();
            const counted = new Set();
            const dailyUsage = new Map();
            summaryDays.forEach(({ iso }) => {
                const jobs = lighthouseState.byDate.get(iso) || [];
                jobs.forEach(job => {
                    if (!job || !job.hasEquipment) return;
                    job.equipment.forEach(item => {
                        if (!item) return;
                        const itemKey = item.normalizedName || normalizeSimple(item.name);
                        const jobKey = `${job.id}::${itemKey}`;
                        if (!counted.has(jobKey)) {
                            const weeklyEntry = weeklyTotals.get(itemKey) || { name: item.name, quantity: 0 };
                            weeklyEntry.name = item.name;
                            weeklyEntry.quantity += item.quantity || 0;
                            weeklyTotals.set(itemKey, weeklyEntry);
                            counted.add(jobKey);
                        }
                        if (!dailyUsage.has(iso)) dailyUsage.set(iso, new Map());
                        const dayMap = dailyUsage.get(iso);
                        const dayEntry = dayMap.get(itemKey) || { name: item.name, quantity: 0, day: iso };
                        dayEntry.name = item.name;
                        dayEntry.quantity += item.quantity || 0;
                        dayMap.set(itemKey, dayEntry);
                    });
                });
            });
            const totals = Array.from(weeklyTotals.values()).filter(item => item.quantity > 0).sort((a, b) => b.quantity - a.quantity || a.name.localeCompare(b.name));
            const peak = [];
            dailyUsage.forEach((map, iso) => {
                map.forEach(item => {
                    const existing = peak.find(entry => normalizeSimple(entry.name) === normalizeSimple(item.name));
                    const label = new Date(iso + "T00:00:00").toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric" });
                    if (!existing || item.quantity > existing.quantity) {
                        if (existing) {
                            existing.quantity = item.quantity;
                            existing.day = label;
                        } else {
                            peak.push({ name: item.name, quantity: item.quantity, day: label });
                        }
                    }
                });
            });
            peak.sort((a, b) => b.quantity - a.quantity || a.name.localeCompare(b.name));
            return {
                totals,
                peak,
                hasData: totals.length > 0 || peak.length > 0
            };
        }

        function renderWeeklySummaryPanel(detailMeta = null) {
            const summary = buildWeeklySummary();
            if (!summary.hasData && (!detailMeta || !detailMeta.jobs || !detailMeta.jobs.length)) {
                clearAVPanel();
                return;
            }
            let html = "";
            if (summary.totals.length) {
                html += `<div class="av-section"><h4>Weekly Totals</h4><table class="av-table"><thead><tr><th>Item</th><th>Qty</th></tr></thead><tbody>${summary.totals.map(item => `<tr><td>${escapeHTML(item.name)}</td><td>${formatQuantity(item.quantity)}</td></tr>`).join("")}</tbody></table></div>`;
            } else {
                html += `<div class="av-section"><h4>Weekly Totals</h4><p style='opacity:.7;'>No AV gear recorded.</p></div>`;
            }
            if (summary.peak.length) {
                html += `<div class="av-section"><h4>Peak Daily Usage</h4><table class="av-table"><thead><tr><th>Item</th><th>Peak Qty</th><th>Day</th></tr></thead><tbody>${summary.peak.map(item => `<tr><td>${escapeHTML(item.name)}</td><td>${formatQuantity(item.quantity)}</td><td>${escapeHTML(item.day || "")}</td></tr>`).join("")}</tbody></table></div>`;
            }
            if (detailMeta && detailMeta.jobs && detailMeta.jobs.length) {
                const dayLabel = new Date(detailMeta.dateIso + "T00:00:00").toLocaleDateString("en-US", { weekday: "long", month: "short", day: "numeric" });
                const detailHtml = detailMeta.jobs.map(jobDetailHtml).join("<div style='height:8px;'></div>");
                html += `<div class="av-section"><h4>${escapeHTML(detailMeta.company || "")} — ${escapeHTML(dayLabel)}</h4>${detailHtml}</div>`;
            }
            setAVPanel("Weekly AV Summary", html);
        }

        function getCurrentViewDates() {
            if (viewMode === "day") return [toLocalISODate(currentDate)];
            const dates = [];
            const ws = weekStart(currentDate);
            for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                dates.push(toLocalISODate(d));
            }
            return dates;
        }

        async function fetchLighthouseActionsForDates(dates) {
            if (!dates || !dates.length) return false;
            lighthouseState.fetching = true;
            updateLighthouseStatus("Fetching Lighthouse actions…", "info", true);
            try {
                const dataByDate = new Map();
                const changedEntries = [];
                const fetchTimestamp = new Date().toISOString();
                for (const iso of dates) {
                    const url = `${LIGHTHOUSE_PROXY_ENDPOINT}?date=${encodeURIComponent(iso)}`;
                    const res = await fetch(url, { credentials: "include" });
                    if (!res.ok) {
                        const text = await res.text().catch(() => "");
                        throw new Error(text || `Lighthouse returned ${res.status}`);
                    }
                    const json = await res.json();
                    dataByDate.set(iso, normalizeLighthouseActions(json));
                }
                let changed = false;
                for (const [iso, list] of dataByDate.entries()) {
                    const existing = lighthouseState.rawByDate.get(iso);
                    const serializedExisting = existing ? JSON.stringify(existing) : "";
                    const serializedNew = JSON.stringify(list);
                    if (serializedExisting !== serializedNew) {
                        lighthouseState.rawByDate.set(iso, list);
                        changed = true;
                        changedEntries.push({ iso, payload: list, savedAt: fetchTimestamp });
                    }
                }
                if (changed) {
                    recomputeLighthouseState();
                    if (changedEntries.length) {
                        await persistLighthouseCacheEntries(changedEntries);
                    }
                }
                lighthouseState.lastSync = new Date();
                lighthouseState.enabled = true;
                lighthouseState.autoFetch = true;
                updateLighthouseStatus("Lighthouse data synced.", "success");
                return changed;
            } catch (err) {
                console.error("Lighthouse sync failed", err);
                updateLighthouseStatus(`Sync failed: ${err?.message || err}`, "error", true);
                return false;
            } finally {
                lighthouseState.fetching = false;
            }
        }

        function maybeFetchLighthouseForView() {
            if (!lighthouseState.autoFetch || lighthouseState.fetching) return;
            const desired = getCurrentViewDates();
            const missing = desired.filter(iso => !lighthouseState.byDate.has(iso));
            if (!missing.length) return;
            fetchLighthouseActionsForDates(missing).then(changed => {
                if (changed) {
                    redraw();
                }
            }).catch(err => console.error("Lighthouse auto-fetch failed", err));
        }

        function handleLighthouseSyncClick() {
            if (lighthouseState.fetching) return;
            window.open(LIGHTHOUSE_LOGIN_URL, "lighthouseLogin", "noopener,width=1024,height=768");
            updateLighthouseStatus("Complete Lighthouse login in the popup, then stay here while we sync…", "info", true);
            fetchLighthouseActionsForDates(getCurrentViewDates()).then(changed => {
                if (changed) redraw();
            });
        }

        function findLighthouseMatchesForEvent(ev) {
            if (!lighthouseState.enabled) return [];
            const eventDate = parseDayOfEvent(ev?.["Day of Event"]);
            if (!eventDate) return [];
            const iso = toLocalISODate(eventDate);
            const dayJobs = lighthouseState.byDate.get(iso) || [];
            if (!dayJobs.length) return [];
            const [sh, sm] = parseTime(ev["Start Time"]);
            const [eh, em] = parseTime(ev["End Time"]);
            let start = new Date(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate(), sh, sm);
            let end = new Date(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate(), eh, em);
            if (end <= start) end = new Date(end.getTime() + 24 * 60 * 60 * 1000);
            const rooms = normalizeRooms(ev["Function Space"]);
            const roomSet = new Set();
            rooms.forEach(room => {
                roomSet.add(room);
                const base = PARENT_MAP[room];
                if (base) roomSet.add(base);
            });
            const company = normalizeSimple(ev["Company Name"]);
            const eventName = normalizeSimple(ev["Event Name"]);
            const matches = [];
            const seen = new Set();
            dayJobs.forEach(job => {
                if (!job || !job.hasEquipment) return;
                if (roomSet.size && job.matchRooms && job.matchRooms.size) {
                    let hasRoom = false;
                    job.matchRooms.forEach(r => {
                        if (!hasRoom && roomSet.has(r)) hasRoom = true;
                    });
                    if (!hasRoom) return;
                }
                const jobStart = job.start || start;
                const jobEnd = job.end || end;
                if (jobEnd <= start || jobStart >= end) return;
                const clientMatch = company && job.normalizedClient && job.normalizedClient === company;
                const nameMatch = eventName && job.normalizedOrderName && job.normalizedOrderName === eventName;
                if (!clientMatch && !nameMatch && roomSet.size > 1) return;
                if (!seen.has(job.id)) {
                    matches.push(job);
                    seen.add(job.id);
                }
            });
            return matches;
        }

        function collectJobsForCompanyOnDate(company, dateIso) {
            if (!lighthouseState.enabled || !company) return [];
            const normalized = normalizeSimple(company);
            const jobs = lighthouseState.byDate.get(dateIso) || [];
            const seen = new Set();
            const results = [];
            jobs.forEach(job => {
                if (!job || !job.hasEquipment) return;
                if (job.normalizedClient === normalized && !seen.has(job.id)) {
                    results.push(job);
                    seen.add(job.id);
                }
            });
            return results;
        }

        function handleTimelineSelection() {
            if (!currentTimelineChart) return;
            const selection = currentTimelineChart.getSelection();
            if (!selection || !selection.length) return;
            const rowIndex = selection[0].row;
            if (rowIndex == null) return;
            const meta = currentTimelineMetadata[rowIndex];
            if (!meta) {
                lastSelectionMeta = null;
                if (!highlightAV) clearAVPanel();
                return;
            }
            lastSelectionMeta = meta;
            if (meta.type === "daily") {
                renderDailyAVPanel(meta);
            } else if (meta.type === "weekly") {
                renderWeeklySummaryPanel(meta);
            }
        }

        /* ========= PDF PARSING HEURISTICS ========= */
        const FUNCTION_TYPES = [
            "Meeting", "Breakout", "Breakfast", "Lunch", "Dinner", "Reception",
            "Cocktail Reception", "Board Meeting", "General Session", "Set Up",
            "Holding Room", "Dance", "Ceremony", "Brunch", "Box Lunch",
            "PM Break", "AM Break", "Coffee Break", "Continuous Break",
            "Hospitality Room", "24 Hour Hold", "Storage", "Office",
            "Registration", "Rehearsal", "Special", "Buffet", "Exhibits",
            "Continental Breakfast", "Teardown", "No Agenda Hold"
        ];

        const FUNCTION_SPACES_HINTS = [
            "Director's Room", "The Founders Room",
            "Legacy Ballroom", "Legacy Ballroom I", "Legacy Ballroom II",
            "Legacy I", "Legacy II", "Legacy Prefunction",
            "The Gallery", "Gallery", "Gallery I", "Gallery II",
            "Gallery Prefunction", "Gallery I Prefunction", "Gallery II Prefunction",
            "The Gallery Lounge",
            "Trade Root Restaurant", "Boardroom", "Envoy", "Diplomat", "Ambassador",
            "Plaza I", "Plaza II", "Plaza III", "Plaza II & III", "Plaza", "Plaza Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V",
            "Salon VI", "Salon VII", "Salon VIII",
            "Prefunction", "2nd Floor Prefunction", "Whitley Prefunction",
            "Consulate", "Delegate", "Attache", "Charge",
            "The Whitley Ballroom", "Whitley Ballroom"
        ];

        const SETUP_STYLES = [
            "Conference", "Rounds of 10", "Rounds of 8", "Rounds of 6",
            "Chevron Theatre", "Schoolroom", "U-Shape", "Hollow Square",
            "Cocktail Rounds", "Theatre", "Special",
            "Crescent Rounds", "Lounge", "Storage"
        ];

        const GROUPINGS = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
        };

        const ROMAN_ORDER = { I: 1, II: 2, III: 3, IV: 4, V: 5, VI: 6, VII: 7, VIII: 8 };

        const MEAL_BREAK_TYPES = new Set([
            "Breakfast", "Lunch", "Dinner", "AM Break", "PM Break",
            "Coffee Break", "Continuous Break", "Box Lunch", "Buffet", "Continental Breakfast"
        ]);

        const FALLBACK_TYPES = new Set([...MEAL_BREAK_TYPES, "Meeting", "Rehearsal", "Exhibits"]);

        const TIME_RANGE_RE = /(\d{1,2}:\d{2}\s?[AP]M)\s*[-–—]\s*(\d{1,2}:\d{2}\s?[AP]M)/i;
        const DATE_LINE_RE = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), .* \d{4}$/i;
        const COUNTS_RE = /^\d+\/\d+\/(?:\d+|__)$/;
        const POST_AS_RE = /Post As[:\-]?\s*(.+)/i;

        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function romanToInt(r) {
            return ROMAN_ORDER[r] ?? 999;
        }

        function splitRomanList(str) {
            const cleaned = str.replace(/\s*(?:&|and)\s*/gi, ",");
            return cleaned
                .split(",")
                .map(p => p.trim().toUpperCase())
                .filter(p => p && /^[IVX]+$/.test(p));
        }

        function expandCompoundPrefix(lineText) {
            const found = new Set();
            const checks = [
                { prefix: "Salon", regex: /\bSalon\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Plaza", regex: /\bPlaza\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Legacy", regex: /\bLegacy\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
            ];
            checks.forEach(({ prefix, regex }) => {
                let match;
                while ((match = regex.exec(lineText))) {
                    splitRomanList(match[1]).forEach(r => found.add(`${prefix} ${r}`));
                }
            });
            return Array.from(found);
        }

        function expandGroupedSpace(lineText, primary) {
            const compound = new Set(expandCompoundPrefix(lineText));

            Object.entries(GROUPINGS).forEach(([ballroom, subs]) => {
                subs.forEach(sub => {
                    const re = new RegExp(`\\b${escapeRegExp(sub)}\\b`);
                    if (re.test(lineText)) compound.add(sub);
                });
            });

            if (/\bAttache\b/i.test(lineText) && /\bCharge\b/i.test(lineText)) {
                return "Attache Charge";
            }

            if (!compound.size) {
                return primary ? primary.trim() : primary;
            }

            const whitley = Array.from(compound).filter(s => s.startsWith("Salon "));
            const plaza = Array.from(compound).filter(s => s.startsWith("Plaza "));
            const legacy = Array.from(compound).filter(s => s.startsWith("Legacy "));

            if (whitley.length) {
                const romans = Array.from(new Set(whitley.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Whitley Ballroom (${romans.map(r => `Salon ${r}`).join(", ")})`;
            }
            if (plaza.length) {
                const romans = Array.from(new Set(plaza.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Plaza Ballroom (${romans.map(r => `Plaza ${r}`).join(", ")})`;
            }
            if (legacy.length) {
                const romans = Array.from(new Set(legacy.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Legacy Ballroom (${romans.map(r => `Legacy ${r}`).join(", ")})`;
            }

            return primary ? primary.trim() : primary;
        }

        function detectFunctionType(text) {
            if (/\bContinental\b/i.test(text)) return "Continental Breakfast";
            const sorted = [...FUNCTION_TYPES].sort((a, b) => b.length - a.length);
            for (const f of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(f)}\\b`, "i");
                if (re.test(text)) return f;
            }
            return null;
        }

        function detectSetupStyle(text) {
            const sorted = [...SETUP_STYLES].sort((a, b) => b.length - a.length);
            for (const s of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(s)}\\b`, "i");
                if (re.test(text)) return s;
            }
            return null;
        }

        function detectSpace(text) {
            for (const hint of FUNCTION_SPACES_HINTS) {
                const re = new RegExp(`\\b${escapeRegExp(hint)}\\b`);
                if (re.test(text)) return hint;
            }
            return null;
        }

        function cleanTimeString(raw) {
            if (!raw) return "";
            const match = raw.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
            if (!match) return raw.trim();
            const hour = String(Number(match[1]));
            const minute = match[2];
            const mod = match[3].toUpperCase();
            return `${hour}:${minute} ${mod}`;
        }

        /* ========= ROOM ORDERING ========= */
        const ROOM_ORDER = [
            "Whitley Ballroom", "Whitley Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII",
            "Plaza Ballroom", "Plaza Prefunction", "Plaza I", "Plaza II", "Plaza III",
            "Gallery", "Gallery Prefunction", "Gallery I", "Gallery II",
            "Legacy Ballroom", "Legacy Prefunction", "Legacy I", "Legacy II",
            "Ambassador", "Attache", "Attache Charge", "Boardroom", "Charge", "Consulate",
            "Delegate", "Diplomat", "Director's Room", "Envoy", "The Founders Room"
        ];
        const SUBORDER = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
            "Gallery": ["Gallery I", "Gallery II"]
        };
        const PARENT_MAP = {};
        Object.entries(SUBORDER).forEach(([p, subs]) => subs.forEach(s => PARENT_MAP[s] = p));

        /* ========= UTILS ========= */
        function parseDayOfEvent(str) {
            if (!str) return null;
            let d = new Date(str);
            if (isNaN(d)) d = new Date(String(str).replace(/^[A-Za-z]+,\s*/, ""));
            return isNaN(d) ? null : d;
        }

        function parseTime(str) {
            if (!str) return [0, 0];
            const parts = String(str).trim().split(" ");
            const timePart = parts[0] || "0:00";
            const mod = (parts[1] || "").toUpperCase();
            const hhmm = timePart.split(":");
            let h = Number(hhmm[0] || 0),
                m = Number(hhmm[1] || 0);
            if (mod === "PM" && h < 12) h += 12;
            if (mod === "AM" && h === 12) h = 0;
            return [h, m];
        }

        function toLocalISODate(d) {
            return d.getFullYear() + "-" + String(d.getMonth() + 1).padStart(2, "0") + "-" + String(d.getDate()).padStart(2, "0");
        }

        function sameDay(a, b) {
            return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
        }

        function formatAMPM(d) {
            let h = d.getHours(),
                m = d.getMinutes(),
                ampm = h >= 12 ? "PM" : "AM";
            h = h % 12;
            h = h ? h : 12;
            m = m < 10 ? "0" + m : m;
            return `${h}:${m} ${ampm}`;
        }

        function escapeHTML(value) {
            return (value || "").toString().replace(/[&<>"']/g, ch => ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            }[ch] || ch));
        }

        function monthLabel(d) {
            return d.toLocaleString("en-US", {
                month: "long",
                year: "numeric"
            });
        }

        function weekStart(d) {
            const x = new Date(d);
            const day = x.getDay();
            x.setDate(x.getDate() - day);
            x.setHours(0, 0, 0, 0);
            return x;
        } // Sunday 00:00
        function weekEnd(d) {
            const ws = weekStart(d);
            const we = new Date(ws);
            we.setDate(ws.getDate() + 6);
            we.setHours(23, 59, 59, 999);
            return we;
        }

        function shortTick(d) {
            return d.toLocaleDateString("en-US", {
                weekday: "short",
                month: "numeric",
                day: "numeric"
            });
        }

        function condenseSubs(list) {
            if (!list.length) return "";
            const m = list[0].match(/^([A-Za-z]+(?:\s[A-Za-z]+)?)\s+/);
            let prefix = m ? m[1] + " " : "";
            if (prefix && !list.every(x => x.startsWith(prefix))) prefix = "";
            if (!prefix) return list.join(", ");
            const rest = list.map(x => x.slice(prefix.length)).join(", ");
            return prefix + rest;
        }

        function normalizeRooms(raw) {
            if (!raw) return [];
            let s = String(raw).trim();
            if (s === "The Whitley Ballroom") s = "Whitley Ballroom";
            if (s === "The Gallery") s = "Gallery";
            if (s === "Plaza") s = "Plaza Ballroom";
            if (s === "Founder's Room" || s === "Founders Room") s = "The Founders Room";
            if (s === "Legacy Ballroom I") s = "Legacy I";
            if (s === "Legacy Ballroom II") s = "Legacy II";
            if (s.toLowerCase() === "attache charge") return ["Attache Charge"];
            if (s === "Prefunction") return ["Whitley Prefunction"];
            if (s.includes("(") && s.includes(")")) {
                const inner = s.slice(s.indexOf("(") + 1, s.lastIndexOf(")")).trim();
                if (inner) return inner.split(",").map(x => x.trim());
            }
            if (s.includes(",")) return s.split(",").map(p => p.trim());
            return [s];
        }

        function groupRoomsToLabels(rooms) {
            const byBase = new Map();
            rooms.forEach(r => {
                const base = PARENT_MAP[r] || r;
                const isSub = !!PARENT_MAP[r];
                if (!byBase.has(base)) byBase.set(base, {
                    base,
                    subs: new Set()
                });
                if (isSub) byBase.get(base).subs.add(r);
            });
            const out = [];
            for (const {
                    base,
                    subs
                }
                of byBase.values()) {
                if (subs.size > 0) {
                    const all = SUBORDER[base] || [];
                    if (subs.size === all.length) {
                        out.push({
                            label: base,
                            base
                        });
                    } else {
                        let list = Array.from(subs);
                        if (all.length) list.sort((a, b) => all.indexOf(a) - all.indexOf(b));
                        const condensed = condenseSubs(list);
                        out.push({
                            label: `${base} (${condensed})`,
                            base
                        });
                    }
                } else out.push({
                    label: base,
                    base
                });
            }
            return out;
        }
        // Convert "YYYY-MM-DD" into a Date at LOCAL midnight
        function fromISODateLocal(iso) {
            const [y, m, d] = iso.split("-").map(Number);
            return new Date(y, m - 1, d, 0, 0, 0, 0);
        }

        /* ======== SEARCH FILTER (timeline-only) ======== */
        function buildSuggestions() {
            const names = new Set();
            (reportA || []).forEach(r => {
                if (r["Company Name"]) names.add(r["Company Name"].trim());
                if (r["Event Name"]) names.add(r["Event Name"].trim());
            });
            suggestionsList = Array.from(names).sort((a, b) => a.localeCompare(b));
        }

        function applySearchFilter(rows) {
            if (!searchTerm) return rows;
            const q = searchTerm.toLowerCase();
            // Filter by company OR event name
            return rows.filter(ev => {
                const c = (ev["Company Name"] || "").toLowerCase();
                const e = (ev["Event Name"] || "").toLowerCase();
                return c.includes(q) || e.includes(q);
            });
        }

        /* ========= TOOLTIP FOR DAILY ========= */
        function groupTooltip(room, items, status) {
            items.sort((a, b) => a.start - b.start);
            let html = `<div style="padding:6px;">`;
            if (items[0]?.event) html += `<div style="font-weight:700; margin-bottom:4px;">${items[0].event}</div>`;
            if (status) html += `<div style="margin-bottom:6px"><span style="padding:2px 6px;border-radius:6px;background:#eef;border:1px solid #ccd">${status}</span></div>`;
            html += `<div style="font-weight:600; margin-bottom:4px;">${room}</div>`;
            items.forEach(e => {
                const time = `${formatAMPM(e.start)} – ${formatAMPM(e.end)}`;
                html += `<div><b>${e.function||""}</b> · ${time} · ${e.setup||""}</div>`;
            });
            html += `</div>`;
            return html;
        }

        /* ========= TIMELINE DRAWERS ========= */
        function drawDaily(selectedDateISO) {
            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Room"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(selectedDateISO + "T00:00:00");
            currentDate = chosen;
            lastSelectionMeta = null;

            const groups = {};
            const rowMetadata = [];
            let dataMin = null,
                dataMax = null;

            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const status = (ev["Event Status"] || "").toString().trim();
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const rooms = normalizeRooms(ev["Function Space"]);
                const company = ev["Company Name"] || "";
                const eventName = ev["Event Name"] || "";
                const labels = groupRoomsToLabels(rooms);
                const matches = findLighthouseMatchesForEvent(ev);

                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        if (sameDay(d, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: start,
                                max: midnight,
                                jobSet: new Map()
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start,
                                end: midnight,
                                jobs: matches
                            });
                            if (start < groups[key].min) groups[key].min = start;
                            if (midnight > groups[key].max) groups[key].max = midnight;
                            if (!dataMin || start < dataMin) dataMin = start;
                            if (!dataMax || midnight > dataMax) dataMax = midnight;
                            if (matches.length) {
                                matches.forEach(job => groups[key].jobSet.set(job.id, job));
                                groups[key].hasAV = true;
                            }
                        }
                        if (sameDay(nextDay, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + nextDay.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: nextDay,
                                max: endNext,
                                jobSet: new Map()
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start: nextDay,
                                end: endNext,
                                jobs: matches
                            });
                            if (nextDay < groups[key].min) groups[key].min = nextDay;
                            if (endNext > groups[key].max) groups[key].max = endNext;
                            if (!dataMin || nextDay < dataMin) dataMin = nextDay;
                            if (!dataMax || endNext > dataMax) dataMax = endNext;
                            if (matches.length) {
                                matches.forEach(job => groups[key].jobSet.set(job.id, job));
                                groups[key].hasAV = true;
                            }
                        }
                    });
                    return;
                }

                if (sameDay(d, chosen)) {
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                        if (!groups[key]) groups[key] = {
                            roomLabel: label,
                            base,
                            company,
                            status,
                            items: [],
                            min: start,
                            max: end,
                            jobSet: new Map()
                        };
                        groups[key].items.push({
                            event: eventName,
                            function: ev["Function Type"],
                            setup: ev["Setup Style"],
                            start,
                            end,
                            jobs: matches
                        });
                        if (start < groups[key].min) groups[key].min = start;
                        if (end > groups[key].max) groups[key].max = end;
                        if (matches.length) {
                            matches.forEach(job => groups[key].jobSet.set(job.id, job));
                            groups[key].hasAV = true;
                        }
                    });
                    if (!dataMin || start < dataMin) dataMin = start;
                    if (!dataMax || end > dataMax) dataMax = end;
                }
            });

            const rows = [];
            const usedBases = new Set();
            ROOM_ORDER.forEach(roomBase => {
                Object.values(groups).forEach(g => {
                    if (g.base === roomBase && sameDay(g.min, chosen)) {
                        usedBases.add(roomBase);
                        const jobs = g.jobSet ? Array.from(g.jobSet.values()) : [];
                        const style = highlightAV && jobs.length ? AV_STYLE : "";
                        rows.push([g.roomLabel, g.company || g.items[0]?.event || "", groupTooltip(g.roomLabel, g.items, g.status), style, g.min, g.max]);
                        rowMetadata.push({
                            type: "daily",
                            room: g.roomLabel,
                            company: g.company || "",
                            status: g.status,
                            dateIso: toLocalISODate(chosen),
                            jobs,
                            items: g.items
                        });
                    }
                });
                if (showAllRooms && !usedBases.has(roomBase)) {
                    const base = dataMin || new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 8, 0);
                    rows.push([roomBase, "", "", "color:#E5E7EB;", base, new Date(base.getTime() + 60000)]);
                    rowMetadata.push(null);
                }
            });
            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No events found for this date.</p>";
                return;
            }

            dt.addRows(rows);

            // full-day window
            const startHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 0, 0, 0, 0);
            const endHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 23, 59, 59, 999);
            const ticks = [];
            let t = new Date(startHour);
            while (t <= endHour) {
                ticks.push(new Date(t));
                t.setHours(t.getHours() + 1);
            }

            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "h a",
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: startHour,
                        max: endHour
                    }
                },
                timeline: {
                    showBarLabels: true,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });
            currentTimelineChart = chart;
            currentTimelineData = dt;
            currentTimelineMetadata = rowMetadata;
            currentTimelineMode = "day";
            google.visualization.events.removeAllListeners(chart);
            google.visualization.events.addListener(chart, "select", handleTimelineSelection);
            if (!highlightAV || !lastSelectionMeta || !lastSelectionMeta.jobs || !lastSelectionMeta.jobs.length) {
                clearAVPanel();
            }
        }

        /* Weekly: Sun→Sat columns always visible; per company, add day segments (filled when present) */
        function drawWeekly(anyDateISO) {
            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Company"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(anyDateISO + "T00:00:00");
            currentDate = chosen;
            lastSelectionMeta = null;
            const ws = weekStart(chosen); // Sun 00:00
            const we = weekEnd(chosen); // Sat 23:59:59.999

            // Per-company occupancy by day (from filtered events)
            const perCompany = new Map(); // company -> Map(dayISO -> Set(rooms))
            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const company = ev["Company Name"] || "";
                const rooms = normalizeRooms(ev["Function Space"]);

                const spans = [];
                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    spans.push({
                        s: start,
                        e: midnight
                    });
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    spans.push({
                        s: new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), 0, 0, 0, 0),
                        e: endNext
                    });
                } else {
                    spans.push({
                        s: start,
                        e: end
                    });
                }

                spans.forEach(({
                    s,
                    e
                }) => {
                    // iterate each day from s..e; collect rooms for any day that intersects week
                    let cursor = new Date(s);
                    while (cursor <= e) {
                        const dayStart = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 0, 0, 0, 0);
                        const dayEnd = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 23, 59, 59, 999);
                        if (dayEnd >= ws && dayStart <= we) {
                            if (!perCompany.has(company)) perCompany.set(company, new Map());
                            const dayIso = toLocalISODate(dayStart);
                            if (!perCompany.get(company).has(dayIso)) perCompany.get(company).set(dayIso, new Set());
                            rooms.forEach(r => perCompany.get(company).get(dayIso).add(r));
                        }
                        cursor.setDate(cursor.getDate() + 1);
                        cursor.setHours(0, 0, 0, 0);
                    }
                });
            });

            // Compute overall in-house span per company
            const companySpans = new Map();
            for (const [company, days] of perCompany.entries()) {
                const allDates = Array.from(days.keys()).map(d => fromISODateLocal(d));
                if (allDates.length) {
                    allDates.sort((a, b) => a - b); // earliest to latest
                    companySpans.set(company, {
                        start: allDates[0],
                        end: allDates[allDates.length - 1]
                    });
                }
            }

            // Rows: each company gets 7 day segments (Sun..Sat), filled if they have rooms
            const rows = [];
            const rowMetadata = [];
            const companies = Array.from(perCompany.keys()).sort((a, b) => a.localeCompare(b));
            companies.forEach(company => {
                for (let i = 0; i < 7; i++) {
                    const d = new Date(ws);
                    d.setDate(ws.getDate() + i);
                    const dayIso = toLocalISODate(d);
                    const has = perCompany.get(company).has(dayIso) && perCompany.get(company).get(dayIso).size > 0;
                    const roomsList = has ? Array.from(perCompany.get(company).get(dayIso)).sort() : [];
                    const segStart = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
                    const segEnd = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);
                    const jobMatches = collectJobsForCompanyOnDate(company, dayIso);
                    let style = has ? "" : "color:#E5E7EB;";
                    if (highlightAV && jobMatches.length) style = AV_STYLE;

                    const weekRange = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
                    const span = companySpans.get(company);
                    const spanText = span ?
                        `${span.start.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${span.end.toLocaleDateString("en-US",{month:"short",day:"numeric"})}` :
                        "";

                    const tip = `
  <div style="padding:6px;max-width:260px;">
    <div style="font-weight:700;margin-bottom:4px;">${company}</div>
    <div><b>${d.toLocaleDateString("en-US",{weekday:"short", month:"short", day:"numeric"})}</b></div>
    <div style="margin:6px 0;"><i>In-house:</i> ${spanText}</div>
    <div><b>Rooms:</b> ${roomsList.join(", ")}</div>
  </div>
`.trim();


                    rows.push([company, "", tip, style, segStart, segEnd]);
                    rowMetadata.push({
                        type: "weekly",
                        company,
                        dateIso: dayIso,
                        jobs: jobMatches,
                        rooms: roomsList
                    });
                }
            });

            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No companies intersect this week.</p>";
                return;
            }
            dt.addRows(rows);

            // Axis ticks: always Sun..Sat, labels like "Sun 9/21"
            const ticks = [];
            for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                d.setHours(0, 0, 0, 0); // midnight, not noon
                ticks.push(d);
            }


            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "EEE M/d", // <-- fixed: use pattern, not function
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: new Date(ws),
                        max: new Date(we)
                    }
                },
                timeline: {
                    showBarLabels: false,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });
            currentTimelineChart = chart;
            currentTimelineData = dt;
            currentTimelineMetadata = rowMetadata;
            currentTimelineMode = "weekly";
            google.visualization.events.removeAllListeners(chart);
            google.visualization.events.addListener(chart, "select", handleTimelineSelection);
            if (highlightAV) {
                renderWeeklySummaryPanel(null);
            } else {
                clearAVPanel();
            }
        }

        /* ========= CHANGE LOG =========
           (Kept as your working logic from last version.
            Only re-rendered when both reports present and Change Log tab is opened.) */
        function generateChangeLog(reportA, reportB) {
            const container = document.getElementById("changeLog");
            container.innerHTML = "";

            if (!reportA.length || !reportB.length) {
                container.innerHTML = "<p style='opacity:.8'>Upload both reports to see changes.</p>";
                return;
            }

            // Company + Event + Date + Room + Function Type + Post As
            const makeKey = ev => [
                ev["Company Name"], ev["Event Name"], ev["Day of Event"],
                ev["Function Space"], ev["Function Type"], ev["Post As"] || ""
            ].join("||");

            const mapB = new Map();
            reportB.forEach(ev => mapB.set(makeKey(ev), ev));

            const companyGroups = {};
            reportA.forEach(ev => {
                const key = makeKey(ev);
                const old = mapB.get(key);
                if (!old) return; // only overlapping entries

                const diffs = [];
                ["Start Time", "End Time", "Setup Style", "Event Status"].forEach(field => {
                    if ((ev[field] || "").trim() !== (old[field] || "").trim()) {
                        diffs.push({
                            field,
                            prev: old[field] || "",
                            newest: ev[field] || ""
                        });
                    }
                });

                if (diffs.length) {
                    const company = ev["Company Name"] || "";
                    const event = ev["Event Name"] || "";
                    const space = ev["Function Space"] || "";
                    const ftype = ev["Function Type"] || "";
                    const pas = ev["Post As"] || "";
                    if (!companyGroups[company]) companyGroups[company] = {};
                    if (!companyGroups[company][event]) companyGroups[company][event] = [];
                    companyGroups[company][event].push({
                        space,
                        ftype,
                        pas,
                        diffs,
                        date: ev["Day of Event"]
                    });
                }
            });

            if (Object.keys(companyGroups).length === 0) {
                container.innerHTML = "<p style='opacity:.7'>✅ No changes detected between the reports.</p>";
                return;
            }

            for (const company of Object.keys(companyGroups)) {
                const compHeader = document.createElement("div");
                compHeader.className = "company-header";
                compHeader.textContent = company;
                container.appendChild(compHeader);

                for (const event of Object.keys(companyGroups[company])) {
                    const evHeader = document.createElement("div");
                    evHeader.className = "event-header";
                    evHeader.textContent = event;
                    container.appendChild(evHeader);

                    companyGroups[company][event].forEach(change => {
                        const card = document.createElement("div");
                        card.className = "change-card";
                        card.innerHTML = `
            <h4>${change.space} — ${change.ftype} ${change.pas?("· "+change.pas):""}</h4>
            <div style="font-size:.8rem;color:#555;margin-bottom:4px;">${change.date}</div>
            <ul>
              ${change.diffs.map(d=>
                `<li>${d.field}:
                  <span class="change-prev">${d.prev}</span> →
                  <span class="change-new">${d.newest}</span>
                </li>`).join("")}
            </ul>`;
                        container.appendChild(card);
                    });
                }
            }
        }


        /* ========= FORECAST (unchanged) ========= */
        function renderForecast() {
            const host = document.getElementById("forecast");
            host.innerHTML = "";

            if (!reportA.length) {
                host.innerHTML = "<p style='opacity:.8'>Upload the newest report to view today’s schedule summary.</p>";
                return;
            }

            const now = new Date();
            const todayISO = toLocalISODate(now);

            const todays = reportA.filter(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                return d && toLocalISODate(d) === todayISO;
            });

            if (!todays.length) {
                host.innerHTML = "<p style='opacity:.8'>No events scheduled for today.</p>";
                return;
            }

            const entries = todays.map(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                return {
                    company: ev["Company Name"] || "",
                    event: ev["Event Name"] || "",
                    space: ev["Function Space"] || "",
                    start: new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm),
                    end: new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em),
                };
            });

            const merged = (() => {
                const map = new Map();
                entries.forEach(e => {
                    const key = `${e.company}||${e.space}`;
                    if (!map.has(key)) {
                        map.set(key, {
                            company: e.company,
                            space: e.space,
                            start: new Date(e.start),
                            end: new Date(e.end),
                            events: [e.event]
                        });
                    } else {
                        const g = map.get(key);
                        if (e.start < g.start) g.start = new Date(e.start);
                        if (e.end > g.end) g.end = new Date(e.end);
                        g.events.push(e.event);
                    }
                });
                return Array.from(map.values()).sort((a, b) => a.start - b.start);
            })();

            const companyGroups = {};
            entries.forEach(ev => {
                if (!companyGroups[ev.company]) companyGroups[ev.company] = {};
                if (!companyGroups[ev.company][ev.event]) companyGroups[ev.company][ev.event] = new Set();
                companyGroups[ev.company][ev.event].add(ev.space);
            });

            const compCard = document.createElement("div");
            compCard.className = "forecast-card";
            compCard.innerHTML = "<h3>Companies & Function Spaces</h3>";
            for (const [company, events] of Object.entries(companyGroups)) {
                const group = document.createElement("div");
                group.className = "company-group";
                group.innerHTML = `<div class="company-name">${company}</div>`;
                for (const [event, spaces] of Object.entries(events)) {
                    const evBlock = document.createElement("div");
                    evBlock.className = "event-block";
                    evBlock.innerHTML = `<div class="event-title">${event}</div><div>${Array.from(spaces).map(s=>`<span class="space-pill">${s}</span>`).join("")}</div>`;
                    group.appendChild(evBlock);
                }
                compCard.appendChild(group);
            }
            host.appendChild(compCard);

            const nowList = merged.filter(e => now >= e.start && now < e.end);
            const nextList = merged.filter(e => e.start > now);

            const happeningCard = document.createElement("div");
            happeningCard.className = "forecast-card happening";
            happeningCard.innerHTML = "<h3>What's Happening</h3>";

            const renderSection = (title, list, cls) => {
                const sec = document.createElement("div");
                sec.className = `section ${cls}`;
                sec.innerHTML = `<strong>${title}</strong>`;
                if (!list.length) {
                    sec.innerHTML += `<p style='opacity:.7;font-size:.85rem'>No events</p>`;
                } else {
                    list.forEach(e => {
                        const row = document.createElement("div");
                        row.className = "happening-row";
                        row.innerHTML = `<span><b>${e.company}</b> — ${e.space}</span><span>${formatAMPM(e.start)} – ${formatAMPM(e.end)}</span>`;
                        sec.appendChild(row);
                    });
                }
                happeningCard.appendChild(sec);
            };

            renderSection("Now", nowList, "now");
            renderSection("Next", nextList, "next");
            host.appendChild(happeningCard);

            const byRoom = {};
            entries.forEach(e => {
                (byRoom[e.space] ||= []).push(e);
            });
            const flips = [];
            Object.values(byRoom).forEach(list => {
                list.sort((a, b) => a.start - b.start);
                for (let i = 1; i < list.length; i++) {
                    const prev = list[i - 1],
                        curr = list[i];
                    const gap = (curr.start - prev.end) / 60000;
                    if (gap >= 0 && gap <= 30 && prev.company !== curr.company) {
                        flips.push({
                            room: curr.space,
                            prev,
                            curr,
                            gap
                        });
                    }
                }
            });
            if (flips.length) {
                const warn = document.createElement("div");
                warn.className = "warning-box";
                warn.innerHTML = "<h3 style='margin:0 0 8px 0;color:#facc15;'>Warnings: Quick Room Flips</h3>";
                flips.forEach(f => {
                    const box = document.createElement("div");
                    box.innerHTML = `<strong>${f.room}</strong> ${f.prev.company} (${formatAMPM(f.prev.start)} – ${formatAMPM(f.prev.end)}) → ${f.curr.company} (${formatAMPM(f.curr.start)} – ${formatAMPM(f.curr.end)})`;
                    warn.appendChild(box);
                });
                host.appendChild(warn);
            }
        }

        /* ========= PDF UPLOAD ========= */
        async function extractPdfLines(file) {
            if (!window.pdfjsLib) {
                throw new Error("PDF.js library is not available");
            }
            const data = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data }).promise;
            const lines = [];

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();
                const items = textContent.items
                    .map(item => ({
                        text: (item.str || "").trim(),
                        x: item.transform?.[4] ?? 0,
                        y: item.transform?.[5] ?? 0
                    }))
                    .filter(item => item.text);

                items.sort((a, b) => {
                    const yDiff = Math.abs(b.y - a.y);
                    if (yDiff > 2) {
                        return b.y - a.y; // top to bottom
                    }
                    return a.x - b.x; // left to right
                });

                let currentY = null;
                let parts = [];
                items.forEach(item => {
                    if (currentY === null || Math.abs(item.y - currentY) <= 2) {
                        parts.push(item.text);
                        currentY = item.y;
                    } else {
                        const normalized = parts.join(' ').replace(/\s+/g, ' ').trim();
                        if (normalized) lines.push(normalized);
                        parts = [item.text];
                        currentY = item.y;
                    }
                });
                if (parts.length) {
                    const normalized = parts.join(' ').replace(/\s+/g, ' ').trim();
                    if (normalized) lines.push(normalized);
                }
            }

            return lines;
        }

        async function loadPDF(file, target) {
            const lines = await extractPdfLines(file);
            const rows = [];

            let currentCompany = null;
            let currentEvent = null;
            let currentDateStr = null;
            let currentStatus = null;
            let inEventHeader = false;
            let inEventBody = false;
            const lastSpaceByEvent = new Map();

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) {
                    continue;
                }

                if (line.includes("Quote #:")) {
                    currentCompany = line.split("Quote #:")[0].trim();
                    inEventHeader = true;
                    inEventBody = false;
                    continue;
                }

                if (line.includes("Status:")) {
                    const statusMatch = line.match(/Status:\s*(\w+)/i);
                    if (statusMatch) {
                        currentStatus = statusMatch[1].trim();
                    }
                    continue;
                }

                if (line.includes("Folio #:")) {
                    const evMatch = line.match(/(.+?)\s+Folio #:/);
                    if (evMatch) {
                        currentEvent = evMatch[1].trim();
                        inEventHeader = true;
                        inEventBody = false;
                    }
                    continue;
                }

                if (DATE_LINE_RE.test(line)) {
                    currentDateStr = line.trim();
                    continue;
                }

                const postMatch = line.match(POST_AS_RE);
                if (postMatch && rows.length && inEventBody) {
                    const last = rows[rows.length - 1];
                    if (last["Function Space"] && !last["Post As"]) {
                        last["Post As"] = postMatch[1].trim();
                    }
                    continue;
                }
                if (postMatch && inEventHeader) {
                    continue;
                }

                const timeMatch = line.match(TIME_RANGE_RE);
                if (!timeMatch) {
                    continue;
                }

                inEventHeader = false;
                inEventBody = true;

                const startTime = cleanTimeString(timeMatch[1]);
                const endTime = cleanTimeString(timeMatch[2]);
                const functionType = detectFunctionType(line);
                const setupStyle = detectSetupStyle(line);
                let functionSpace = detectSpace(line);
                functionSpace = expandGroupedSpace(line, functionSpace);

                if (functionSpace && COUNTS_RE.test(functionSpace.trim())) {
                    functionSpace = null;
                }

                const eventKey = `${currentCompany || ""}||${currentEvent || ""}`;
                if (!functionSpace && functionType && FALLBACK_TYPES.has(functionType)) {
                    const lastSpace = lastSpaceByEvent.get(eventKey);
                    if (lastSpace) {
                        functionSpace = lastSpace;
                    }
                }

                if (!functionSpace) {
                    continue;
                }

                lastSpaceByEvent.set(eventKey, functionSpace);

                rows.push({
                    "Company Name": currentCompany || "",
                    "Event Name": currentEvent || "",
                    "Event Status": currentStatus || "",
                    "Day of Event": currentDateStr || "",
                    "Start Time": startTime,
                    "End Time": endTime,
                    "Function Type": functionType || "",
                    "Function Space": functionSpace || "",
                    "Setup Style": setupStyle || "",
                    "Post As": "",
                    "Raw Line": line
                });
            }

            ingestRows(target, rows);
            return rows;
        }

        function ingestRows(target, rows) {
            const filtered = rows.filter(r => r && r["Day of Event"]);
            if (target === "A") {
                reportA = filtered;
                allEvents = filtered;
                buildSuggestions();
                redraw();
                renderForecast();
            } else {
                reportB = filtered;
            }
            if (reportA.length && reportB.length) {
                generateChangeLog(reportA, reportB);
            }
        }

        async function processPdfUpload(file, target) {
            if (!file) return;
            try {
                const rows = await loadPDF(file, target);
                if (!rows.length) {
                    alert(`No events were recognized in ${file.name}.`);
                }
                await saveParsedReport(file, rows, target);
            } catch (err) {
                console.error(err);
                alert(`Unable to parse ${file.name}: ${err?.message || err}`);
            }
        }

        /* ========= DATE / VIEW CONTROLS ========= */
        function syncDateLabel() {
            const label = document.getElementById("dateLabel");
            if (viewMode === "day") {
                label.textContent = currentDate.toLocaleDateString("en-US", {
                    weekday: "short",
                    month: "short",
                    day: "numeric",
                    year: "numeric"
                });
            } else {
                const ws = weekStart(currentDate),
                    we = weekEnd(currentDate);
                label.textContent = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
            }
        }

        function redraw() {
            if (!google?.charts) return;
            if (viewMode === "day") drawDaily(toLocalISODate(currentDate));
            else drawWeekly(toLocalISODate(currentDate));
            maybeFetchLighthouseForView();
        }

        function changeDay(offset) {
            const nd = new Date(currentDate);
            nd.setDate(currentDate.getDate() + offset);
            currentDate = nd;
            syncDateUI(currentDate);
            redraw();
        }

        /* ========= CALENDAR ========= */
        const calTable = document.getElementById("calTable");
        const calMonthLabel = document.getElementById("calMonthLabel");

        function renderCalendar(focusDate) {
            const year = focusDate.getFullYear(),
                month = focusDate.getMonth();
            calMonthLabel.textContent = monthLabel(focusDate);
            const first = new Date(year, month, 1);
            const startDay = first.getDay(); // Sun=0
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const prevMonthDays = new Date(year, month, 0).getDate();
            const cells = [];

            for (let i = 0; i < startDay; i++) {
                cells.push({
                    d: new Date(year, month - 1, prevMonthDays - startDay + 1 + i),
                    muted: true
                });
            }
            for (let d = 1; d <= daysInMonth; d++) {
                cells.push({
                    d: new Date(year, month, d),
                    muted: false
                });
            }
            while (cells.length < 42) {
                const nextDay = cells.length - (startDay + daysInMonth) + 1;
                cells.push({
                    d: new Date(year, month + 1, nextDay),
                    muted: true
                });
            }

            const ws = weekStart(currentDate),
                we = weekEnd(currentDate);

            let html = "<thead><tr>" + ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map(d => `<th>${d}</th>`).join("") + "</tr></thead><tbody>";
            for (let r = 0; r < 6; r++) {
                html += "<tr>";
                for (let c = 0; c < 7; c++) {
                    const idx = r * 7 + c,
                        cell = cells[idx];
                    const isActive = cell.d.toDateString() === currentDate.toDateString();
                    const isRealToday = (new Date()).toDateString() === cell.d.toDateString();
                    const inWeek = cell.d >= ws && cell.d <= we;
                    html += `<td class="${cell.muted?"muted":""} ${isActive?"active":""} ${isRealToday?"real-today":""} ${inWeek?"in-week":""}"
        data-y="${cell.d.getFullYear()}" data-m="${cell.d.getMonth()}" data-d="${cell.d.getDate()}">${cell.d.getDate()}</td>`;
                }
                html += "</tr>";
            }
            html += "</tbody>";
            calTable.innerHTML = html;
            calTable.parentElement.classList.add("week-highlight");

            calTable.querySelectorAll("td").forEach(td => {
                td.addEventListener("click", () => {
                    const y = +td.getAttribute("data-y"),
                        m = +td.getAttribute("data-m"),
                        d = +td.getAttribute("data-d");
                    currentDate = new Date(y, m, d);
                    syncDateUI(currentDate);
                    redraw();
                });
            });
        }

        function syncDateUI(d) {
            renderCalendar(d);
            syncDateLabel();
        }

        /* ========= SEARCH UI (autosuggest) ========= */
        function wireSearch() {
            const input = document.getElementById("timelineSearch");
            const box = document.getElementById("searchSuggest");
            const status = document.getElementById("searchStatus");
            const clearBtn = document.getElementById("clearSearch");

            function closeSuggest() {
                box.style.display = "none";
            }

            function openSuggest() {
                box.style.display = "block";
            }

            function renderSuggest() {
                const q = (input.value || "").trim().toLowerCase();
                if (!q) {
                    closeSuggest();
                    return;
                }
                const matches = suggestionsList.filter(s => s.toLowerCase().includes(q)).slice(0, 12);
                if (!matches.length) {
                    closeSuggest();
                    return;
                }
                box.innerHTML = matches.map(m => `<div data-v="${m}">${m}</div>`).join("");
                openSuggest();
                box.querySelectorAll("div").forEach(div => {
                    div.addEventListener("click", () => {
                        input.value = div.getAttribute("data-v");
                        searchTerm = input.value.trim();
                        status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                        closeSuggest();
                        redraw(); // timeline-only
                    });
                });
            }

            input.addEventListener("input", () => {
                searchTerm = input.value.trim();
                status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                renderSuggest();
                redraw();
            });
            input.addEventListener("focus", renderSuggest);
            document.addEventListener("click", (e) => {
                if (!box.contains(e.target) && e.target !== input) closeSuggest();
            });

            clearBtn.addEventListener("click", () => {
                input.value = "";
                searchTerm = "";
                status.textContent = "";
                closeSuggest();
                redraw();
            });
        }

        /* ========= EVENT HOOKS ========= */
        async function initUI() {
            loadLighthouseRoomGuide().catch(err => console.warn("Room guide load failed", err));
            await loadLighthouseCache();
            document.getElementById("csvFileA").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "A");
            });
            document.getElementById("csvFileB").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "B");
            });

            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            const toggleAVBtn = document.getElementById("toggleHighlightAV");
            const lighthouseSyncBtn = document.getElementById("lighthouseSync");

            if (selectA) {
                selectA.addEventListener("change", async () => {
                    const option = selectA.options[selectA.selectedIndex];
                    selectA.title = option ? option.textContent : "";
                    const id = selectA.value;
                    if (!id) return;
                    const loaded = await loadReportFromHistory(id, "A");
                    if (!loaded) {
                        alert("Unable to load the selected report from history.");
                        selectA.value = "";
                        selectA.selectedIndex = 0;
                        const resetOption = selectA.options[selectA.selectedIndex];
                        selectA.title = resetOption ? resetOption.textContent : "";
                    }
                });
            }

            if (selectB) {
                selectB.addEventListener("change", async () => {
                    const option = selectB.options[selectB.selectedIndex];
                    selectB.title = option ? option.textContent : "";
                    const id = selectB.value;
                    if (!id) return;
                    const loaded = await loadReportFromHistory(id, "B");
                    if (!loaded) {
                        alert("Unable to load the selected report from history.");
                        selectB.value = "";
                        selectB.selectedIndex = 0;
                        const resetOption = selectB.options[selectB.selectedIndex];
                        selectB.title = resetOption ? resetOption.textContent : "";
                    }
                });
            }

            if (toggleAVBtn) {
                toggleAVBtn.classList.toggle("active", highlightAV);
                toggleAVBtn.addEventListener("click", () => {
                    highlightAV = !highlightAV;
                    toggleAVBtn.classList.toggle("active", highlightAV);
                    if (!highlightAV && (!lastSelectionMeta || lastSelectionMeta.type !== "daily")) {
                        clearAVPanel();
                    }
                    redraw();
                    if (viewMode === "week" && highlightAV) {
                        renderWeeklySummaryPanel(lastSelectionMeta && lastSelectionMeta.type === "weekly" ? lastSelectionMeta : null);
                    }
                });
            }

            if (lighthouseSyncBtn) {
                lighthouseSyncBtn.addEventListener("click", () => {
                    handleLighthouseSyncClick();
                });
            }

            await initializeReportHistory();

            // Segmented control
            document.querySelectorAll("#viewMode button").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll("#viewMode button").forEach(b => b.classList.remove("active"));
                    btn.classList.add("active");
                    viewMode = btn.dataset.mode;
                    syncDateUI(currentDate);
                    redraw();
                });
            });

            document.getElementById("prevDay").addEventListener("click", () => changeDay(viewMode === "day" ? -1 : -7));
            document.getElementById("nextDay").addEventListener("click", () => changeDay(viewMode === "day" ? +1 : +7));
            document.getElementById("jumpToday").addEventListener("click", () => {
                currentDate = new Date();
                syncDateUI(currentDate);
                redraw();
            });
            document.getElementById("toggleShowRooms").addEventListener("click", () => {
                showAllRooms = !showAllRooms;
                document.getElementById("toggleShowRooms").textContent = showAllRooms ? "Hide Unused Rooms" : "Show All Rooms";
                if (viewMode === "day") redraw(); // weekly ignores this
            });

            document.getElementById("calPrev").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() - 1);
                renderCalendar(d); // move focus month; selection unchanged
            });
            document.getElementById("calNext").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() + 1);
                renderCalendar(d);
            });

            // Tabs
            document.querySelectorAll(".tab-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
                    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
                    btn.classList.add("active");
                    document.getElementById(btn.dataset.tab).classList.add("active");
                    if (btn.dataset.tab === "timelineTab") redraw();
                    if (btn.dataset.tab === "changeTab" && reportA.length && reportB.length) generateChangeLog(reportA, reportB);
                    if (btn.dataset.tab === "forecastTab") renderForecast();
                });
            });

            // Search
            wireSearch();

            // initial
            syncDateUI(currentDate);
            google.charts.setOnLoadCallback(() => redraw());
        }
        window.addEventListener("resize", () => redraw());

        /* ========= BOOT ========= */
        initUI().catch(err => console.error("Failed to initialize UI", err));
    </script>






</body>

</html>