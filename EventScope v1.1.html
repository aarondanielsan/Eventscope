<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>EventScope</title>

    <!-- Google Charts -->
    <script src="https://www.gstatic.com/charts/loader.js"></script>

    <!-- PDF.js for in-browser PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
    <script>
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js";
        }
    </script>

    <!-- Dexie.js for IndexedDB management -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&amp;display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-navy: #0f1f3a;
            --panel: #1c2a55;
            --border: #394c7a;
            --text: #f5f5f5;
            --accent: #2196f3;
            --chart-bg: #ffffff;
            --prev: #dc2626;
            --new: #16a34a;
            --changed: #eab308;
            --tab: #0b1730;
            --tab-active: #173265;
            --muted: #cbd5e1;
            --today: #16a34a;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: var(--bg-navy);
            color: var(--text);
        }

        .container {
            margin: 0 auto;
            padding: 24px;
        }

        h1 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 0 0 12px 0;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 14px;
        }

        /* global controls (uploads) */
        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        label {
            font-size: .9rem;
            opacity: .9
        }

        input[type="file"] {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        input[type="file"]::-webkit-file-upload-button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: .8rem;
        }

        button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: .85rem;
            cursor: pointer;
            transition: .18s ease;
        }

        button:hover {
            filter: brightness(1.08)
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        .spacer {
            flex: 1
        }

        .group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap
        }

        .upload-stack {
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
        }

        .upload-stack label {
            margin-bottom: 2px;
        }

        .upload-stack input[type="file"],
        .upload-stack .report-select {
            width: min(280px, 100%);
        }

        .report-select {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        .report-select:focus {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }

        /* tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin: 12px 0;
        }

        .tab-btn {
            background: var(--tab);
            border: 1px solid var(--border);
            color: #cfe0ff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .tab-btn.active {
            background: var(--tab-active);
            color: #fff;
            border-color: #3e59a1;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* toolbar (calendar + bottom-anchored controls) */
        .toolbar {
            display: flex;
            gap: 20px;
            align-items: stretch;
            background: #182750;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
        }

        .calendar-shell {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px;
            width: 220px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .cal-nav button {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            cursor: pointer;
            font-weight: 700;
        }

        table.cal {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
            font-size: .8rem
        }

        .cal th {
            color: var(--muted);
            font-weight: 600;
            padding: 4px 0
        }

        .cal td {
            padding: 4px;
            border-radius: 6px;
            cursor: pointer
        }

        .cal td:hover {
            background: #2b3f75
        }

        .cal td.active {
            background: #2b3f75;
            outline: 1px solid #4b6bb5
        }

        .cal td.real-today {
            outline: 2px dashed var(--today)
        }

        .cal td.muted {
            color: #7f8ab1
        }

        .week-highlight td.in-week {
            background: #2a3f7c;
        }

        .week-highlight td.in-week.active {
            outline: 2px solid #4b6bb5
        }

        .right-tools {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .controls-bottom {
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-badge {
            display: grid;
            grid-template-columns: 34px minmax(220px, 1fr) 34px;
            align-items: center;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 6px 8px;
            min-width: 320px;
        }

        .nav-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            color: #fff;
            background: var(--accent);
        }

        .date-label {
            text-align: center;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 8px;
        }

        .segmented {
            display: inline-flex;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 3px;
        }

        .segmented button {
            background: transparent;
            border: none;
            color: #cfe0ff;
            padding: 6px 10px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
        }

        .segmented button.active {
            background: var(--accent);
            color: #fff;
        }

        .btn {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .85rem;
        }

        .btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        /* search card (timeline-only filter) */
        .search-card {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            position: relative;
        }

        .search-box input {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            font: inherit;
            min-width: 280px;
        }

        .suggestions {
            position: absolute;
            top: 110%;
            left: 0;
            right: 0;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 180px;
            overflow-y: auto;
            display: none;
            z-index: 20;
        }

        .suggestions div {
            padding: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .suggestions div:hover {
            background: #2b3f75;
        }

        .pill {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 4px 8px;
            font-size: .8rem;
            color: #cfe0ff;
        }

        /* timeline wrapper */
        #timeline-wrapper {
            background: var(--chart-bg);
            border-radius: 10px;
            padding: 10px;
            margin-top: 8px;
        }

        #timeline {
            width: 100%;
            height: 70vh;
            min-height: 400px;
        }

        #timeline text {
            font-weight: 400 !important;
        }

        .google-visualization-tooltip,
        .google-visualization-tooltip * {
            color: #000 !important;
            background: #fff !important;
            font-family: 'Poppins', sans-serif !important;
            font-size: 12px !important;
        }

        .google-visualization-tooltip {
            border: 1px solid #cfcfcf !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, .15) !important;
            border-radius: 6px !important;
        }

        /* Change Log (kept as your working version, pill colors preserved) */
        #changeLogNote {
            background: #eef6ff;
            color: #1e3a8a;
            padding: 6px 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-size: .9rem;
            font-weight: 500;
        }

        .company-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 14px 0 6px;
        }

        .event-header {
            font-size: 1rem;
            font-weight: 500;
            margin: 8px 0 4px 8px;
            color: #cbd5e1;
        }

        .change-card {
            background: #fff;
            color: #000;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 6px 0 6px 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .change-card h4 {
            margin: 0 0 6px;
            font-size: .95rem;
            color: #111;
        }

        .change-card ul {
            margin: 0;
            padding-left: 16px;
        }

        .change-card li {
            margin: 2px 0;
            font-size: .85rem;
        }

        .change-prev {
            color: var(--prev);
            font-weight: 600;
        }

        .change-new {
            color: var(--new);
            font-weight: 700;
        }

        /* Forecast styles (unchanged) */
        .forecast-card {
            background: #1c2a55;
            padding: 16px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #394c7a;
        }

        .forecast-card h3 {
            margin-top: 0;
            font-size: 1.2rem;
        }

        .company-group {
            margin-bottom: 14px;
            padding: 12px;
            border-radius: 8px;
            background: #223366;
        }

        .company-name {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .event-block {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 6px;
            background: #2a3c6e;
        }

        .event-title {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .space-pill {
            background: #394c7a;
            padding: 3px 8px;
            border-radius: 14px;
            font-size: .8rem;
            margin-right: 6px;
        }

        .happening .section {
            margin-top: 12px;
        }

        .happening strong {
            font-size: 1.05rem;
        }

        .happening .now strong {
            color: #22c55e;
        }

        .happening .next strong {
            color: #3b82f6;
        }

        .happening-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #394c7a;
        }

        .happening-row:last-child {
            border-bottom: none;
        }

        .happening-row span {
            font-size: .9rem;
        }

        .warning-box {
            margin-bottom: 12px;
            padding: 10px;
            border: 1px solid #facc15;
            border-radius: 6px;
            background: #2a2a1c;
            color: #facc15;
        }
    </style>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
</head>

<body>
    <div class="container">
        <h1>EventScope</h1>

        <!-- GLOBAL uploads -->
        <div class="card" id="globalUploads">
            <div class="controls">
                <div class="group upload-stack">
                    <label for="csvFileA">Newest Event Report PDF</label>
                    <input type="file" id="csvFileA" accept=".pdf">
                    <select id="reportHistoryA" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
                <div class="spacer"></div>
                <div class="group upload-stack">
                    <label for="csvFileB">Previous Event Report PDF</label>
                    <input type="file" id="csvFileB" accept=".pdf">
                    <select id="reportHistoryB" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="timelineTab">Timeline</button>
            <button class="tab-btn" data-tab="changeTab">Change Log</button>
            <button class="tab-btn" data-tab="forecastTab">Today’s Forecast</button>
        </div>

        <!-- TIMELINE TAB -->
        <div id="timelineTab" class="tab-content active">
            <div class="card">

                <!-- Toolbar (calendar + bottom-anchored controls) -->
                <div class="toolbar">
                    <!-- Calendar -->
                    <div class="calendar-shell week-highlight">
                        <div class="calendar-header">
                            <div id="calMonthLabel">September 2025</div>
                            <div class="cal-nav">
                                <button id="calPrev" aria-label="Prev Month">‹</button>
                                <button id="calNext" aria-label="Next Month">›</button>
                            </div>
                        </div>
                        <table class="cal" id="calTable">
                            <thead>
                                <tr>
                                    <th>Su</th>
                                    <th>Mo</th>
                                    <th>Tu</th>
                                    <th>We</th>
                                    <th>Th</th>
                                    <th>Fr</th>
                                    <th>Sa</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="7" data-d="31">31</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="1">1</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="2">2</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="3">3</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="4">4</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="5">5</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="6">6</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="7">7</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="8">8</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="9">9</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="10">10</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="11">11</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="12">12</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="13">13</td>
                                </tr>
                                <tr>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="14">14</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="15">15</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="16">16</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="17">17</td>
                                    <td class=" active real-today in-week" data-y="2025" data-m="8" data-d="18">18</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="19">19</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="20">20</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="21">21</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="22">22</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="23">23</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="24">24</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="25">25</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="26">26</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="27">27</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="28">28</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="29">29</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="30">30</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="1">1</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="2">2</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="3">3</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="4">4</td>
                                </tr>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="5">5</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="6">6</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="7">7</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="8">8</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="9">9</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="10">10</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="11">11</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Bottom-anchored tools -->

                </div>

                <!--Main Tools (Date, Toggle, Search, Show -->
                <div class="card" id="searchCard" style="margin-top:12px;">
                    <div class="search-card">

                        <div class="date-badge">
                            <button class="nav-btn" id="prevDay">‹</button>
                            <div class="date-label" id="dateLabel">Thu, Sep 18, 2025</div>
                            <button class="nav-btn" id="nextDay">›</button>
                        </div><button class="btn" id="jumpToday">Today</button>
                        <div class="segmented" id="viewMode">
                            <button data-mode="day" class="active">Daily</button>
                            <button data-mode="week" class="">Weekly</button>
                        </div>
                        <div class="search-box">
                            <input type="text" id="timelineSearch" placeholder="Search company or event…">
                            <div class="suggestions" id="searchSuggest" style="display: none;"></div>
                        </div>
                        <button class="secondary" id="clearSearch">Clear</button>
                        <span id="searchStatus" style="opacity:.7;font-size:.9rem;"></span>
                        <button class="btn secondary" id="toggleShowRooms">Show All Rooms</button>
                    </div>
                </div>

                <!-- Chart -->
                <div id="timeline-wrapper">
                    <div id="timeline">
                        <p style="color:#c00; margin:12px;">No events found for this date.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- CHANGE LOG TAB (unchanged logic & styles you approved) -->
        <div id="changeTab" class="tab-content">
            <div class="card">
                <h2>Change Log</h2>
                <div id="changeLogNote">Comparing overlapping dates: Previous Report ⇄ Newest Report</div>
                <div id="changeLog">
                    <p style="opacity:.8">Upload both reports to see changes.</p>
                </div>
            </div>
        </div>

        <!-- TODAY'S FORECAST TAB (unchanged) -->
        <div id="forecastTab" class="tab-content">
            <div class="card">
                <h2>Today’s Event Forecast</h2>
                <div id="forecast">
                    <p style="opacity:.8">Upload the newest report to view today’s schedule summary.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ========= LOAD CHARTS ========= */
        google.charts.load("current", {
            packages: ["timeline"]
        });

        /* ========= GLOBAL STATE ========= */
        let reportA = [],
            reportB = []; // A = newest, B = previous
        let allEvents = []; // base events (from newest report)
        let currentDate = new Date();
        let showAllRooms = false;
        let viewMode = "day"; // 'day' | 'week'
        let searchTerm = ""; // timeline-only filter
        let suggestionsList = []; // autosuggest values

        /* ========= REPORT HISTORY (IndexedDB) ========= */
        const REPORT_HISTORY_LIMIT = 10;
        const reportDB = window.Dexie ? new Dexie("eventscopeReports") : null;
        if (reportDB) {
            reportDB.version(1).stores({
                reports: "++id, uploadedAt"
            });
        }

        async function getStoredReports() {
            if (!reportDB) return [];
            try {
                return await reportDB.reports.orderBy("uploadedAt").reverse().limit(REPORT_HISTORY_LIMIT).toArray();
            } catch (err) {
                console.error("Unable to read stored reports", err);
                return [];
            }
        }

        function formatReportOption(entry) {
            const dt = new Date(entry.uploadedAt);
            const dateStr = dt.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
            const timeStr = dt.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" });
            return `${dateStr} ${timeStr} – ${entry.filename}`;
        }

        async function populateReportDropdowns() {
            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            if (!selectA || !selectB) return;
            await pruneExcessReports();
            const data = await getStoredReports();
            [selectA, selectB].forEach(sel => {
                const current = sel.value;
                sel.innerHTML = "<option value=\"\">Select a saved report…</option>";
                data.forEach(item => {
                    const opt = document.createElement("option");
                    opt.value = String(item.id);
                    opt.textContent = formatReportOption(item);
                    opt.dataset.filename = item.filename;
                    opt.dataset.timestamp = String(item.uploadedAt);
                    opt.dataset.date = item.uploadedDate || "";
                    sel.appendChild(opt);
                });
                if (current) {
                    sel.value = current;
                    if (sel.value !== current) {
                        sel.selectedIndex = 0;
                    }
                }
                const selectedOption = sel.options[sel.selectedIndex];
                sel.title = selectedOption ? selectedOption.textContent : "";
            });
        }

        async function pruneExcessReports() {
            if (!reportDB) return;
            try {
                const total = await reportDB.reports.count();
                if (total <= REPORT_HISTORY_LIMIT) return;
                const excess = await reportDB.reports.orderBy("uploadedAt").toArray();
                const toDelete = excess.slice(0, Math.max(0, excess.length - REPORT_HISTORY_LIMIT));
                if (toDelete.length) {
                    await reportDB.reports.bulkDelete(toDelete.map(entry => entry.id));
                }
            } catch (err) {
                console.error("Unable to prune stored reports", err);
            }
        }

        async function saveReportMetadata(file) {
            if (!reportDB || !file) return;
            try {
                const now = new Date();
                await reportDB.reports.add({
                    filename: file.name,
                    uploadedAt: now.getTime(),
                    uploadedDate: now.toISOString(),
                    fileTimestamp: file.lastModified || null
                });
                await pruneExcessReports();
                await populateReportDropdowns();
            } catch (err) {
                console.error("Unable to save report metadata", err);
            }
        }

        /* ========= PDF PARSING HEURISTICS ========= */
        const FUNCTION_TYPES = [
            "Meeting", "Breakout", "Breakfast", "Lunch", "Dinner", "Reception",
            "Cocktail Reception", "Board Meeting", "General Session", "Set Up",
            "Holding Room", "Dance", "Ceremony", "Brunch", "Box Lunch",
            "PM Break", "AM Break", "Coffee Break", "Continuous Break",
            "Hospitality Room", "24 Hour Hold", "Storage", "Office",
            "Registration", "Rehearsal", "Special", "Buffet", "Exhibits",
            "Continental Breakfast", "Teardown", "No Agenda Hold"
        ];

        const FUNCTION_SPACES_HINTS = [
            "Director's Room", "The Founders Room",
            "Legacy Ballroom", "Legacy Ballroom I", "Legacy Ballroom II",
            "Legacy I", "Legacy II", "Legacy Prefunction",
            "The Gallery", "Gallery", "Gallery I", "Gallery II",
            "Gallery Prefunction", "Gallery I Prefunction", "Gallery II Prefunction",
            "The Gallery Lounge",
            "Trade Root Restaurant", "Boardroom", "Envoy", "Diplomat", "Ambassador",
            "Plaza I", "Plaza II", "Plaza III", "Plaza II & III", "Plaza", "Plaza Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V",
            "Salon VI", "Salon VII", "Salon VIII",
            "Prefunction", "2nd Floor Prefunction", "Whitley Prefunction",
            "Consulate", "Delegate", "Attache", "Charge",
            "The Whitley Ballroom", "Whitley Ballroom"
        ];

        const SETUP_STYLES = [
            "Conference", "Rounds of 10", "Rounds of 8", "Rounds of 6",
            "Chevron Theatre", "Schoolroom", "U-Shape", "Hollow Square",
            "Cocktail Rounds", "Theatre", "Special",
            "Crescent Rounds", "Lounge", "Storage"
        ];

        const GROUPINGS = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
        };

        const ROMAN_ORDER = { I: 1, II: 2, III: 3, IV: 4, V: 5, VI: 6, VII: 7, VIII: 8 };

        const MEAL_BREAK_TYPES = new Set([
            "Breakfast", "Lunch", "Dinner", "AM Break", "PM Break",
            "Coffee Break", "Continuous Break", "Box Lunch", "Buffet", "Continental Breakfast"
        ]);

        const FALLBACK_TYPES = new Set([...MEAL_BREAK_TYPES, "Meeting", "Rehearsal", "Exhibits"]);

        const TIME_RANGE_RE = /(\d{1,2}:\d{2}\s?[AP]M)\s*[-–—]\s*(\d{1,2}:\d{2}\s?[AP]M)/i;
        const DATE_LINE_RE = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), .* \d{4}$/i;
        const COUNTS_RE = /^\d+\/\d+\/(?:\d+|__)$/;
        const POST_AS_RE = /Post As[:\-]?\s*(.+)/i;

        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function romanToInt(r) {
            return ROMAN_ORDER[r] ?? 999;
        }

        function splitRomanList(str) {
            const cleaned = str.replace(/\s*(?:&|and)\s*/gi, ",");
            return cleaned
                .split(",")
                .map(p => p.trim().toUpperCase())
                .filter(p => p && /^[IVX]+$/.test(p));
        }

        function expandCompoundPrefix(lineText) {
            const found = new Set();
            const checks = [
                { prefix: "Salon", regex: /\bSalon\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Plaza", regex: /\bPlaza\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Legacy", regex: /\bLegacy\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
            ];
            checks.forEach(({ prefix, regex }) => {
                let match;
                while ((match = regex.exec(lineText))) {
                    splitRomanList(match[1]).forEach(r => found.add(`${prefix} ${r}`));
                }
            });
            return Array.from(found);
        }

        function expandGroupedSpace(lineText, primary) {
            const compound = new Set(expandCompoundPrefix(lineText));

            Object.entries(GROUPINGS).forEach(([ballroom, subs]) => {
                subs.forEach(sub => {
                    const re = new RegExp(`\\b${escapeRegExp(sub)}\\b`);
                    if (re.test(lineText)) compound.add(sub);
                });
            });

            if (/\bAttache\b/i.test(lineText) && /\bCharge\b/i.test(lineText)) {
                return "Attache Charge";
            }

            if (!compound.size) {
                return primary ? primary.trim() : primary;
            }

            const whitley = Array.from(compound).filter(s => s.startsWith("Salon "));
            const plaza = Array.from(compound).filter(s => s.startsWith("Plaza "));
            const legacy = Array.from(compound).filter(s => s.startsWith("Legacy "));

            if (whitley.length) {
                const romans = Array.from(new Set(whitley.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Whitley Ballroom (${romans.map(r => `Salon ${r}`).join(", ")})`;
            }
            if (plaza.length) {
                const romans = Array.from(new Set(plaza.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Plaza Ballroom (${romans.map(r => `Plaza ${r}`).join(", ")})`;
            }
            if (legacy.length) {
                const romans = Array.from(new Set(legacy.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Legacy Ballroom (${romans.map(r => `Legacy ${r}`).join(", ")})`;
            }

            return primary ? primary.trim() : primary;
        }

        function detectFunctionType(text) {
            if (/\bContinental\b/i.test(text)) return "Continental Breakfast";
            const sorted = [...FUNCTION_TYPES].sort((a, b) => b.length - a.length);
            for (const f of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(f)}\\b`, "i");
                if (re.test(text)) return f;
            }
            return null;
        }

        function detectSetupStyle(text) {
            const sorted = [...SETUP_STYLES].sort((a, b) => b.length - a.length);
            for (const s of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(s)}\\b`, "i");
                if (re.test(text)) return s;
            }
            return null;
        }

        function detectSpace(text) {
            for (const hint of FUNCTION_SPACES_HINTS) {
                const re = new RegExp(`\\b${escapeRegExp(hint)}\\b`);
                if (re.test(text)) return hint;
            }
            return null;
        }

        function cleanTimeString(raw) {
            if (!raw) return "";
            const match = raw.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
            if (!match) return raw.trim();
            const hour = String(Number(match[1]));
            const minute = match[2];
            const mod = match[3].toUpperCase();
            return `${hour}:${minute} ${mod}`;
        }

        /* ========= ROOM ORDERING ========= */
        const ROOM_ORDER = [
            "Whitley Ballroom", "Whitley Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII",
            "Plaza Ballroom", "Plaza Prefunction", "Plaza I", "Plaza II", "Plaza III",
            "Gallery", "Gallery Prefunction", "Gallery I", "Gallery II",
            "Legacy Ballroom", "Legacy Prefunction", "Legacy I", "Legacy II",
            "Ambassador", "Attache", "Attache Charge", "Boardroom", "Charge", "Consulate",
            "Delegate", "Diplomat", "Director's Room", "Envoy", "The Founders Room"
        ];
        const SUBORDER = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
            "Gallery": ["Gallery I", "Gallery II"]
        };
        const PARENT_MAP = {};
        Object.entries(SUBORDER).forEach(([p, subs]) => subs.forEach(s => PARENT_MAP[s] = p));

        /* ========= UTILS ========= */
        function parseDayOfEvent(str) {
            if (!str) return null;
            let d = new Date(str);
            if (isNaN(d)) d = new Date(String(str).replace(/^[A-Za-z]+,\s*/, ""));
            return isNaN(d) ? null : d;
        }

        function parseTime(str) {
            if (!str) return [0, 0];
            const parts = String(str).trim().split(" ");
            const timePart = parts[0] || "0:00";
            const mod = (parts[1] || "").toUpperCase();
            const hhmm = timePart.split(":");
            let h = Number(hhmm[0] || 0),
                m = Number(hhmm[1] || 0);
            if (mod === "PM" && h < 12) h += 12;
            if (mod === "AM" && h === 12) h = 0;
            return [h, m];
        }

        function toLocalISODate(d) {
            return d.getFullYear() + "-" + String(d.getMonth() + 1).padStart(2, "0") + "-" + String(d.getDate()).padStart(2, "0");
        }

        function sameDay(a, b) {
            return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
        }

        function formatAMPM(d) {
            let h = d.getHours(),
                m = d.getMinutes(),
                ampm = h >= 12 ? "PM" : "AM";
            h = h % 12;
            h = h ? h : 12;
            m = m < 10 ? "0" + m : m;
            return `${h}:${m} ${ampm}`;
        }

        function monthLabel(d) {
            return d.toLocaleString("en-US", {
                month: "long",
                year: "numeric"
            });
        }

        function weekStart(d) {
            const x = new Date(d);
            const day = x.getDay();
            x.setDate(x.getDate() - day);
            x.setHours(0, 0, 0, 0);
            return x;
        } // Sunday 00:00
        function weekEnd(d) {
            const ws = weekStart(d);
            const we = new Date(ws);
            we.setDate(ws.getDate() + 6);
            we.setHours(23, 59, 59, 999);
            return we;
        }

        function shortTick(d) {
            return d.toLocaleDateString("en-US", {
                weekday: "short",
                month: "numeric",
                day: "numeric"
            });
        }

        function condenseSubs(list) {
            if (!list.length) return "";
            const m = list[0].match(/^([A-Za-z]+(?:\s[A-Za-z]+)?)\s+/);
            let prefix = m ? m[1] + " " : "";
            if (prefix && !list.every(x => x.startsWith(prefix))) prefix = "";
            if (!prefix) return list.join(", ");
            const rest = list.map(x => x.slice(prefix.length)).join(", ");
            return prefix + rest;
        }

        function normalizeRooms(raw) {
            if (!raw) return [];
            let s = String(raw).trim();
            if (s === "The Whitley Ballroom") s = "Whitley Ballroom";
            if (s === "The Gallery") s = "Gallery";
            if (s === "Plaza") s = "Plaza Ballroom";
            if (s === "Founder's Room" || s === "Founders Room") s = "The Founders Room";
            if (s === "Legacy Ballroom I") s = "Legacy I";
            if (s === "Legacy Ballroom II") s = "Legacy II";
            if (s.toLowerCase() === "attache charge") return ["Attache Charge"];
            if (s === "Prefunction") return ["Whitley Prefunction"];
            if (s.includes("(") && s.includes(")")) {
                const inner = s.slice(s.indexOf("(") + 1, s.lastIndexOf(")")).trim();
                if (inner) return inner.split(",").map(x => x.trim());
            }
            if (s.includes(",")) return s.split(",").map(p => p.trim());
            return [s];
        }

        function groupRoomsToLabels(rooms) {
            const byBase = new Map();
            rooms.forEach(r => {
                const base = PARENT_MAP[r] || r;
                const isSub = !!PARENT_MAP[r];
                if (!byBase.has(base)) byBase.set(base, {
                    base,
                    subs: new Set()
                });
                if (isSub) byBase.get(base).subs.add(r);
            });
            const out = [];
            for (const {
                    base,
                    subs
                }
                of byBase.values()) {
                if (subs.size > 0) {
                    const all = SUBORDER[base] || [];
                    if (subs.size === all.length) {
                        out.push({
                            label: base,
                            base
                        });
                    } else {
                        let list = Array.from(subs);
                        if (all.length) list.sort((a, b) => all.indexOf(a) - all.indexOf(b));
                        const condensed = condenseSubs(list);
                        out.push({
                            label: `${base} (${condensed})`,
                            base
                        });
                    }
                } else out.push({
                    label: base,
                    base
                });
            }
            return out;
        }
        // Convert "YYYY-MM-DD" into a Date at LOCAL midnight
        function fromISODateLocal(iso) {
            const [y, m, d] = iso.split("-").map(Number);
            return new Date(y, m - 1, d, 0, 0, 0, 0);
        }

        /* ======== SEARCH FILTER (timeline-only) ======== */
        function buildSuggestions() {
            const names = new Set();
            (reportA || []).forEach(r => {
                if (r["Company Name"]) names.add(r["Company Name"].trim());
                if (r["Event Name"]) names.add(r["Event Name"].trim());
            });
            suggestionsList = Array.from(names).sort((a, b) => a.localeCompare(b));
        }

        function applySearchFilter(rows) {
            if (!searchTerm) return rows;
            const q = searchTerm.toLowerCase();
            // Filter by company OR event name
            return rows.filter(ev => {
                const c = (ev["Company Name"] || "").toLowerCase();
                const e = (ev["Event Name"] || "").toLowerCase();
                return c.includes(q) || e.includes(q);
            });
        }

        /* ========= TOOLTIP FOR DAILY ========= */
        function groupTooltip(room, items, status) {
            items.sort((a, b) => a.start - b.start);
            let html = `<div style="padding:6px;">`;
            if (items[0]?.event) html += `<div style="font-weight:700; margin-bottom:4px;">${items[0].event}</div>`;
            if (status) html += `<div style="margin-bottom:6px"><span style="padding:2px 6px;border-radius:6px;background:#eef;border:1px solid #ccd">${status}</span></div>`;
            html += `<div style="font-weight:600; margin-bottom:4px;">${room}</div>`;
            items.forEach(e => {
                const time = `${formatAMPM(e.start)} – ${formatAMPM(e.end)}`;
                html += `<div><b>${e.function||""}</b> · ${time} · ${e.setup||""}</div>`;
            });
            html += `</div>`;
            return html;
        }

        /* ========= TIMELINE DRAWERS ========= */
        function drawDaily(selectedDateISO) {
            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Room"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(selectedDateISO + "T00:00:00");
            currentDate = chosen;

            const groups = {};
            let dataMin = null,
                dataMax = null;

            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const status = (ev["Event Status"] || "").toString().trim();
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const rooms = normalizeRooms(ev["Function Space"]);
                const company = ev["Company Name"] || "";
                const eventName = ev["Event Name"] || "";
                const labels = groupRoomsToLabels(rooms);

                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        if (sameDay(d, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: start,
                                max: midnight
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start,
                                end: midnight
                            });
                            if (start < groups[key].min) groups[key].min = start;
                            if (midnight > groups[key].max) groups[key].max = midnight;
                            if (!dataMin || start < dataMin) dataMin = start;
                            if (!dataMax || midnight > dataMax) dataMax = midnight;
                        }
                        if (sameDay(nextDay, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + nextDay.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: nextDay,
                                max: endNext
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start: nextDay,
                                end: endNext
                            });
                            if (nextDay < groups[key].min) groups[key].min = nextDay;
                            if (endNext > groups[key].max) groups[key].max = endNext;
                            if (!dataMin || nextDay < dataMin) dataMin = nextDay;
                            if (!dataMax || endNext > dataMax) dataMax = endNext;
                        }
                    });
                    return;
                }

                if (sameDay(d, chosen)) {
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                        if (!groups[key]) groups[key] = {
                            roomLabel: label,
                            base,
                            company,
                            status,
                            items: [],
                            min: start,
                            max: end
                        };
                        groups[key].items.push({
                            event: eventName,
                            function: ev["Function Type"],
                            setup: ev["Setup Style"],
                            start,
                            end
                        });
                        if (start < groups[key].min) groups[key].min = start;
                        if (end > groups[key].max) groups[key].max = end;
                    });
                    if (!dataMin || start < dataMin) dataMin = start;
                    if (!dataMax || end > dataMax) dataMax = end;
                }
            });

            const rows = [];
            const usedBases = new Set();
            ROOM_ORDER.forEach(roomBase => {
                Object.values(groups).forEach(g => {
                    if (g.base === roomBase && sameDay(g.min, chosen)) {
                        usedBases.add(roomBase);
                        rows.push([g.roomLabel, g.company || g.items[0]?.event || "", groupTooltip(g.roomLabel, g.items, g.status), "", g.min, g.max]);
                    }
                });
                if (showAllRooms && !usedBases.has(roomBase)) {
                    const base = dataMin || new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 8, 0);
                    rows.push([roomBase, "", "", "color:#E5E7EB;", base, new Date(base.getTime() + 60000)]);
                }
            });
            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No events found for this date.</p>";
                return;
            }

            dt.addRows(rows);

            // full-day window
            const startHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 0, 0, 0, 0);
            const endHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 23, 59, 59, 999);
            const ticks = [];
            let t = new Date(startHour);
            while (t <= endHour) {
                ticks.push(new Date(t));
                t.setHours(t.getHours() + 1);
            }

            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "h a",
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: startHour,
                        max: endHour
                    }
                },
                timeline: {
                    showBarLabels: true,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });
        }

        /* Weekly: Sun→Sat columns always visible; per company, add day segments (filled when present) */
        function drawWeekly(anyDateISO) {
            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Company"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(anyDateISO + "T00:00:00");
            currentDate = chosen;
            const ws = weekStart(chosen); // Sun 00:00
            const we = weekEnd(chosen); // Sat 23:59:59.999

            // Per-company occupancy by day (from filtered events)
            const perCompany = new Map(); // company -> Map(dayISO -> Set(rooms))
            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const company = ev["Company Name"] || "";
                const rooms = normalizeRooms(ev["Function Space"]);

                const spans = [];
                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    spans.push({
                        s: start,
                        e: midnight
                    });
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    spans.push({
                        s: new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), 0, 0, 0, 0),
                        e: endNext
                    });
                } else {
                    spans.push({
                        s: start,
                        e: end
                    });
                }

                spans.forEach(({
                    s,
                    e
                }) => {
                    // iterate each day from s..e; collect rooms for any day that intersects week
                    let cursor = new Date(s);
                    while (cursor <= e) {
                        const dayStart = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 0, 0, 0, 0);
                        const dayEnd = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 23, 59, 59, 999);
                        if (dayEnd >= ws && dayStart <= we) {
                            if (!perCompany.has(company)) perCompany.set(company, new Map());
                            const dayIso = toLocalISODate(dayStart);
                            if (!perCompany.get(company).has(dayIso)) perCompany.get(company).set(dayIso, new Set());
                            rooms.forEach(r => perCompany.get(company).get(dayIso).add(r));
                        }
                        cursor.setDate(cursor.getDate() + 1);
                        cursor.setHours(0, 0, 0, 0);
                    }
                });
            });

            // Compute overall in-house span per company
            const companySpans = new Map();
            for (const [company, days] of perCompany.entries()) {
                const allDates = Array.from(days.keys()).map(d => fromISODateLocal(d));
                if (allDates.length) {
                    allDates.sort((a, b) => a - b); // earliest to latest
                    companySpans.set(company, {
                        start: allDates[0],
                        end: allDates[allDates.length - 1]
                    });
                }
            }

            // Rows: each company gets 7 day segments (Sun..Sat), filled if they have rooms
            const rows = [];
            const companies = Array.from(perCompany.keys()).sort((a, b) => a.localeCompare(b));
            companies.forEach(company => {
                for (let i = 0; i < 7; i++) {
                    const d = new Date(ws);
                    d.setDate(ws.getDate() + i);
                    const dayIso = toLocalISODate(d);
                    const has = perCompany.get(company).has(dayIso) && perCompany.get(company).get(dayIso).size > 0;
                    const roomsList = has ? Array.from(perCompany.get(company).get(dayIso)).sort() : [];
                    const segStart = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
                    const segEnd = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);
                    const style = has ? "" : "color:#E5E7EB;";

                    const weekRange = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
                    const span = companySpans.get(company);
                    const spanText = span ?
                        `${span.start.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${span.end.toLocaleDateString("en-US",{month:"short",day:"numeric"})}` :
                        "";

                    const tip = `
  <div style="padding:6px;max-width:260px;">
    <div style="font-weight:700;margin-bottom:4px;">${company}</div>
    <div><b>${d.toLocaleDateString("en-US",{weekday:"short", month:"short", day:"numeric"})}</b></div>
    <div style="margin:6px 0;"><i>In-house:</i> ${spanText}</div>
    <div><b>Rooms:</b> ${roomsList.join(", ")}</div>
  </div>
`.trim();


                    rows.push([company, "", tip, style, segStart, segEnd]);
                }
            });

            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No companies intersect this week.</p>";
                return;
            }
            dt.addRows(rows);

            // Axis ticks: always Sun..Sat, labels like "Sun 9/21"
            const ticks = [];
            for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                d.setHours(0, 0, 0, 0); // midnight, not noon
                ticks.push(d);
            }


            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "EEE M/d", // <-- fixed: use pattern, not function
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: new Date(ws),
                        max: new Date(we)
                    }
                },
                timeline: {
                    showBarLabels: false,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });
        }

        /* ========= CHANGE LOG =========
           (Kept as your working logic from last version.
            Only re-rendered when both reports present and Change Log tab is opened.) */
        function generateChangeLog(reportA, reportB) {
            const container = document.getElementById("changeLog");
            container.innerHTML = "";

            if (!reportA.length || !reportB.length) {
                container.innerHTML = "<p style='opacity:.8'>Upload both reports to see changes.</p>";
                return;
            }

            // Company + Event + Date + Room + Function Type + Post As
            const makeKey = ev => [
                ev["Company Name"], ev["Event Name"], ev["Day of Event"],
                ev["Function Space"], ev["Function Type"], ev["Post As"] || ""
            ].join("||");

            const mapB = new Map();
            reportB.forEach(ev => mapB.set(makeKey(ev), ev));

            const companyGroups = {};
            reportA.forEach(ev => {
                const key = makeKey(ev);
                const old = mapB.get(key);
                if (!old) return; // only overlapping entries

                const diffs = [];
                ["Start Time", "End Time", "Setup Style", "Event Status"].forEach(field => {
                    if ((ev[field] || "").trim() !== (old[field] || "").trim()) {
                        diffs.push({
                            field,
                            prev: old[field] || "",
                            newest: ev[field] || ""
                        });
                    }
                });

                if (diffs.length) {
                    const company = ev["Company Name"] || "";
                    const event = ev["Event Name"] || "";
                    const space = ev["Function Space"] || "";
                    const ftype = ev["Function Type"] || "";
                    const pas = ev["Post As"] || "";
                    if (!companyGroups[company]) companyGroups[company] = {};
                    if (!companyGroups[company][event]) companyGroups[company][event] = [];
                    companyGroups[company][event].push({
                        space,
                        ftype,
                        pas,
                        diffs,
                        date: ev["Day of Event"]
                    });
                }
            });

            if (Object.keys(companyGroups).length === 0) {
                container.innerHTML = "<p style='opacity:.7'>✅ No changes detected between the reports.</p>";
                return;
            }

            for (const company of Object.keys(companyGroups)) {
                const compHeader = document.createElement("div");
                compHeader.className = "company-header";
                compHeader.textContent = company;
                container.appendChild(compHeader);

                for (const event of Object.keys(companyGroups[company])) {
                    const evHeader = document.createElement("div");
                    evHeader.className = "event-header";
                    evHeader.textContent = event;
                    container.appendChild(evHeader);

                    companyGroups[company][event].forEach(change => {
                        const card = document.createElement("div");
                        card.className = "change-card";
                        card.innerHTML = `
            <h4>${change.space} — ${change.ftype} ${change.pas?("· "+change.pas):""}</h4>
            <div style="font-size:.8rem;color:#555;margin-bottom:4px;">${change.date}</div>
            <ul>
              ${change.diffs.map(d=>
                `<li>${d.field}:
                  <span class="change-prev">${d.prev}</span> →
                  <span class="change-new">${d.newest}</span>
                </li>`).join("")}
            </ul>`;
                        container.appendChild(card);
                    });
                }
            }
        }


        /* ========= FORECAST (unchanged) ========= */
        function renderForecast() {
            const host = document.getElementById("forecast");
            host.innerHTML = "";

            if (!reportA.length) {
                host.innerHTML = "<p style='opacity:.8'>Upload the newest report to view today’s schedule summary.</p>";
                return;
            }

            const now = new Date();
            const todayISO = toLocalISODate(now);

            const todays = reportA.filter(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                return d && toLocalISODate(d) === todayISO;
            });

            if (!todays.length) {
                host.innerHTML = "<p style='opacity:.8'>No events scheduled for today.</p>";
                return;
            }

            const entries = todays.map(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                return {
                    company: ev["Company Name"] || "",
                    event: ev["Event Name"] || "",
                    space: ev["Function Space"] || "",
                    start: new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm),
                    end: new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em),
                };
            });

            const merged = (() => {
                const map = new Map();
                entries.forEach(e => {
                    const key = `${e.company}||${e.space}`;
                    if (!map.has(key)) {
                        map.set(key, {
                            company: e.company,
                            space: e.space,
                            start: new Date(e.start),
                            end: new Date(e.end),
                            events: [e.event]
                        });
                    } else {
                        const g = map.get(key);
                        if (e.start < g.start) g.start = new Date(e.start);
                        if (e.end > g.end) g.end = new Date(e.end);
                        g.events.push(e.event);
                    }
                });
                return Array.from(map.values()).sort((a, b) => a.start - b.start);
            })();

            const companyGroups = {};
            entries.forEach(ev => {
                if (!companyGroups[ev.company]) companyGroups[ev.company] = {};
                if (!companyGroups[ev.company][ev.event]) companyGroups[ev.company][ev.event] = new Set();
                companyGroups[ev.company][ev.event].add(ev.space);
            });

            const compCard = document.createElement("div");
            compCard.className = "forecast-card";
            compCard.innerHTML = "<h3>Companies & Function Spaces</h3>";
            for (const [company, events] of Object.entries(companyGroups)) {
                const group = document.createElement("div");
                group.className = "company-group";
                group.innerHTML = `<div class="company-name">${company}</div>`;
                for (const [event, spaces] of Object.entries(events)) {
                    const evBlock = document.createElement("div");
                    evBlock.className = "event-block";
                    evBlock.innerHTML = `<div class="event-title">${event}</div><div>${Array.from(spaces).map(s=>`<span class="space-pill">${s}</span>`).join("")}</div>`;
                    group.appendChild(evBlock);
                }
                compCard.appendChild(group);
            }
            host.appendChild(compCard);

            const nowList = merged.filter(e => now >= e.start && now < e.end);
            const nextList = merged.filter(e => e.start > now);

            const happeningCard = document.createElement("div");
            happeningCard.className = "forecast-card happening";
            happeningCard.innerHTML = "<h3>What's Happening</h3>";

            const renderSection = (title, list, cls) => {
                const sec = document.createElement("div");
                sec.className = `section ${cls}`;
                sec.innerHTML = `<strong>${title}</strong>`;
                if (!list.length) {
                    sec.innerHTML += `<p style='opacity:.7;font-size:.85rem'>No events</p>`;
                } else {
                    list.forEach(e => {
                        const row = document.createElement("div");
                        row.className = "happening-row";
                        row.innerHTML = `<span><b>${e.company}</b> — ${e.space}</span><span>${formatAMPM(e.start)} – ${formatAMPM(e.end)}</span>`;
                        sec.appendChild(row);
                    });
                }
                happeningCard.appendChild(sec);
            };

            renderSection("Now", nowList, "now");
            renderSection("Next", nextList, "next");
            host.appendChild(happeningCard);

            const byRoom = {};
            entries.forEach(e => {
                (byRoom[e.space] ||= []).push(e);
            });
            const flips = [];
            Object.values(byRoom).forEach(list => {
                list.sort((a, b) => a.start - b.start);
                for (let i = 1; i < list.length; i++) {
                    const prev = list[i - 1],
                        curr = list[i];
                    const gap = (curr.start - prev.end) / 60000;
                    if (gap >= 0 && gap <= 30 && prev.company !== curr.company) {
                        flips.push({
                            room: curr.space,
                            prev,
                            curr,
                            gap
                        });
                    }
                }
            });
            if (flips.length) {
                const warn = document.createElement("div");
                warn.className = "warning-box";
                warn.innerHTML = "<h3 style='margin:0 0 8px 0;color:#facc15;'>Warnings: Quick Room Flips</h3>";
                flips.forEach(f => {
                    const box = document.createElement("div");
                    box.innerHTML = `<strong>${f.room}</strong> ${f.prev.company} (${formatAMPM(f.prev.start)} – ${formatAMPM(f.prev.end)}) → ${f.curr.company} (${formatAMPM(f.curr.start)} – ${formatAMPM(f.curr.end)})`;
                    warn.appendChild(box);
                });
                host.appendChild(warn);
            }
        }

        /* ========= PDF UPLOAD ========= */
        async function extractPdfLines(file) {
            if (!window.pdfjsLib) {
                throw new Error("PDF.js library is not available");
            }
            const data = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data }).promise;
            const lines = [];

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();
                const items = textContent.items
                    .map(item => ({
                        text: (item.str || "").trim(),
                        x: item.transform?.[4] ?? 0,
                        y: item.transform?.[5] ?? 0
                    }))
                    .filter(item => item.text);

                items.sort((a, b) => {
                    const yDiff = Math.abs(b.y - a.y);
                    if (yDiff > 2) {
                        return b.y - a.y; // top to bottom
                    }
                    return a.x - b.x; // left to right
                });

                let currentY = null;
                let parts = [];
                items.forEach(item => {
                    if (currentY === null || Math.abs(item.y - currentY) <= 2) {
                        parts.push(item.text);
                        currentY = item.y;
                    } else {
                        const normalized = parts.join(' ').replace(/\s+/g, ' ').trim();
                        if (normalized) lines.push(normalized);
                        parts = [item.text];
                        currentY = item.y;
                    }
                });
                if (parts.length) {
                    const normalized = parts.join(' ').replace(/\s+/g, ' ').trim();
                    if (normalized) lines.push(normalized);
                }
            }

            return lines;
        }

        async function loadPDF(file, target) {
            const lines = await extractPdfLines(file);
            const rows = [];

            let currentCompany = null;
            let currentEvent = null;
            let currentDateStr = null;
            let currentStatus = null;
            let inEventHeader = false;
            let inEventBody = false;
            const lastSpaceByEvent = new Map();

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) {
                    continue;
                }

                if (line.includes("Quote #:")) {
                    currentCompany = line.split("Quote #:")[0].trim();
                    inEventHeader = true;
                    inEventBody = false;
                    continue;
                }

                if (line.includes("Status:")) {
                    const statusMatch = line.match(/Status:\s*(\w+)/i);
                    if (statusMatch) {
                        currentStatus = statusMatch[1].trim();
                    }
                    continue;
                }

                if (line.includes("Folio #:")) {
                    const evMatch = line.match(/(.+?)\s+Folio #:/);
                    if (evMatch) {
                        currentEvent = evMatch[1].trim();
                        inEventHeader = true;
                        inEventBody = false;
                    }
                    continue;
                }

                if (DATE_LINE_RE.test(line)) {
                    currentDateStr = line.trim();
                    continue;
                }

                const postMatch = line.match(POST_AS_RE);
                if (postMatch && rows.length && inEventBody) {
                    const last = rows[rows.length - 1];
                    if (last["Function Space"] && !last["Post As"]) {
                        last["Post As"] = postMatch[1].trim();
                    }
                    continue;
                }
                if (postMatch && inEventHeader) {
                    continue;
                }

                const timeMatch = line.match(TIME_RANGE_RE);
                if (!timeMatch) {
                    continue;
                }

                inEventHeader = false;
                inEventBody = true;

                const startTime = cleanTimeString(timeMatch[1]);
                const endTime = cleanTimeString(timeMatch[2]);
                const functionType = detectFunctionType(line);
                const setupStyle = detectSetupStyle(line);
                let functionSpace = detectSpace(line);
                functionSpace = expandGroupedSpace(line, functionSpace);

                if (functionSpace && COUNTS_RE.test(functionSpace.trim())) {
                    functionSpace = null;
                }

                const eventKey = `${currentCompany || ""}||${currentEvent || ""}`;
                if (!functionSpace && functionType && FALLBACK_TYPES.has(functionType)) {
                    const lastSpace = lastSpaceByEvent.get(eventKey);
                    if (lastSpace) {
                        functionSpace = lastSpace;
                    }
                }

                if (!functionSpace) {
                    continue;
                }

                lastSpaceByEvent.set(eventKey, functionSpace);

                rows.push({
                    "Company Name": currentCompany || "",
                    "Event Name": currentEvent || "",
                    "Event Status": currentStatus || "",
                    "Day of Event": currentDateStr || "",
                    "Start Time": startTime,
                    "End Time": endTime,
                    "Function Type": functionType || "",
                    "Function Space": functionSpace || "",
                    "Setup Style": setupStyle || "",
                    "Post As": "",
                    "Raw Line": line
                });
            }

            ingestRows(target, rows);
            return rows;
        }

        function ingestRows(target, rows) {
            const filtered = rows.filter(r => r && r["Day of Event"]);
            if (target === "A") {
                reportA = filtered;
                allEvents = filtered;
                buildSuggestions();
                redraw();
                renderForecast();
            } else {
                reportB = filtered;
            }
            if (reportA.length && reportB.length) {
                generateChangeLog(reportA, reportB);
            }
        }

        async function processPdfUpload(file, target) {
            if (!file) return;
            try {
                await saveReportMetadata(file);
                const rows = await loadPDF(file, target);
                if (!rows.length) {
                    alert(`No events were recognized in ${file.name}.`);
                }
            } catch (err) {
                console.error(err);
                alert(`Unable to parse ${file.name}: ${err?.message || err}`);
            }
        }

        /* ========= DATE / VIEW CONTROLS ========= */
        function syncDateLabel() {
            const label = document.getElementById("dateLabel");
            if (viewMode === "day") {
                label.textContent = currentDate.toLocaleDateString("en-US", {
                    weekday: "short",
                    month: "short",
                    day: "numeric",
                    year: "numeric"
                });
            } else {
                const ws = weekStart(currentDate),
                    we = weekEnd(currentDate);
                label.textContent = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
            }
        }

        function redraw() {
            if (!google?.charts) return;
            if (viewMode === "day") drawDaily(toLocalISODate(currentDate));
            else drawWeekly(toLocalISODate(currentDate));
        }

        function changeDay(offset) {
            const nd = new Date(currentDate);
            nd.setDate(currentDate.getDate() + offset);
            currentDate = nd;
            syncDateUI(currentDate);
            redraw();
        }

        /* ========= CALENDAR ========= */
        const calTable = document.getElementById("calTable");
        const calMonthLabel = document.getElementById("calMonthLabel");

        function renderCalendar(focusDate) {
            const year = focusDate.getFullYear(),
                month = focusDate.getMonth();
            calMonthLabel.textContent = monthLabel(focusDate);
            const first = new Date(year, month, 1);
            const startDay = first.getDay(); // Sun=0
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const prevMonthDays = new Date(year, month, 0).getDate();
            const cells = [];

            for (let i = 0; i < startDay; i++) {
                cells.push({
                    d: new Date(year, month - 1, prevMonthDays - startDay + 1 + i),
                    muted: true
                });
            }
            for (let d = 1; d <= daysInMonth; d++) {
                cells.push({
                    d: new Date(year, month, d),
                    muted: false
                });
            }
            while (cells.length < 42) {
                const nextDay = cells.length - (startDay + daysInMonth) + 1;
                cells.push({
                    d: new Date(year, month + 1, nextDay),
                    muted: true
                });
            }

            const ws = weekStart(currentDate),
                we = weekEnd(currentDate);

            let html = "<thead><tr>" + ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map(d => `<th>${d}</th>`).join("") + "</tr></thead><tbody>";
            for (let r = 0; r < 6; r++) {
                html += "<tr>";
                for (let c = 0; c < 7; c++) {
                    const idx = r * 7 + c,
                        cell = cells[idx];
                    const isActive = cell.d.toDateString() === currentDate.toDateString();
                    const isRealToday = (new Date()).toDateString() === cell.d.toDateString();
                    const inWeek = cell.d >= ws && cell.d <= we;
                    html += `<td class="${cell.muted?"muted":""} ${isActive?"active":""} ${isRealToday?"real-today":""} ${inWeek?"in-week":""}"
        data-y="${cell.d.getFullYear()}" data-m="${cell.d.getMonth()}" data-d="${cell.d.getDate()}">${cell.d.getDate()}</td>`;
                }
                html += "</tr>";
            }
            html += "</tbody>";
            calTable.innerHTML = html;
            calTable.parentElement.classList.add("week-highlight");

            calTable.querySelectorAll("td").forEach(td => {
                td.addEventListener("click", () => {
                    const y = +td.getAttribute("data-y"),
                        m = +td.getAttribute("data-m"),
                        d = +td.getAttribute("data-d");
                    currentDate = new Date(y, m, d);
                    syncDateUI(currentDate);
                    redraw();
                });
            });
        }

        function syncDateUI(d) {
            renderCalendar(d);
            syncDateLabel();
        }

        /* ========= SEARCH UI (autosuggest) ========= */
        function wireSearch() {
            const input = document.getElementById("timelineSearch");
            const box = document.getElementById("searchSuggest");
            const status = document.getElementById("searchStatus");
            const clearBtn = document.getElementById("clearSearch");

            function closeSuggest() {
                box.style.display = "none";
            }

            function openSuggest() {
                box.style.display = "block";
            }

            function renderSuggest() {
                const q = (input.value || "").trim().toLowerCase();
                if (!q) {
                    closeSuggest();
                    return;
                }
                const matches = suggestionsList.filter(s => s.toLowerCase().includes(q)).slice(0, 12);
                if (!matches.length) {
                    closeSuggest();
                    return;
                }
                box.innerHTML = matches.map(m => `<div data-v="${m}">${m}</div>`).join("");
                openSuggest();
                box.querySelectorAll("div").forEach(div => {
                    div.addEventListener("click", () => {
                        input.value = div.getAttribute("data-v");
                        searchTerm = input.value.trim();
                        status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                        closeSuggest();
                        redraw(); // timeline-only
                    });
                });
            }

            input.addEventListener("input", () => {
                searchTerm = input.value.trim();
                status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                renderSuggest();
                redraw();
            });
            input.addEventListener("focus", renderSuggest);
            document.addEventListener("click", (e) => {
                if (!box.contains(e.target) && e.target !== input) closeSuggest();
            });

            clearBtn.addEventListener("click", () => {
                input.value = "";
                searchTerm = "";
                status.textContent = "";
                closeSuggest();
                redraw();
            });
        }

        /* ========= EVENT HOOKS ========= */
        function initUI() {
            document.getElementById("csvFileA").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "A");
            });
            document.getElementById("csvFileB").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "B");
            });

            [document.getElementById("reportHistoryA"), document.getElementById("reportHistoryB")].forEach(sel => {
                if (!sel) return;
                sel.addEventListener("change", () => {
                    const option = sel.options[sel.selectedIndex];
                    sel.title = option ? option.textContent : "";
                });
            });

            populateReportDropdowns();

            // Segmented control
            document.querySelectorAll("#viewMode button").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll("#viewMode button").forEach(b => b.classList.remove("active"));
                    btn.classList.add("active");
                    viewMode = btn.dataset.mode;
                    syncDateUI(currentDate);
                    redraw();
                });
            });

            document.getElementById("prevDay").addEventListener("click", () => changeDay(viewMode === "day" ? -1 : -7));
            document.getElementById("nextDay").addEventListener("click", () => changeDay(viewMode === "day" ? +1 : +7));
            document.getElementById("jumpToday").addEventListener("click", () => {
                currentDate = new Date();
                syncDateUI(currentDate);
                redraw();
            });
            document.getElementById("toggleShowRooms").addEventListener("click", () => {
                showAllRooms = !showAllRooms;
                document.getElementById("toggleShowRooms").textContent = showAllRooms ? "Hide Unused Rooms" : "Show All Rooms";
                if (viewMode === "day") redraw(); // weekly ignores this
            });

            document.getElementById("calPrev").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() - 1);
                renderCalendar(d); // move focus month; selection unchanged
            });
            document.getElementById("calNext").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() + 1);
                renderCalendar(d);
            });

            // Tabs
            document.querySelectorAll(".tab-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
                    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
                    btn.classList.add("active");
                    document.getElementById(btn.dataset.tab).classList.add("active");
                    if (btn.dataset.tab === "timelineTab") redraw();
                    if (btn.dataset.tab === "changeTab" && reportA.length && reportB.length) generateChangeLog(reportA, reportB);
                    if (btn.dataset.tab === "forecastTab") renderForecast();
                });
            });

            // Search
            wireSearch();

            // initial
            syncDateUI(currentDate);
            google.charts.setOnLoadCallback(() => redraw());
        }
        window.addEventListener("resize", () => redraw());

        /* ========= BOOT ========= */
        initUI();
    </script>






</body>

</html>