<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>EventScope</title>

    <!-- Google Charts -->
    <script src="https://www.gstatic.com/charts/loader.js"></script>

    <!-- PDF.js for in-browser PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
    <script>
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js";
        }
    </script>

    <!-- Dexie.js for IndexedDB management -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&amp;display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-navy: #0f1f3a;
            --panel: #1c2a55;
            --border: #394c7a;
            --text: #f5f5f5;
            --accent: #2196f3;
            --chart-bg: #ffffff;
            --prev: #dc2626;
            --new: #16a34a;
            --changed: #eab308;
            --tab: #0b1730;
            --tab-active: #173265;
            --muted: #cbd5e1;
            --today: #16a34a;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: var(--bg-navy);
            color: var(--text);
        }

        .container {
            margin: 0 auto;
            padding: 24px;
        }

        h1 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 0 0 12px 0;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 14px;
        }

        /* global controls (uploads) */
        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        label {
            font-size: .9rem;
            opacity: .9
        }

        input[type="file"] {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        input[type="file"]::-webkit-file-upload-button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: .8rem;
        }

        button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: .85rem;
            cursor: pointer;
            transition: .18s ease;
        }

        button:hover {
            filter: brightness(1.08)
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn.toggled {
            background: #3cc47c;
            color: #0f1f3a;
        }

        .btn.secondary.toggled {
            border-color: #3cc47c;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: .8rem;
            color: #cfe0ff;
        }

        .status-pill.success {
            color: #22c55e;
            border-color: rgba(34, 197, 94, 0.35);
        }

        .status-pill.error {
            color: #f87171;
            border-color: rgba(248, 113, 113, 0.45);
        }

        .status-pill.syncing {
            color: #facc15;
            border-color: rgba(250, 204, 21, 0.45);
        }

        .lighthouse-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .av-panel {
            margin-top: 16px;
            background: #17264d;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
        }

        .av-panel h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .av-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 12px;
        }

        .av-panel-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .av-room-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .av-room-card {
            background: rgba(15, 31, 58, 0.4);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 14px;
        }

        .av-room-card h4 {
            margin: 0 0 8px;
            font-size: 1.05rem;
        }

        .av-job {
            margin-bottom: 12px;
            padding: 10px 12px;
            border-radius: 8px;
            background: rgba(17, 34, 68, 0.6);
            border: 1px solid rgba(57, 76, 122, 0.45);
        }

        .av-job:last-child {
            margin-bottom: 0;
        }

        .av-job-header {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: baseline;
            margin-bottom: 6px;
        }

        .av-job-header strong {
            font-size: .95rem;
        }

        .av-job-company {
            font-size: .82rem;
            color: var(--muted);
        }

        .av-job-contacts {
            font-size: .78rem;
            color: var(--muted);
            margin-bottom: 6px;
        }

        .av-category {
            margin-bottom: 10px;
        }

        .av-category:last-child {
            margin-bottom: 0;
        }

        .av-category h5 {
            margin: 0 0 4px;
            font-size: .82rem;
            letter-spacing: .01em;
            text-transform: uppercase;
            color: #90b4ff;
        }

        .av-equipment {
            list-style: none;
            margin: 4px 0 0;
            padding-left: 0;
        }

        .av-equipment li {
            margin-bottom: 4px;
            font-size: .84rem;
            line-height: 1.35;
        }

        .av-equipment li:last-child {
            margin-bottom: 0;
        }

        .av-equipment.depth-0 {
            margin-left: 0;
        }

        .av-equipment.depth-1 {
            margin-left: 16px;
        }

        .av-equipment.depth-2 {
            margin-left: 32px;
        }

        .av-equipment.depth-3 {
            margin-left: 48px;
        }

        .av-equipment .av-qty {
            margin-left: 6px;
            color: #9db7ff;
            font-size: .78rem;
        }

        .av-equipment .av-item-line {
            display: flex;
            align-items: baseline;
            gap: 6px;
        }

        .av-equipment .av-item-label {
            display: inline-flex;
            align-items: baseline;
            gap: 4px;
        }

        .av-equipment .av-item-label.av-package {
            flex-direction: column;
            align-items: flex-start;
        }

        .av-equipment .av-item-label.av-package strong {
            font-weight: 600;
        }

        .av-equipment .av-item-label .av-sub {
            font-size: .72rem;
            color: var(--muted);
            font-weight: 400;
        }

        .av-meta {
            margin-left: 6px;
            font-size: .75rem;
            color: var(--muted);
        }

        .av-sections {
            display: grid;
            gap: 14px;
        }

        .av-section {
            background: #1d2f5a;
            border: 1px solid rgba(57, 76, 122, 0.7);
            border-radius: 10px;
            padding: 12px;
        }

        .av-section h4 {
            margin: 0 0 8px 0;
            font-size: 1rem;
        }

        .av-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 6px;
        }

        .av-list li {
            background: rgba(20, 32, 66, 0.8);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: .9rem;
        }

        .av-empty {
            opacity: .75;
            font-size: .9rem;
        }

        .spacer {
            flex: 1
        }

        .group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap
        }

        .upload-stack {
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
        }

        .upload-stack label {
            margin-bottom: 2px;
        }

        .upload-stack input[type="file"],
        .upload-stack .report-select {
            width: min(280px, 100%);
        }

        .report-select {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font: inherit;
            font-size: .85rem;
        }

        .report-select:focus {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }

        /* tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin: 12px 0;
        }

        .tab-btn {
            background: var(--tab);
            border: 1px solid var(--border);
            color: #cfe0ff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .tab-btn.active {
            background: var(--tab-active);
            color: #fff;
            border-color: #3e59a1;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* toolbar (calendar + bottom-anchored controls) */
        .toolbar {
            display: flex;
            gap: 20px;
            align-items: stretch;
            background: #182750;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
        }

        .calendar-shell {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px;
            width: 220px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .cal-nav button {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            cursor: pointer;
            font-weight: 700;
        }

        table.cal {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
            font-size: .8rem
        }

        .cal th {
            color: var(--muted);
            font-weight: 600;
            padding: 4px 0
        }

        .cal td {
            padding: 4px;
            border-radius: 6px;
            cursor: pointer
        }

        .cal td:hover {
            background: #2b3f75
        }

        .cal td.active {
            background: #2b3f75;
            outline: 1px solid #4b6bb5
        }

        .cal td.real-today {
            outline: 2px dashed var(--today)
        }

        .cal td.muted {
            color: #7f8ab1
        }

        .week-highlight td.in-week {
            background: #2a3f7c;
        }

        .week-highlight td.in-week.active {
            outline: 2px solid #4b6bb5
        }

        .right-tools {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .controls-bottom {
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-badge {
            display: grid;
            grid-template-columns: 34px minmax(220px, 1fr) 34px;
            align-items: center;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 6px 8px;
            min-width: 320px;
        }

        .nav-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            color: #fff;
            background: var(--accent);
        }

        .date-label {
            text-align: center;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 8px;
        }

        .segmented {
            display: inline-flex;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 3px;
        }

        .segmented button {
            background: transparent;
            border: none;
            color: #cfe0ff;
            padding: 6px 10px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
        }

        .segmented button.active {
            background: var(--accent);
            color: #fff;
        }

        .btn {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: .85rem;
        }

        .btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
        }

        /* search card (timeline-only filter) */
        .search-card {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            position: relative;
        }

        .search-box input {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #1c2a55;
            color: #fff;
            font: inherit;
            min-width: 280px;
        }

        .suggestions {
            position: absolute;
            top: 110%;
            left: 0;
            right: 0;
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 180px;
            overflow-y: auto;
            display: none;
            z-index: 20;
        }

        .suggestions div {
            padding: 8px;
            cursor: pointer;
            font-size: .9rem;
        }

        .suggestions div:hover {
            background: #2b3f75;
        }

        .pill {
            background: #223366;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 4px 8px;
            font-size: .8rem;
            color: #cfe0ff;
        }

        /* timeline wrapper */
        #timeline-wrapper {
            background: var(--chart-bg);
            border-radius: 10px;
            padding: 10px;
            margin-top: 8px;
        }

        #timeline {
            width: 100%;
            height: 70vh;
            min-height: 400px;
        }

        #timeline text {
            font-weight: 400 !important;
        }

        .google-visualization-tooltip,
        .google-visualization-tooltip * {
            color: #000 !important;
            background: #fff !important;
            font-family: 'Poppins', sans-serif !important;
            font-size: 12px !important;
        }

        .google-visualization-tooltip {
            border: 1px solid #cfcfcf !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, .15) !important;
            border-radius: 6px !important;
        }

        /* Change Log (kept as your working version, pill colors preserved) */
        #changeLogNote {
            background: #eef6ff;
            color: #1e3a8a;
            padding: 6px 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-size: .9rem;
            font-weight: 500;
        }

        .company-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 14px 0 6px;
        }

        .event-header {
            font-size: 1rem;
            font-weight: 500;
            margin: 8px 0 4px 8px;
            color: #cbd5e1;
        }

        .change-card {
            background: #fff;
            color: #000;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 6px 0 6px 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .change-card h4 {
            margin: 0 0 6px;
            font-size: .95rem;
            color: #111;
        }

        .change-card ul {
            margin: 0;
            padding-left: 16px;
        }

        .change-card li {
            margin: 2px 0;
            font-size: .85rem;
        }

        .change-prev {
            color: var(--prev);
            font-weight: 600;
        }

        .change-new {
            color: var(--new);
            font-weight: 700;
        }

        /* Forecast styles (unchanged) */
        .forecast-card {
            background: #1c2a55;
            padding: 16px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #394c7a;
        }

        .forecast-card h3 {
            margin-top: 0;
            font-size: 1.2rem;
        }

        .company-group {
            margin-bottom: 14px;
            padding: 12px;
            border-radius: 8px;
            background: #223366;
        }

        .company-name {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .event-block {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 6px;
            background: #2a3c6e;
        }

        .event-title {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .space-pill {
            background: #394c7a;
            padding: 3px 8px;
            border-radius: 14px;
            font-size: .8rem;
            margin-right: 6px;
        }

        .happening .section {
            margin-top: 12px;
        }

        .happening strong {
            font-size: 1.05rem;
        }

        .happening .now strong {
            color: #22c55e;
        }

        .happening .next strong {
            color: #3b82f6;
        }

        .happening-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #394c7a;
        }

        .happening-row:last-child {
            border-bottom: none;
        }

        .happening-row span {
            font-size: .9rem;
        }

        .warning-box {
            margin-bottom: 12px;
            padding: 10px;
            border: 1px solid #facc15;
            border-radius: 6px;
            background: #2a2a1c;
            color: #facc15;
        }
    </style>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/loader.js"></script>
    <link id="load-css-0" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/core/tooltip.css">
    <link id="load-css-1" rel="stylesheet" type="text/css" href="https://www.gstatic.com/charts/51/css/util/util.css">
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_default_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_graphics_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_ui_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_fw_module.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/third_party/dygraphs/dygraph-tickers-combined.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://www.gstatic.com/charts/51/js/jsapi_compiled_timeline_module.js"></script>
</head>

<body>
    <div class="container">
        <h1>EventScope</h1>

        <!-- GLOBAL uploads -->
        <div class="card" id="globalUploads">
            <div class="controls">
                <div class="group upload-stack">
                    <label for="csvFileA">Newest Event Report PDF</label>
                    <input type="file" id="csvFileA" accept=".pdf">
                    <select id="reportHistoryA" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
                <div class="spacer"></div>
                <div class="group upload-stack">
                    <label for="csvFileB">Previous Event Report PDF</label>
                    <input type="file" id="csvFileB" accept=".pdf">
                    <select id="reportHistoryB" class="report-select">
                        <option value="">Select a saved report…</option>
                    </select>
                </div>
                <div class="group lighthouse-group">
                    <button class="btn" id="lighthouseSyncBtn">Lighthouse Sync</button>
                    <span class="status-pill" id="lighthouseStatus">Not connected</span>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="timelineTab">Timeline</button>
            <button class="tab-btn" data-tab="changeTab">Change Log</button>
            <button class="tab-btn" data-tab="forecastTab">Today’s Forecast</button>
        </div>

        <!-- TIMELINE TAB -->
        <div id="timelineTab" class="tab-content active">
            <div class="card">

                <!-- Toolbar (calendar + bottom-anchored controls) -->
                <div class="toolbar">
                    <!-- Calendar -->
                    <div class="calendar-shell week-highlight">
                        <div class="calendar-header">
                            <div id="calMonthLabel">September 2025</div>
                            <div class="cal-nav">
                                <button id="calPrev" aria-label="Prev Month">‹</button>
                                <button id="calNext" aria-label="Next Month">›</button>
                            </div>
                        </div>
                        <table class="cal" id="calTable">
                            <thead>
                                <tr>
                                    <th>Su</th>
                                    <th>Mo</th>
                                    <th>Tu</th>
                                    <th>We</th>
                                    <th>Th</th>
                                    <th>Fr</th>
                                    <th>Sa</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="7" data-d="31">31</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="1">1</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="2">2</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="3">3</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="4">4</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="5">5</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="6">6</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="7">7</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="8">8</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="9">9</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="10">10</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="11">11</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="12">12</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="13">13</td>
                                </tr>
                                <tr>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="14">14</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="15">15</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="16">16</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="17">17</td>
                                    <td class=" active real-today in-week" data-y="2025" data-m="8" data-d="18">18</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="19">19</td>
                                    <td class="   in-week" data-y="2025" data-m="8" data-d="20">20</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="21">21</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="22">22</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="23">23</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="24">24</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="25">25</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="26">26</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="27">27</td>
                                </tr>
                                <tr>
                                    <td class="   " data-y="2025" data-m="8" data-d="28">28</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="29">29</td>
                                    <td class="   " data-y="2025" data-m="8" data-d="30">30</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="1">1</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="2">2</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="3">3</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="4">4</td>
                                </tr>
                                <tr>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="5">5</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="6">6</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="7">7</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="8">8</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="9">9</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="10">10</td>
                                    <td class="muted   " data-y="2025" data-m="9" data-d="11">11</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Bottom-anchored tools -->

                </div>

                <!--Main Tools (Date, Toggle, Search, Show -->
                <div class="card" id="searchCard" style="margin-top:12px;">
                    <div class="search-card">

                        <div class="date-badge">
                            <button class="nav-btn" id="prevDay">‹</button>
                            <div class="date-label" id="dateLabel">Thu, Sep 18, 2025</div>
                            <button class="nav-btn" id="nextDay">›</button>
                        </div><button class="btn" id="jumpToday">Today</button>
                        <div class="segmented" id="viewMode">
                            <button data-mode="day" class="active">Daily</button>
                            <button data-mode="week" class="">Weekly</button>
                        </div>
                        <div class="search-box">
                            <input type="text" id="timelineSearch" placeholder="Search company or event…">
                            <div class="suggestions" id="searchSuggest" style="display: none;"></div>
                        </div>
                        <button class="secondary" id="clearSearch">Clear</button>
                        <span id="searchStatus" style="opacity:.7;font-size:.9rem;"></span>
                        <button class="btn secondary" id="toggleShowRooms">Show All Rooms</button>
                    </div>
                </div>

                <!-- Chart -->
                <div id="timeline-wrapper">
                    <div id="timeline">
                        <p style="color:#c00; margin:12px;">No events found for this date.</p>
                    </div>
                </div>
                <div class="av-panel" id="lighthousePanel">
                    <div class="av-panel-header">
                        <h3>Audio / Visual Actions</h3>
                        <div class="av-panel-controls">
                            <button class="btn secondary" id="highlightAVBtn">Highlight AV</button>
                            <span class="status-pill" id="lighthousePanelStatus">Sync Lighthouse to view AV data</span>
                        </div>
                    </div>
                    <div id="lighthousePanelContent">
                        <p class="av-empty">No Lighthouse data loaded for this date.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- CHANGE LOG TAB (unchanged logic & styles you approved) -->
        <div id="changeTab" class="tab-content">
            <div class="card">
                <h2>Change Log</h2>
                <div id="changeLogNote">Comparing overlapping dates: Previous Report ⇄ Newest Report</div>
                <div id="changeLog">
                    <p style="opacity:.8">Upload both reports to see changes.</p>
                </div>
            </div>
        </div>

        <!-- TODAY'S FORECAST TAB (unchanged) -->
        <div id="forecastTab" class="tab-content">
            <div class="card">
                <h2>Today’s Event Forecast</h2>
                <div id="forecast">
                    <p style="opacity:.8">Upload the newest report to view today’s schedule summary.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ========= LOAD CHARTS ========= */
        google.charts.load("current", {
            packages: ["timeline"]
        });

        /* ========= GLOBAL STATE ========= */
        let reportA = [],
            reportB = []; // A = newest, B = previous
        let allEvents = []; // base events (from newest report)
        let currentDate = new Date();
        let showAllRooms = false;
        let viewMode = "day"; // 'day' | 'week'
        let searchTerm = ""; // timeline-only filter
        let suggestionsList = []; // autosuggest values

        const LIGHTHOUSE_BRIDGE = window.desktop?.lighthouse ?? null;
        const LIGHTHOUSE_ENABLED = Boolean(LIGHTHOUSE_BRIDGE?.getActions);
        const LIGHTHOUSE_STATUS_CLASSES = ["success", "error", "syncing"];
        const LIGHTHOUSE_HIGHLIGHT_STYLE = "fill-color: #3cc47c; stroke-color: #ffffff; stroke-width: 2;";

        const ROOM_ORDER = [
            "Whitley Ballroom", "Whitley Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII",
            "Plaza Ballroom", "Plaza Prefunction", "Plaza I", "Plaza II", "Plaza III",
            "Gallery", "Gallery Prefunction", "Gallery I", "Gallery II",
            "Legacy Ballroom", "Legacy Prefunction", "Legacy I", "Legacy II",
            "Ambassador", "Attache", "Attache Charge", "Boardroom", "Charge", "Consulate",
            "Delegate", "Diplomat", "Director's Room", "Envoy", "The Founders Room"
        ];
        const SUBORDER = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
            "Gallery": ["Gallery I", "Gallery II"]
        };
        const PARENT_MAP = {};
        Object.entries(SUBORDER).forEach(([parent, subs]) => subs.forEach(sub => PARENT_MAP[sub] = parent));

        const ROOM_GUIDE = [];
        const ROOM_GUIDE_BY_GUID = new Map();
        const ROOM_GUIDE_BY_KEY = new Map();

        fetch('roomGuide.json')
            .then(resp => resp.ok ? resp.json() : [])
            .then(data => applyRoomGuide(data))
            .catch(err => console.warn('Unable to load roomGuide.json', err));

        const lighthouseState = {
            byDate: new Map(),
            selectedRoom: null,
            selectedCompany: null,
            highlightActive: false,
        };

        /* ========= REPORT HISTORY (IndexedDB) ========= */
        const REPORT_HISTORY_LIMIT = 10;
        const reportDB = window.Dexie ? new Dexie("eventscopeReports") : null;
        if (reportDB) {
            reportDB.version(1).stores({
                reports: "++id, uploadedAt"
            });
            reportDB.version(2).stores({
                reports: "++id, date, savedAt"
            }).upgrade(async tx => {
                await tx.table("reports").toCollection().modify(entry => {
                    const fallbackRaw = entry.fileTimestamp ?? entry.uploadedAt ?? Date.now();
                    const fallbackNumber = Number(fallbackRaw);
                    const fallbackDate = Number.isFinite(fallbackNumber) ? new Date(fallbackNumber) : new Date();
                    const savedValue = entry.uploadedDate ?? (entry.uploadedAt ? new Date(Number(entry.uploadedAt)).toISOString() : new Date().toISOString());
                    entry.fileName = entry.fileName || entry.filename || "Report";
                    entry.date = entry.date || fallbackDate.toISOString();
                    entry.savedAt = entry.savedAt || savedValue;
                    if (entry.events === undefined && entry.rows !== undefined) {
                        entry.events = entry.rows;
                    }
                    delete entry.filename;
                    delete entry.uploadedAt;
                    delete entry.uploadedDate;
                    delete entry.fileTimestamp;
                    delete entry.rows;
                });
            });
        }

        const lighthouseDB = window.Dexie ? new Dexie("eventscopeLighthouse") : null;
        if (lighthouseDB) {
            lighthouseDB.version(1).stores({
                actions: "date"
            });
        }

        function entryDateValue(entry) {
            if (!entry) return 0;
            const candidate = entry.date ?? entry.savedAt;
            if (candidate !== undefined && candidate !== null) {
                const parsed = typeof candidate === "number" ? candidate : Date.parse(candidate);
                if (!Number.isNaN(parsed)) return parsed;
            }
            const fallback = entry.fileTimestamp ?? entry.uploadedAt ?? entry.lastModified;
            if (fallback !== undefined && fallback !== null) {
                const numeric = typeof fallback === "number" ? fallback : Number(fallback);
                if (Number.isFinite(numeric)) return numeric;
            }
            return 0;
        }

        function formatReportOption(entry) {
            const dateValue = entryDateValue(entry);
            const dt = dateValue ? new Date(dateValue) : null;
            const dateStr = dt ? dt.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "Unknown date";
            const name = entry.fileName || entry.filename || "Report";
            return `${dateStr} – ${name}`;
        }

        async function getStoredReports() {
            if (!reportDB) return [];
            try {
                const all = await reportDB.reports.toArray();
                const usable = all.filter(entry => entry && entry.events !== undefined);
                usable.sort((a, b) => {
                    const diff = entryDateValue(b) - entryDateValue(a);
                    if (diff !== 0) return diff;
                    return (b.id || 0) - (a.id || 0);
                });
                return usable.slice(0, REPORT_HISTORY_LIMIT);
            } catch (err) {
                console.error("Unable to read stored reports", err);
                return [];
            }
        }

        async function pruneExcessReports() {
            if (!reportDB) return;
            try {
                const all = await reportDB.reports.toArray();
                if (all.length <= REPORT_HISTORY_LIMIT) return;
                all.sort((a, b) => {
                    const diff = entryDateValue(b) - entryDateValue(a);
                    if (diff !== 0) return diff;
                    return (b.id || 0) - (a.id || 0);
                });
                const keep = new Set(all.slice(0, REPORT_HISTORY_LIMIT).map(entry => entry.id));
                const toDelete = all.filter(entry => !keep.has(entry.id)).map(entry => entry.id);
                if (toDelete.length) {
                    await reportDB.reports.bulkDelete(toDelete);
                }
            } catch (err) {
                console.error("Unable to prune stored reports", err);
            }
        }

        async function populateReportDropdowns({ selectAId, selectBId } = {}) {
            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            if (!selectA || !selectB) return [];
            const data = await getStoredReports();
            [
                { element: selectA, override: selectAId },
                { element: selectB, override: selectBId }
            ].forEach(({ element, override }) => {
                const previous = element.value;
                const desired = override !== undefined ? (override == null ? "" : String(override)) : previous;
                element.innerHTML = "<option value=\"\">Select a saved report…</option>";
                data.forEach(item => {
                    const opt = document.createElement("option");
                    opt.value = String(item.id);
                    opt.textContent = formatReportOption(item);
                    opt.dataset.fileName = item.fileName || "";
                    opt.dataset.date = item.date || "";
                    opt.dataset.savedAt = item.savedAt || "";
                    element.appendChild(opt);
                });
                if (desired) {
                    element.value = desired;
                    if (element.value !== desired) {
                        element.selectedIndex = 0;
                    }
                } else {
                    element.selectedIndex = 0;
                }
                const selectedOption = element.options[element.selectedIndex];
                element.title = selectedOption ? selectedOption.textContent : "";
            });
            return data;
        }

        async function saveParsedReport(file, rows, target) {
            if (!reportDB || !file) return null;
            try {
                const now = new Date();
                const hasLastModified = typeof file.lastModified === "number" && !Number.isNaN(file.lastModified);
                const fileDate = hasLastModified ? new Date(file.lastModified) : now;
                const fileDateIso = fileDate.toISOString();
                const events = Array.isArray(rows) ? rows.filter(r => r && r["Day of Event"]) : [];
                const clonedEvents = JSON.parse(JSON.stringify(events));
                const existing = await reportDB.reports
                    .where("date")
                    .equals(fileDateIso)
                    .filter(entry => (entry?.fileName || "") === file.name)
                    .first();
                const selectionTarget = target === "A" ? "selectAId" : "selectBId";
                if (existing?.id) {
                    await reportDB.reports.update(existing.id, {
                        events: clonedEvents,
                        savedAt: now.toISOString()
                    });
                    await pruneExcessReports();
                    await populateReportDropdowns({ [selectionTarget]: existing.id });
                    return existing.id;
                }
                const payload = {
                    fileName: file.name,
                    date: fileDateIso,
                    savedAt: now.toISOString(),
                    events: clonedEvents
                };
                const id = await reportDB.reports.add(payload);
                await pruneExcessReports();
                await populateReportDropdowns({ [selectionTarget]: id });
                return id;
            } catch (err) {
                console.error("Unable to save parsed report", err);
                return null;
            }
        }

        async function loadReportFromHistory(entryOrId, target) {
            if (!reportDB) return false;
            try {
                let entry = entryOrId;
                if (!entry || typeof entry !== "object") {
                    const idNum = Number(entryOrId);
                    if (!idNum) return false;
                    entry = await reportDB.reports.get(idNum);
                }
                if (!entry || entry.events === undefined) {
                    console.warn("Stored report is missing event data.");
                    return false;
                }
                const events = Array.isArray(entry.events) ? entry.events : [];
                const cloned = JSON.parse(JSON.stringify(events));
                ingestRows(target, cloned);
                return true;
            } catch (err) {
                console.error("Unable to load stored report", err);
                return false;
            }
        }

        async function initializeReportHistory() {
            await pruneExcessReports();
            const inputA = document.getElementById("csvFileA");
            const inputB = document.getElementById("csvFileB");
            if (inputA) inputA.value = "";
            if (inputB) inputB.value = "";
            const reports = await populateReportDropdowns({ selectBId: null });
            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");
            if (selectB) {
                selectB.value = "";
                selectB.selectedIndex = 0;
                const optionB = selectB.options[selectB.selectedIndex];
                selectB.title = optionB ? optionB.textContent : "";
            }
            if (!selectA || !reports.length) {
                if (selectA) {
                    selectA.selectedIndex = 0;
                    const optionA = selectA.options[selectA.selectedIndex];
                    selectA.title = optionA ? optionA.textContent : "";
                }
                return;
            }
            const latest = reports[0];
            const desired = String(latest.id);
            selectA.value = desired;
            if (selectA.value !== desired) {
                selectA.selectedIndex = 0;
            }
            const option = selectA.options[selectA.selectedIndex];
            selectA.title = option ? option.textContent : "";
            const loaded = await loadReportFromHistory(latest, "A");
            if (!loaded) {
                selectA.value = "";
                selectA.selectedIndex = 0;
                const fallbackOption = selectA.options[selectA.selectedIndex];
                selectA.title = fallbackOption ? fallbackOption.textContent : "";
            }
        }

        /* ========= PDF PARSING HEURISTICS ========= */
        const FUNCTION_TYPES = [
            "Meeting", "Breakout", "Breakfast", "Lunch", "Dinner", "Reception",
            "Cocktail Reception", "Board Meeting", "General Session", "Set Up",
            "Holding Room", "Dance", "Ceremony", "Brunch", "Box Lunch",
            "PM Break", "AM Break", "Coffee Break", "Continuous Break",
            "Hospitality Room", "24 Hour Hold", "Storage", "Office",
            "Registration", "Rehearsal", "Special", "Buffet", "Exhibits",
            "Continental Breakfast", "Teardown", "No Agenda Hold"
        ];

        const FUNCTION_SPACES_HINTS = [
            "Director's Room", "The Founders Room",
            "Legacy Ballroom", "Legacy Ballroom I", "Legacy Ballroom II",
            "Legacy I", "Legacy II", "Legacy Prefunction",
            "The Gallery", "Gallery", "Gallery I", "Gallery II",
            "Gallery Prefunction", "Gallery I Prefunction", "Gallery II Prefunction",
            "The Gallery Lounge",
            "Trade Root Restaurant", "Boardroom", "Envoy", "Diplomat", "Ambassador",
            "Plaza I", "Plaza II", "Plaza III", "Plaza II & III", "Plaza", "Plaza Prefunction",
            "Salon I", "Salon II", "Salon III", "Salon IV", "Salon V",
            "Salon VI", "Salon VII", "Salon VIII",
            "Prefunction", "2nd Floor Prefunction", "Whitley Prefunction",
            "Consulate", "Delegate", "Attache", "Charge",
            "The Whitley Ballroom", "Whitley Ballroom"
        ];

        const SETUP_STYLES = [
            "Conference", "Rounds of 10", "Rounds of 8", "Rounds of 6",
            "Chevron Theatre", "Schoolroom", "U-Shape", "Hollow Square",
            "Cocktail Rounds", "Theatre", "Special",
            "Crescent Rounds", "Lounge", "Storage"
        ];

        const GROUPINGS = {
            "Whitley Ballroom": ["Salon I", "Salon II", "Salon III", "Salon IV", "Salon V", "Salon VI", "Salon VII", "Salon VIII"],
            "Plaza Ballroom": ["Plaza I", "Plaza II", "Plaza III"],
            "Legacy Ballroom": ["Legacy I", "Legacy II"],
        };

        const ROMAN_ORDER = { I: 1, II: 2, III: 3, IV: 4, V: 5, VI: 6, VII: 7, VIII: 8 };

        const MEAL_BREAK_TYPES = new Set([
            "Breakfast", "Lunch", "Dinner", "AM Break", "PM Break",
            "Coffee Break", "Continuous Break", "Box Lunch", "Buffet", "Continental Breakfast"
        ]);

        const FALLBACK_TYPES = new Set([...MEAL_BREAK_TYPES, "Meeting", "Rehearsal", "Exhibits"]);

        const TIME_RANGE_RE = /(\d{1,2}:\d{2}\s?[AP]M)\s*[-–—]\s*(\d{1,2}:\d{2}\s?[AP]M)/i;
        const DATE_LINE_RE = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), .* \d{4}$/i;
        const COUNTS_RE = /^\d+\/\d+\/(?:\d+|__)$/;
        const POST_AS_RE = /Post As[:\-]?\s*(.+)/i;

        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function romanToInt(r) {
            return ROMAN_ORDER[r] ?? 999;
        }

        function splitRomanList(str) {
            const cleaned = str.replace(/\s*(?:&|and)\s*/gi, ",");
            return cleaned
                .split(",")
                .map(p => p.trim().toUpperCase())
                .filter(p => p && /^[IVX]+$/.test(p));
        }

        function expandCompoundPrefix(lineText) {
            const found = new Set();
            const checks = [
                { prefix: "Salon", regex: /\bSalon\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Plaza", regex: /\bPlaza\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
                { prefix: "Legacy", regex: /\bLegacy\b\s+([IVX]+(?:\s*,\s*[IVX]+)*(?:\s*(?:&|and)\s*[IVX]+)?)/gi },
            ];
            checks.forEach(({ prefix, regex }) => {
                let match;
                while ((match = regex.exec(lineText))) {
                    splitRomanList(match[1]).forEach(r => found.add(`${prefix} ${r}`));
                }
            });
            return Array.from(found);
        }

        function expandGroupedSpace(lineText, primary) {
            const compound = new Set(expandCompoundPrefix(lineText));

            Object.entries(GROUPINGS).forEach(([ballroom, subs]) => {
                subs.forEach(sub => {
                    const re = new RegExp(`\\b${escapeRegExp(sub)}\\b`);
                    if (re.test(lineText)) compound.add(sub);
                });
            });

            if (/\bAttache\b/i.test(lineText) && /\bCharge\b/i.test(lineText)) {
                return "Attache Charge";
            }

            if (!compound.size) {
                return primary ? primary.trim() : primary;
            }

            const whitley = Array.from(compound).filter(s => s.startsWith("Salon "));
            const plaza = Array.from(compound).filter(s => s.startsWith("Plaza "));
            const legacy = Array.from(compound).filter(s => s.startsWith("Legacy "));

            if (whitley.length) {
                const romans = Array.from(new Set(whitley.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Whitley Ballroom (${romans.map(r => `Salon ${r}`).join(", ")})`;
            }
            if (plaza.length) {
                const romans = Array.from(new Set(plaza.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Plaza Ballroom (${romans.map(r => `Plaza ${r}`).join(", ")})`;
            }
            if (legacy.length) {
                const romans = Array.from(new Set(legacy.map(s => s.split(" ").at(-1)))).sort((a, b) => romanToInt(a) - romanToInt(b));
                return `Legacy Ballroom (${romans.map(r => `Legacy ${r}`).join(", ")})`;
            }

            return primary ? primary.trim() : primary;
        }

        function detectFunctionType(text) {
            if (/\bContinental\b/i.test(text)) return "Continental Breakfast";
            const sorted = [...FUNCTION_TYPES].sort((a, b) => b.length - a.length);
            for (const f of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(f)}\\b`, "i");
                if (re.test(text)) return f;
            }
            return null;
        }

        function detectSetupStyle(text) {
            const sorted = [...SETUP_STYLES].sort((a, b) => b.length - a.length);
            for (const s of sorted) {
                const re = new RegExp(`\\b${escapeRegExp(s)}\\b`, "i");
                if (re.test(text)) return s;
            }
            return null;
        }

        function detectSpace(text) {
            for (const hint of FUNCTION_SPACES_HINTS) {
                const re = new RegExp(`\\b${escapeRegExp(hint)}\\b`);
                if (re.test(text)) return hint;
            }
            return null;
        }

        function cleanTimeString(raw) {
            if (!raw) return "";
            const match = raw.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
            if (!match) return raw.trim();
            const hour = String(Number(match[1]));
            const minute = match[2];
            const mod = match[3].toUpperCase();
            return `${hour}:${minute} ${mod}`;
        }

        /* ========= LIGHTHOUSE HELPERS ========= */
        function updateStatusPill(el, text, type) {
            if (!el) return;
            if (typeof text === "string") {
                el.textContent = text;
            }
            LIGHTHOUSE_STATUS_CLASSES.forEach(cls => el.classList.remove(cls));
            if (type && LIGHTHOUSE_STATUS_CLASSES.includes(type)) {
                el.classList.add(type);
            }
        }

        function setLighthouseStatus(text, type) {
            const el = document.getElementById("lighthouseStatus");
            updateStatusPill(el, text, type);
        }

        function setLighthousePanelStatus(text, type) {
            const el = document.getElementById("lighthousePanelStatus");
            updateStatusPill(el, text, type);
        }

        function canonicalizeText(value) {
            return (value ?? "").toString().trim().toLowerCase().replace(/\s+/g, " " );
        }

        function canonicalizeRoomKey(value) {
            return canonicalizeText(value).replace(/[^a-z0-9 ]+/g, "");
        }

        function escapeHtml(str) {
            return String(str ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function applyRoomGuide(data) {
            ROOM_GUIDE.length = 0;
            ROOM_GUIDE_BY_GUID.clear();
            ROOM_GUIDE_BY_KEY.clear();
            if (!Array.isArray(data)) return;
            data.forEach(entry => {
                if (!entry) return;
                const roomGuid = entry.roomGuid || entry.guid || entry.id || entry.RoomGuid || entry.RoomID || null;
                const rawName = entry.roomName || entry.name || entry.description || entry.RoomName || '';
                if (!roomGuid && !rawName) return;
                const normalizedName = normalizeRoomDisplayName(rawName);
                const key = canonicalizeRoomKey(normalizedName || rawName);
                const record = {
                    roomGuid,
                    roomName: rawName || '',
                    normalizedName: normalizedName || (rawName || '').trim(),
                    key,
                };
                ROOM_GUIDE.push(record);
                if (record.roomGuid) {
                    ROOM_GUIDE_BY_GUID.set(record.roomGuid, record);
                }
                if (key) {
                    if (!ROOM_GUIDE_BY_KEY.has(key)) {
                        ROOM_GUIDE_BY_KEY.set(key, []);
                    }
                    ROOM_GUIDE_BY_KEY.get(key).push(record);
                }
            });
            console.log('[Lighthouse] Loaded room guide entries:', ROOM_GUIDE.length);
        }

        function normalizeRoomDisplayName(name) {
            if (!name) return '';
            const normalized = normalizeRooms(name);
            if (normalized.length) {
                const base = PARENT_MAP[normalized[0]] || normalized[0];
                return base;
            }
            const trimmed = String(name).trim().replace(/\s{2,}/g, ' ');
            if (!trimmed) return '';
            const direct = ROOM_ORDER.find(room => room.toLowerCase() === trimmed.toLowerCase());
            return direct || trimmed;
        }

        function canonicalizeRoomFromGuide(roomGuid, fallbackName) {
            let entry = null;
            if (roomGuid && ROOM_GUIDE_BY_GUID.has(roomGuid)) {
                entry = ROOM_GUIDE_BY_GUID.get(roomGuid);
            }
            const fallbackNormalized = normalizeRoomDisplayName(fallbackName || '');
            if (!entry && fallbackNormalized) {
                const key = canonicalizeRoomKey(fallbackNormalized);
                if (key && ROOM_GUIDE_BY_KEY.has(key)) {
                    const list = ROOM_GUIDE_BY_KEY.get(key);
                    if (list.length) entry = list[0];
                }
            }
            let name = entry?.normalizedName || fallbackNormalized || '';
            if (!name) {
                const trimmed = (fallbackName || '').trim();
                name = normalizeRoomDisplayName(trimmed) || trimmed;
            }
            let key = canonicalizeRoomKey(name);
            if (!key && entry?.key) key = entry.key;
            if (!key && fallbackName) {
                key = canonicalizeRoomKey(normalizeRoomDisplayName(fallbackName) || fallbackName);
            }
            return {
                guid: entry?.roomGuid || roomGuid || null,
                name: name || fallbackName || '',
                key: key || '',
            };
        }

        function listFromPayload(payload) {
            if (!payload) return [];
            if (Array.isArray(payload)) return payload;
            const preferred = ["actions", "value", "data", "results", "items"];
            for (const key of preferred) {
                if (Array.isArray(payload?.[key])) return payload[key];
            }
            if (Array.isArray(payload?.data?.items)) return payload.data.items;
            if (Array.isArray(payload?.data?.results)) return payload.data.results;
            return [];
        }

        function parseActionDate(action) {
            const candidates = [
                "actionDate", "ActionDate", "date", "Date", "dueDate", "DueDate",
                "startDate", "StartDate", "start", "Start", "eventDate", "EventDate",
                "dayOfEvent", "DayOfEvent", "scheduleDate", "ScheduleDate"
            ];
            for (const key of candidates) {
                const raw = action?.[key];
                if (!raw) continue;
                const dt = new Date(raw);
                if (!Number.isNaN(dt)) return dt;
            }
            const nested = [
                action?.schedule?.startDate,
                action?.timeFrame?.start,
                action?.date?.start,
                action?.window?.start
            ];
            for (const raw of nested) {
                if (!raw) continue;
                const dt = new Date(raw);
                if (!Number.isNaN(dt)) return dt;
            }
            return null;
        }

        function extractCompany(action) {
            const candidates = [
                action?.companyName, action?.company?.name, action?.customerName, action?.customer?.name,
                action?.accountName, action?.account?.name, action?.job?.accountName, action?.job?.companyName,
                action?.orderName, action?.projectName, action?.eventName, action?.functionName, action?.jobName,
                action?.organizationName, action?.clientName
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            return action?.job?.name || "";
        }

        function extractDepartment(action) {
            const candidates = [
                action?.department, action?.departmentName, action?.resourceDepartment, action?.departmentDescription,
                action?.Department, action?.ResourceDepartment, action?.categoryDepartment
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            return "";
        }

        function extractCategory(action) {
            const candidates = [
                action?.category, action?.categoryName, action?.itemCategory, action?.resourceCategory,
                action?.productCategory, action?.type, action?.Category
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            return "";
        }

        function extractItem(action) {
            const candidates = [
                action?.itemName, action?.resourceName, action?.productName, action?.description, action?.name,
                action?.ItemName, action?.ResourceName, action?.ProductName
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            if (typeof action === "string") return action;
            return "";
        }

        function extractJob(action) {
            const candidates = [
                action?.jobName, action?.job?.name, action?.orderName, action?.projectName,
                action?.eventName, action?.functionName, action?.bookingName
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            return "";
        }

        function extractContact(action) {
            const candidates = [
                action?.contactName, action?.primaryContact, action?.customerContact, action?.ownerName,
                action?.coordinatorName, action?.eventCoordinator, action?.contact?.name
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            return "";
        }

        function extractQuantity(action) {
            const candidates = [
                action?.quantity, action?.qty, action?.qtyOrdered, action?.orderedQuantity, action?.numberOrdered,
                action?.count, action?.Quantity
            ];
            for (const value of candidates) {
                const num = Number(value);
                if (Number.isFinite(num) && num > 0) return num;
            }
            return 1;
        }

        function deriveRoomsFromAction(action) {
            const result = new Set();
            const nameHints = [
                action?.roomName, action?.room?.name, action?.room?.roomName,
                action?.spaceName, action?.space?.name, action?.locationName
            ].filter(Boolean);
            const guidCandidates = [
                action?.roomGuid, action?.room?.roomGuid, action?.room?.id, action?.roomId,
                action?.spaceGuid, action?.space?.roomGuid
            ];
            guidCandidates.forEach(guid => {
                if (!guid) return;
                const fallback = nameHints.find(Boolean) || '';
                const canonical = canonicalizeRoomFromGuide(guid, fallback);
                if (canonical.name) result.add(canonical.name);
            });
            const buckets = [
                action?.room, action?.roomName, action?.room?.name, action?.space, action?.spaceName, action?.space?.name,
                action?.location, action?.locationName, action?.functionSpace, action?.FunctionSpace, action?.meetingRoom,
                action?.meetingSpace, action?.venueRoom
            ];
            const arrayBuckets = [
                action?.rooms, action?.spaces, action?.locations
            ];
            const values = [];
            buckets.forEach(val => {
                if (typeof val === "string") values.push(val);
            });
            arrayBuckets.forEach(arr => {
                if (Array.isArray(arr)) {
                    arr.forEach(entry => {
                        if (typeof entry === "string") values.push(entry);
                        else if (entry?.name) values.push(entry.name);
                    });
                }
            });
            values.forEach(raw => {
                const cleaned = String(raw).trim();
                if (!cleaned) return;
                const canonical = canonicalizeRoomFromGuide(null, cleaned);
                if (canonical.name) {
                    result.add(canonical.name);
                    return;
                }
                const normalized = normalizeRooms(cleaned);
                if (normalized.length) {
                    normalized.forEach(n => {
                        const base = PARENT_MAP[n] || n;
                        result.add(base);
                    });
                } else {
                    const match = ROOM_ORDER.find(room => room.toLowerCase() === cleaned.toLowerCase());
                    result.add(match || cleaned);
                }
            });
            return Array.from(result);
        }

        function roomDisplayNameFromKey(key) {
            if (!key) return "";
            if (ROOM_GUIDE_BY_KEY.has(key) && ROOM_GUIDE_BY_KEY.get(key).length) {
                const entry = ROOM_GUIDE_BY_KEY.get(key)[0];
                if (entry?.normalizedName) return entry.normalizedName;
                if (entry?.roomName) return entry.roomName;
            }
            const match = ROOM_ORDER.find(room => canonicalizeRoomKey(room) === key);
            return match || key;
        }

        function isAudioVisualMatch(dept, category, item) {
            const tokens = [dept, category, item]
                .filter(Boolean)
                .map(val => val.toString().toLowerCase());
            if (!tokens.length) return false;
            if (tokens.some(t => t.includes("internet"))) return false;
            return tokens.some(t => /(audio|visual|a\/v|av|tech|technology|lighting|sound|projection|video|stage|rigging)/i.test(t));
        }

        function createEmptyLighthouseSummary(dateISO, payload, options = {}) {
            const requested = options?.requestedDate || dateISO;
            return {
                date: requested,
                raw: payload,
                avActions: [],
                byCompany: new Map(),
                byRoom: new Map(),
                gearTotals: new Map(),
                contacts: new Map(),
                jobs: new Set(),
                packageHeaders: new Map(),
                diagnostics: {
                    requestedDate: requested,
                    payloadDate: options?.payloadDate || null,
                    topLevelKeys: payload && typeof payload === 'object' ? Object.keys(payload) : [],
                    roomActionsConsidered: 0,
                    roomActionCount: 0,
                    jobsConsidered: 0,
                    jobCount: 0,
                    jobsMatchedDate: 0,
                    jobsDroppedByDate: 0,
                    jobsWithoutDateInfo: 0,
                    jobsWithEquipment: 0,
                    jobsWithoutEquipment: 0,
                    usedStructuredRoomActions: false,
                    fallbackListLength: 0,
                    canonicalization: [],
                    canonicalizationSeen: new Set(),
                    matchedRoomKeys: new Set(),
                    unmatchedRooms: [],
                    jobDateMatches: [],
                    jobDateDiscarded: [],
                },
            };
        }

        function ensureRoomEntry(summary, roomKey, roomName, roomGuid) {
            const key = roomKey || canonicalizeRoomKey(roomName);
            if (!key) {
                return {
                    key: '',
                    name: roomName || '',
                    guid: roomGuid || null,
                    actions: [],
                    jobs: new Map(),
                };
            }
            if (!summary.byRoom.has(key)) {
                summary.byRoom.set(key, {
                    key,
                    name: roomName || roomDisplayNameFromKey(key),
                    guid: roomGuid || null,
                    actions: [],
                    jobs: new Map(),
                });
            } else {
                const entry = summary.byRoom.get(key);
                if (roomName && (!entry.name || entry.name === key)) entry.name = roomName;
                if (roomGuid && !entry.guid) entry.guid = roomGuid;
            }
            return summary.byRoom.get(key);
        }

        function ensureJobEntry(roomEntry, jobName, company) {
            if (!roomEntry) return null;
            if (!roomEntry.jobs) roomEntry.jobs = new Map();
            const baseKey = canonicalizeText(jobName || company || '');
            const key = baseKey || `job-${roomEntry.jobs.size + 1}`;
            if (!roomEntry.jobs.has(key)) {
                roomEntry.jobs.set(key, {
                    key,
                    name: jobName || '',
                    company: company || '',
                    contacts: new Set(),
                    categories: new Map(),
                });
            } else {
                const jobEntry = roomEntry.jobs.get(key);
                if (jobName && !jobEntry.name) jobEntry.name = jobName;
                if (company && !jobEntry.company) jobEntry.company = company;
            }
            return roomEntry.jobs.get(key);
        }

        function addContactsToSummary(summary, jobEntry, contacts) {
            if (!jobEntry) return;
            if (!Array.isArray(contacts) || !contacts.length) return;
            contacts.forEach(name => {
                const trimmed = (name ?? '').toString().trim();
                if (!trimmed) return;
                if (!jobEntry.contacts) jobEntry.contacts = new Set();
                jobEntry.contacts.add(trimmed);
                const key = canonicalizeText(trimmed);
                if (!summary.contacts.has(key)) {
                    summary.contacts.set(key, { name: trimmed, jobs: new Set() });
                }
                if (jobEntry.name) {
                    summary.contacts.get(key).jobs.add(jobEntry.name);
                }
            });
        }

        function recordSummaryAction(summary, roomEntry, jobEntry, details) {
            const displayName = details.description || '';
            const rawDescription = details.rawDescription || details.description || '';
            const packageName = details.packageName || '';
            const record = {
                roomKey: roomEntry?.key || '',
                roomName: roomEntry?.name || details.roomName || '',
                roomGuid: roomEntry?.guid || details.roomGuid || null,
                job: details.job || jobEntry?.name || '',
                company: details.company || jobEntry?.company || '',
                category: details.category || '',
                description: displayName,
                rawDescription,
                packageName,
                quantity: details.quantity ?? 0,
                isPackageHeader: Boolean(details.isPackageHeader),
            };
            summary.avActions.push(record);
            if (roomEntry && roomEntry.actions) {
                roomEntry.actions.push(record);
            }
            if (record.job) {
                summary.jobs.add(record.job);
            }
            const companyKey = canonicalizeText(record.company);
            if (companyKey) {
                if (!summary.byCompany.has(companyKey)) {
                    summary.byCompany.set(companyKey, { name: record.company, rooms: new Map(), actions: [] });
                }
                const companyEntry = summary.byCompany.get(companyKey);
                companyEntry.actions.push(record);
                if (roomEntry?.key) {
                    if (!companyEntry.rooms.has(roomEntry.key)) {
                        companyEntry.rooms.set(roomEntry.key, { name: roomEntry.name, actions: [] });
                    }
                    companyEntry.rooms.get(roomEntry.key).actions.push(record);
                }
            }
            if (record.isPackageHeader) {
                const canonicalName = canonicalizeText(record.packageName || record.description);
                const pkgKey = `${canonicalName}|${record.quantity || 0}`;
                if (!summary.packageHeaders.has(pkgKey)) {
                    summary.packageHeaders.set(pkgKey, {
                        name: record.packageName || record.description,
                        quantity: record.quantity || 0,
                        sources: new Set(),
                    });
                }
                if (record.job) summary.packageHeaders.get(pkgKey).sources.add(record.job);
            } else {
                const descKey = canonicalizeText(record.description || record.rawDescription);
                if (descKey && !descKey.includes('internet')) {
                    if (!summary.gearTotals.has(descKey)) {
                        summary.gearTotals.set(descKey, { name: record.description || record.rawDescription, quantity: 0, sources: new Set() });
                    }
                    const gearEntry = summary.gearTotals.get(descKey);
                    gearEntry.quantity += record.quantity || 0;
                    if (record.job) gearEntry.sources.add(record.job);
                }
            }
            return record;
        }

        function extractStructuredRoomActions(payload) {
            if (!payload) return [];
            if (Array.isArray(payload.roomActions)) return payload.roomActions;
            if (Array.isArray(payload?.value?.roomActions)) return payload.value.roomActions;
            if (Array.isArray(payload?.data?.roomActions)) return payload.data.roomActions;
            if (Array.isArray(payload?.rooms)) return payload.rooms;
            return [];
        }

        function extractRoomJobs(roomAction) {
            const result = [];
            const candidates = [
                roomAction?.jobs,
                roomAction?.jobActions,
                roomAction?.roomJobs,
                roomAction?.actions,
                roomAction?.items,
                roomAction?.jobList,
                roomAction?.events,
            ];
            candidates.forEach(list => {
                if (Array.isArray(list)) {
                    list.forEach(job => {
                        if (job) result.push(job);
                    });
                }
            });
            return result;
        }

        function extractJobCompany(roomAction, job) {
            return extractCompany(job) || extractCompany(roomAction) || '';
        }

        function extractJobContactsList(job) {
            const result = new Set();
            const direct = [
                job?.primaryContact, job?.contactName, job?.customerContact, job?.ownerName,
                job?.coordinatorName, job?.eventCoordinator, job?.contact?.name
            ];
            direct.forEach(name => {
                if (name) result.add(name);
            });
            const arrays = [job?.contacts, job?.contactList, job?.contactsList, job?.contactPersons, job?.contactAssignments];
            arrays.forEach(list => {
                if (!Array.isArray(list)) return;
                list.forEach(entry => {
                    if (!entry) return;
                    if (typeof entry === 'string') {
                        result.add(entry);
                    } else if (entry.name) {
                        result.add(entry.name);
                    } else if (entry.contactName) {
                        result.add(entry.contactName);
                    } else if (entry.fullName) {
                        result.add(entry.fullName);
                    }
                });
            });
            return Array.from(result.values());
        }

        function extractEquipmentSections(job) {
            const sections = [];
            const candidates = [
                job?.equipmentSections,
                job?.equipment?.sections,
                job?.equipment?.equipmentSections,
                job?.sections,
                job?.equipmentSectionList,
            ];
            candidates.forEach(list => {
                if (Array.isArray(list)) {
                    list.forEach(section => {
                        if (section) sections.push(section);
                    });
                }
            });
            return sections;
        }

        function extractSectionName(section) {
            const candidates = [
                section?.sectionName,
                section?.name,
                section?.categoryName,
                section?.title,
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            return 'Equipment';
        }

        function extractEquipmentItems(section) {
            const items = [];
            const candidates = [
                section?.equipmentItems,
                section?.items,
                section?.resources,
                section?.equipment,
            ];
            candidates.forEach(list => {
                if (Array.isArray(list)) {
                    list.forEach(item => {
                        if (item) items.push(item);
                    });
                }
            });
            return items;
        }

        function extractEquipmentDescription(item) {
            const candidates = [
                item?.description, item?.itemDescription, item?.displayName, item?.name,
                item?.itemName, item?.resourceName, item?.productName,
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            if (typeof item === 'string') return item;
            return '';
        }

        function extractPackageName(item) {
            const candidates = [
                item?.packageName, item?.package?.name, item?.packageHeaderName,
                item?.PackageName, item?.Package?.Name
            ];
            for (const value of candidates) {
                if (value) return value;
            }
            return '';
        }

        function isPackageHeaderItem(item) {
            const candidates = [
                item?.isPackageHeader, item?.packageHeader, item?.isHeader, item?.isPackage, item?.IsPackageHeader,
            ];
            return candidates.some(flag => Boolean(flag));
        }

        function getChildEquipmentItems(item) {
            const children = [];
            const candidates = [item?.childItems, item?.children, item?.items];
            candidates.forEach(list => {
                if (!Array.isArray(list)) return;
                list.forEach(entry => {
                    if (entry) children.push(entry);
                });
            });
            return children;
        }

        function processEquipmentItem(summary, roomEntry, jobEntry, categoryEntry, item, categoryName, depth, parentStructured) {
            if (!item) return;
            const rawDescription = extractEquipmentDescription(item);
            const packageName = extractPackageName(item);
            if (!rawDescription && !packageName) return;
            const quantity = extractQuantity(item);
            const isPackageHeader = isPackageHeaderItem(item);
            const displayName = isPackageHeader ? (packageName || rawDescription || 'Package') : (rawDescription || 'Item');
            const structured = {
                description: displayName,
                rawDescription: rawDescription || '',
                displayName,
                packageName: packageName || '',
                quantity,
                isPackageHeader,
                children: [],
            };
            if (depth === 0) {
                categoryEntry.items.push(structured);
            } else if (parentStructured) {
                parentStructured.children.push(structured);
            }
            recordSummaryAction(summary, roomEntry, jobEntry, {
                job: jobEntry?.name,
                company: jobEntry?.company,
                category: categoryName,
                description: displayName,
                rawDescription,
                packageName,
                quantity,
                isPackageHeader,
            });
            const children = getChildEquipmentItems(item);
            children.forEach(child => processEquipmentItem(summary, roomEntry, jobEntry, categoryEntry, child, categoryName, depth + 1, structured));
        }

        function parseDateValueToISO(value) {
            if (value === null || value === undefined || value === '') return null;
            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) return null;
                const msMatch = trimmed.match(/Date\((\d+)\)/i);
                if (msMatch) {
                    const dt = new Date(Number(msMatch[1]));
                    if (!Number.isNaN(dt.getTime())) return toLocalISODate(dt);
                }
                if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed.slice(0, 10);
                const dt = new Date(trimmed);
                if (!Number.isNaN(dt.getTime())) return toLocalISODate(dt);
                return null;
            }
            if (value instanceof Date) {
                if (!Number.isNaN(value.getTime())) return toLocalISODate(value);
                return null;
            }
            if (typeof value === 'number' && Number.isFinite(value)) {
                const dt = new Date(value);
                if (!Number.isNaN(dt.getTime())) return toLocalISODate(dt);
            }
            return null;
        }

        function appendDateCandidate(container, value, depth = 0) {
            if (depth > 5) return;
            if (!container) return;
            if (!container.dates) container.dates = new Set();
            if (!container.ranges) container.ranges = [];
            if (!container.rangeKeys) container.rangeKeys = new Set();
            if (value === null || value === undefined || value === '') return;
            if (Array.isArray(value)) {
                value.forEach(entry => appendDateCandidate(container, entry, depth + 1));
                return;
            }
            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) return;
                const toParts = trimmed.split(/\s+to\s+/i);
                if (toParts.length === 2 && toParts[0] && toParts[1]) {
                    const startIso = parseDateValueToISO(toParts[0]);
                    const endIso = parseDateValueToISO(toParts[1]);
                    if (startIso || endIso) {
                        const key = `${startIso || ''}|${endIso || ''}`;
                        if (!container.rangeKeys.has(key)) {
                            container.rangeKeys.add(key);
                            container.ranges.push({ start: startIso || null, end: endIso || null });
                        }
                        return;
                    }
                }
                const hyphenParts = trimmed.split(/\s*-\s*/);
                if (hyphenParts.length === 2 && hyphenParts[0] && hyphenParts[1]) {
                    const startIso = parseDateValueToISO(hyphenParts[0]);
                    const endIso = parseDateValueToISO(hyphenParts[1]);
                    if (startIso || endIso) {
                        const key = `${startIso || ''}|${endIso || ''}`;
                        if (!container.rangeKeys.has(key)) {
                            container.rangeKeys.add(key);
                            container.ranges.push({ start: startIso || null, end: endIso || null });
                        }
                        return;
                    }
                }
                const iso = parseDateValueToISO(trimmed);
                if (iso) {
                    container.dates.add(iso);
                }
                return;
            }
            if (value instanceof Date) {
                const iso = parseDateValueToISO(value);
                if (iso) container.dates.add(iso);
                return;
            }
            if (typeof value === 'number') {
                const iso = parseDateValueToISO(value);
                if (iso) container.dates.add(iso);
                return;
            }
            if (typeof value === 'object') {
                const startCandidates = [
                    value.start,
                    value.startDate,
                    value.begin,
                    value.from,
                    value.beginDate,
                    value.first,
                    value.start_time,
                    value.startTime,
                    value.startDateTime,
                    value.startLocal,
                    value.startUtc,
                ];
                const endCandidates = [
                    value.end,
                    value.endDate,
                    value.finish,
                    value.to,
                    value.last,
                    value.endDateTime,
                    value.end_time,
                    value.endTime,
                    value.endLocal,
                    value.endUtc,
                ];
                let startIso = null;
                for (const candidate of startCandidates) {
                    const parsed = parseDateValueToISO(candidate);
                    if (parsed) {
                        startIso = parsed;
                        break;
                    }
                }
                let endIso = null;
                for (const candidate of endCandidates) {
                    const parsed = parseDateValueToISO(candidate);
                    if (parsed) {
                        endIso = parsed;
                        break;
                    }
                }
                if (startIso || endIso) {
                    const key = `${startIso || ''}|${endIso || ''}`;
                    if (!container.rangeKeys.has(key)) {
                        container.rangeKeys.add(key);
                        container.ranges.push({ start: startIso || null, end: endIso || null });
                    }
                }
                const directCandidates = [
                    value.date,
                    value.Date,
                    value.day,
                    value.Day,
                    value.value,
                    value.dateValue,
                    value.occurrenceDate,
                    value.eventDate,
                ];
                directCandidates.forEach(candidate => appendDateCandidate(container, candidate, depth + 1));
                const fallbackKeys = [
                    'scheduledDate', 'scheduleDate', 'actionDate', 'eventDate', 'dayOfEvent', 'dueDate', 'pickupDate',
                    'returnDate', 'deliveryDate', 'loadInDate', 'loadOutDate', 'strikeDate', 'installDate',
                    'rehearsalDate', 'showDate', 'performanceDate', 'calendarDate', 'functionDate',
                ];
                fallbackKeys.forEach(key => {
                    if (Object.prototype.hasOwnProperty.call(value, key)) {
                        appendDateCandidate(container, value[key], depth + 1);
                    }
                });
                const nestedKeys = [
                    'schedule', 'Schedule', 'timeFrame', 'TimeFrame', 'timeframe', 'Timeframe', 'window', 'Window',
                    'period', 'Period', 'range', 'Range', 'availability', 'Availability', 'booking', 'Booking',
                    'function', 'Function', 'occurrence', 'Occurrence', 'reservation', 'Reservation', 'session', 'Session',
                    'segment', 'Segment', 'times', 'Times',
                ];
                nestedKeys.forEach(key => {
                    if (Object.prototype.hasOwnProperty.call(value, key)) {
                        appendDateCandidate(container, value[key], depth + 1);
                    }
                });
                const arrayKeys = [
                    'dates', 'Dates', 'dateList', 'DateList', 'scheduledDates', 'ScheduledDates', 'eventDates', 'EventDates',
                    'days', 'Days', 'dayList', 'DayList', 'occurrences', 'Occurrences', 'segments', 'Segments',
                    'dateRange', 'DateRange', 'dateRanges', 'DateRanges',
                ];
                arrayKeys.forEach(key => {
                    if (Object.prototype.hasOwnProperty.call(value, key)) {
                        appendDateCandidate(container, value[key], depth + 1);
                    }
                });
                if (depth < 3) {
                    const maybeDateKeys = Object.keys(value || {}).filter(key => /date|day/i.test(key));
                    maybeDateKeys.forEach(key => {
                        if (!fallbackKeys.includes(key) && !nestedKeys.includes(key) && !arrayKeys.includes(key)) {
                            appendDateCandidate(container, value[key], depth + 1);
                        }
                    });
                }
                return;
            }
        }

        function collectDateCandidatesFromSource(container, source) {
            if (!source) return;
            const directKeys = [
                'flowsheetDate', 'flowDate', 'date', 'Date', 'actionDate', 'ActionDate', 'eventDate', 'EventDate', 'dayOfEvent',
                'DayOfEvent', 'scheduleDate', 'ScheduleDate', 'jobDate', 'JobDate', 'startDate', 'StartDate', 'endDate', 'EndDate',
                'startDateTime', 'StartDateTime', 'endDateTime', 'EndDateTime', 'start', 'Start', 'end', 'End', 'startTime',
                'StartTime', 'endTime', 'EndTime', 'dueDate', 'DueDate', 'calendarDate', 'CalendarDate', 'functionDate',
                'FunctionDate', 'performanceDate', 'PerformanceDate', 'pickupDate', 'PickupDate', 'returnDate', 'ReturnDate',
                'deliveryDate', 'DeliveryDate', 'loadInDate', 'LoadInDate', 'loadOutDate', 'LoadOutDate', 'showDate', 'ShowDate',
                'rehearsalDate', 'RehearsalDate', 'installDate', 'InstallDate', 'removalDate', 'RemovalDate', 'strikeDate',
                'StrikeDate', 'eventDay', 'EventDay', 'occurrenceDate', 'OccurrenceDate', 'meetingDate', 'MeetingDate',
                'scheduledDay', 'ScheduledDay', 'startLocal', 'endLocal', 'startUtc', 'endUtc', 'startDateLocal', 'endDateLocal',
            ];
            directKeys.forEach(key => appendDateCandidate(container, source[key]));
            const arrayKeys = [
                'dates', 'Dates', 'dateList', 'DateList', 'scheduledDates', 'ScheduledDates', 'eventDates', 'EventDates', 'days',
                'Days', 'dayList', 'DayList', 'occurrences', 'Occurrences', 'segments', 'Segments', 'dateRange', 'DateRange',
                'dateRanges', 'DateRanges', 'jobDates', 'JobDates', 'scheduleDates', 'ScheduleDates',
            ];
            arrayKeys.forEach(key => appendDateCandidate(container, source[key]));
            const nestedObjects = [
                source.schedule,
                source.Schedule,
                source.timeFrame,
                source.TimeFrame,
                source.timeframe,
                source.Timeframe,
                source.window,
                source.Window,
                source.period,
                source.Period,
                source.range,
                source.Range,
                source.availability,
                source.Availability,
                source.booking,
                source.Booking,
                source.function,
                source.Function,
                source.occurrence,
                source.Occurrence,
                source.reservation,
                source.Reservation,
                source.session,
                source.Session,
                source.segment,
                source.Segment,
                source.details,
                source.Details,
            ];
            nestedObjects.forEach(value => appendDateCandidate(container, value));
            const pairFields = [
                ['startDate', 'endDate'],
                ['StartDate', 'EndDate'],
                ['start', 'end'],
                ['Start', 'End'],
                ['startDateTime', 'endDateTime'],
                ['StartDateTime', 'EndDateTime'],
                ['startTime', 'endTime'],
                ['StartTime', 'EndTime'],
                ['scheduledStart', 'scheduledEnd'],
                ['ScheduledStart', 'ScheduledEnd'],
                ['loadInDate', 'loadOutDate'],
                ['LoadInDate', 'LoadOutDate'],
            ];
            pairFields.forEach(([startKey, endKey]) => {
                const startVal = source[startKey];
                const endVal = source[endKey];
                if (startVal || endVal) {
                    appendDateCandidate(container, { start: startVal, end: endVal });
                }
            });
        }

        function jobMatchesRequestedDate(job, roomAction, targetISO) {
            const container = { dates: new Set(), ranges: [], rangeKeys: new Set() };
            collectDateCandidatesFromSource(container, roomAction);
            collectDateCandidatesFromSource(container, job);
            const singleDates = Array.from(container.dates.values());
            const ranges = container.ranges.slice();
            const hasDateInfo = singleDates.length > 0 || ranges.length > 0;
            if (!targetISO) {
                return {
                    matches: true,
                    hadDateInfo: hasDateInfo,
                    candidateDates: singleDates,
                    ranges,
                    matchedDates: [],
                };
            }
            let matches = false;
            const matchedDates = new Set();
            singleDates.forEach(date => {
                if (date === targetISO) {
                    matches = true;
                    matchedDates.add(date);
                }
            });
            if (!matches && ranges.length) {
                const targetDate = fromISODateLocal(targetISO);
                ranges.forEach(range => {
                    if (!range) return;
                    const startDate = range.start ? fromISODateLocal(range.start) : null;
                    const endDate = range.end ? fromISODateLocal(range.end) : null;
                    if (!targetDate) return;
                    let inRange = false;
                    if (startDate && endDate) {
                        inRange = targetDate >= startDate && targetDate <= endDate;
                    } else if (startDate) {
                        inRange = targetDate >= startDate;
                    } else if (endDate) {
                        inRange = targetDate <= endDate;
                    }
                    if (inRange) {
                        matches = true;
                        matchedDates.add(range.start || range.end || targetISO);
                    }
                });
            }
            return {
                matches: matches || !hasDateInfo,
                hadDateInfo: hasDateInfo,
                candidateDates: singleDates,
                ranges,
                matchedDates: Array.from(matchedDates.values()),
            };
        }

        function processStructuredRoomActions(summary, roomActions, dateISO) {
            const diagnostics = summary?.diagnostics;
            roomActions.forEach(roomAction => {
                if (diagnostics) {
                    diagnostics.roomActionsConsidered += 1;
                }
                const roomGuid = roomAction?.roomGuid || roomAction?.roomId || roomAction?.room?.roomGuid;
                const rawRoomName = roomAction?.roomName || roomAction?.room?.name || roomAction?.spaceName || roomAction?.name || '';
                const canonical = canonicalizeRoomFromGuide(roomGuid, rawRoomName);
                const roomName = canonical.name || normalizeRoomDisplayName(rawRoomName) || rawRoomName || '';
                const roomKey = canonical.key || canonicalizeRoomKey(roomName);
                if (diagnostics) {
                    const logKey = `${roomGuid || ''}|${rawRoomName || ''}|${roomKey || ''}`;
                    if (!diagnostics.canonicalizationSeen.has(logKey)) {
                        diagnostics.canonicalizationSeen.add(logKey);
                        diagnostics.canonicalization.push({
                            roomGuid: roomGuid || null,
                            rawName: rawRoomName || '',
                            canonicalName: roomName || '',
                            canonicalKey: roomKey || '',
                            matched: Boolean(roomKey),
                        });
                    }
                }
                const jobs = extractRoomJobs(roomAction);
                const matchingJobs = [];
                jobs.forEach(job => {
                    if (diagnostics) diagnostics.jobsConsidered += 1;
                    const matchInfo = jobMatchesRequestedDate(job, roomAction, dateISO);
                    if (!matchInfo.hadDateInfo && diagnostics) {
                        diagnostics.jobsWithoutDateInfo += 1;
                    }
                    if (!matchInfo.matches) {
                        if (diagnostics) {
                            diagnostics.jobsDroppedByDate += 1;
                            const jobNameForLog = extractJob(job) || extractJob(roomAction) || '';
                            if (diagnostics.jobDateDiscarded.length < 200) {
                                diagnostics.jobDateDiscarded.push({
                                    job: jobNameForLog,
                                    room: rawRoomName || roomName || '',
                                    dates: matchInfo.candidateDates,
                                    ranges: matchInfo.ranges.map(r => ({ start: r?.start || null, end: r?.end || null })),
                                });
                            }
                        }
                        return;
                    }
                    const jobName = extractJob(job) || extractJob(roomAction);
                    matchingJobs.push({ job, jobName });
                    if (diagnostics) {
                        diagnostics.jobCount += 1;
                        diagnostics.jobsMatchedDate += 1;
                        if (Array.isArray(matchInfo.matchedDates) && matchInfo.matchedDates.length) {
                            if (diagnostics.jobDateMatches.length < 200) {
                                diagnostics.jobDateMatches.push({
                                    job: jobName || '',
                                    room: rawRoomName || roomName || '',
                                    matchedDates: matchInfo.matchedDates,
                                });
                            }
                        }
                    }
                });
                if (!matchingJobs.length) return;
                const roomEntry = ensureRoomEntry(summary, roomKey, roomName, canonical.guid);
                if (diagnostics) {
                    diagnostics.roomActionCount += 1;
                    if (roomKey) {
                        diagnostics.matchedRoomKeys.add(roomKey);
                    } else {
                        diagnostics.unmatchedRooms.push({ roomGuid: roomGuid || null, rawName: rawRoomName || '' });
                    }
                }
                matchingJobs.forEach(({ job, jobName }) => {
                    const company = extractJobCompany(roomAction, job);
                    const jobEntry = ensureJobEntry(roomEntry, jobName, company);
                    const contacts = extractJobContactsList(job);
                    if (!contacts.length) {
                        const fallback = extractContact(job);
                        if (fallback) contacts.push(fallback);
                    }
                    addContactsToSummary(summary, jobEntry, contacts);
                    const sections = extractEquipmentSections(job);
                    if (diagnostics) {
                        if (sections.length) diagnostics.jobsWithEquipment += 1;
                        else diagnostics.jobsWithoutEquipment += 1;
                    }
                    if (!sections.length) return;
                    sections.forEach(section => {
                        const categoryName = extractSectionName(section) || 'Equipment';
                        const categoryKey = canonicalizeText(categoryName) || `category-${jobEntry.categories.size}`;
                        if (!jobEntry.categories.has(categoryKey)) {
                            jobEntry.categories.set(categoryKey, { key: categoryKey, name: categoryName, items: [] });
                        }
                        const categoryEntry = jobEntry.categories.get(categoryKey);
                        const items = extractEquipmentItems(section);
                        items.forEach(item => {
                            processEquipmentItem(summary, roomEntry, jobEntry, categoryEntry, item, categoryName, 0, null);
                        });
                    });
                });
            });
        }

        function processGenericActions(summary, list, dateISO) {
            list.forEach(action => {
                const actionDate = parseActionDate(action);
                if (actionDate) {
                    const iso = toLocalISODate(actionDate);
                    if (iso && iso !== dateISO) return;
                }
                const department = extractDepartment(action);
                const category = extractCategory(action);
                const item = extractItem(action);
                const job = extractJob(action);
                const company = extractCompany(action);
                const contact = extractContact(action);
                const quantity = extractQuantity(action);
                const rooms = deriveRoomsFromAction(action);
                const isAV = isAudioVisualMatch(department, category, item);
                if (!isAV) return;
                const targets = rooms.length ? rooms : [''];
                targets.forEach(roomName => {
                    const canonical = canonicalizeRoomFromGuide(null, roomName);
                    const displayName = canonical.name || normalizeRoomDisplayName(roomName) || roomName || '';
                    const roomKey = canonical.key || canonicalizeRoomKey(displayName);
                    const roomEntry = ensureRoomEntry(summary, roomKey, displayName, canonical.guid);
                    const jobEntry = ensureJobEntry(roomEntry, job, company);
                    if (contact) {
                        addContactsToSummary(summary, jobEntry, [contact]);
                    }
                    if (jobEntry) {
                        if (!jobEntry.categories.has('av-default')) {
                            jobEntry.categories.set('av-default', { key: 'av-default', name: category || 'AV Equipment', items: [] });
                        }
                        const categoryEntry = jobEntry.categories.get('av-default');
                        categoryEntry.items.push({
                            description: item || 'Item',
                            displayName: item || 'Item',
                            rawDescription: item || 'Item',
                            packageName: '',
                            quantity,
                            isPackageHeader: false,
                            children: [],
                        });
                    }
                    recordSummaryAction(summary, roomEntry, jobEntry, {
                        job,
                        company,
                        category: category || 'AV Equipment',
                        description: item || 'Item',
                        rawDescription: item || 'Item',
                        packageName: '',
                        quantity,
                        isPackageHeader: false,
                    });
                });
            });
        }

        function resolveLighthouseDateKey(payload, fallbackISO) {
            const candidates = [
                payload?.flowsheetDate,
                payload?.value?.flowsheetDate,
                payload?.data?.flowsheetDate,
                payload?.flowsheet?.date,
            ];
            for (const candidate of candidates) {
                if (!candidate) continue;
                if (typeof candidate === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(candidate.trim())) {
                    return candidate.trim();
                }
                const parsed = new Date(candidate);
                if (!Number.isNaN(parsed.getTime())) {
                    return toLocalISODate(parsed);
                }
            }
            return fallbackISO;
        }

        function computeLighthouseSummaryForDate(dateISO, payload, options = {}) {
            const summary = createEmptyLighthouseSummary(dateISO, payload, options);
            const roomActions = extractStructuredRoomActions(payload);
            if (summary.diagnostics) {
                summary.diagnostics.usedStructuredRoomActions = roomActions.length > 0;
                if (options?.payloadDate && !summary.diagnostics.payloadDate) {
                    summary.diagnostics.payloadDate = options.payloadDate;
                }
            }
            if (roomActions.length) {
                processStructuredRoomActions(summary, roomActions, dateISO);
            } else {
                const list = listFromPayload(payload);
                if (summary.diagnostics) {
                    summary.diagnostics.fallbackListLength = list.length;
                }
                processGenericActions(summary, list, dateISO);
            }
            return summary;
        }

        async function loadStoredLighthouseData() {
            if (!lighthouseDB) return;
            try {
                const rows = await lighthouseDB.actions.toArray();
                rows.forEach(entry => {
                    try {
                        const payloadKey = resolveLighthouseDateKey(entry.payload, entry.date);
                        const summary = computeLighthouseSummaryForDate(entry.date, entry.payload, {
                            requestedDate: entry.date,
                            payloadDate: payloadKey,
                        });
                        if (summary.diagnostics) {
                            summary.diagnostics.storeKey = payloadKey;
                        }
                        lighthouseState.byDate.set(entry.date, summary);
                        if (payloadKey && payloadKey !== entry.date && !lighthouseState.byDate.has(payloadKey)) {
                            const payloadSummary = computeLighthouseSummaryForDate(payloadKey, entry.payload, {
                                requestedDate: payloadKey,
                                payloadDate: payloadKey,
                            });
                            if (payloadSummary.diagnostics) {
                                payloadSummary.diagnostics.storeKey = payloadKey;
                            }
                            lighthouseState.byDate.set(payloadKey, payloadSummary);
                        }
                    } catch (err) {
                        console.error("Failed to hydrate Lighthouse cache", err);
                    }
                });
            } catch (err) {
                console.error("Unable to read Lighthouse cache", err);
            }
        }

        async function saveLighthousePayload(dateISO, payload) {
            const storeKey = resolveLighthouseDateKey(payload, dateISO);
            const requestedSummary = computeLighthouseSummaryForDate(dateISO, payload, {
                requestedDate: dateISO,
                payloadDate: storeKey,
            });
            if (requestedSummary.diagnostics) {
                requestedSummary.diagnostics.storeKey = storeKey;
            }
            lighthouseState.byDate.set(dateISO, requestedSummary);
            if (storeKey && storeKey !== dateISO) {
                const payloadSummary = computeLighthouseSummaryForDate(storeKey, payload, {
                    requestedDate: storeKey,
                    payloadDate: storeKey,
                });
                if (payloadSummary.diagnostics) {
                    payloadSummary.diagnostics.storeKey = storeKey;
                }
                lighthouseState.byDate.set(storeKey, payloadSummary);
            } else {
                lighthouseState.byDate.set(storeKey, requestedSummary);
            }
            if (lighthouseDB) {
                const savedAt = new Date().toISOString();
                try {
                    await lighthouseDB.actions.put({ date: dateISO, payload, savedAt });
                    if (storeKey && storeKey !== dateISO) {
                        await lighthouseDB.actions.put({ date: storeKey, payload, savedAt });
                    }
                } catch (err) {
                    console.error("Unable to persist Lighthouse payload", err);
                }
            }
            console.log(
                '[Lighthouse] Payload stored under requested ' + dateISO +
                (storeKey && storeKey !== dateISO ? ' and payload ' + storeKey : '') +
                ' with ' + requestedSummary.avActions.length + ' AV actions for the requested date'
            );
            return requestedSummary;
        }

        function getLighthouseSummary(dateISO) {
            return lighthouseState.byDate.get(dateISO) || null;
        }

        function shouldHighlightRoomForDate(dateObj, company, baseRoom) {
            if (!lighthouseState.highlightActive) return false;
            if (!dateObj) return false;
            const iso = toLocalISODate(dateObj);
            const summary = getLighthouseSummary(iso);
            if (!summary) return false;
            const roomKey = canonicalizeRoomKey(baseRoom);
            const companyKey = canonicalizeText(company);
            if (roomKey && summary.byRoom.has(roomKey)) {
                if (!companyKey) return summary.byRoom.get(roomKey).actions.length > 0;
                const companyEntry = summary.byCompany.get(companyKey);
                if (!companyEntry) return summary.byRoom.get(roomKey).actions.length > 0;
                const companyRoom = companyEntry.rooms.get(roomKey);
                return Boolean(companyRoom && companyRoom.actions.length);
            }
            if (companyKey && summary.byCompany.has(companyKey)) {
                return summary.byCompany.get(companyKey).actions.length > 0;
            }
            return summary.avActions.length > 0;
        }

        function shouldHighlightWeekly(company, dayIso) {
            if (!lighthouseState.highlightActive) return false;
            const summary = getLighthouseSummary(dayIso);
            if (!summary) return false;
            const companyKey = canonicalizeText(company);
            if (companyKey && summary.byCompany.has(companyKey)) {
                return summary.byCompany.get(companyKey).actions.length > 0;
            }
            return summary.avActions.length > 0;
        }

        function renderSimpleList(items, emptyText) {
            if (!items.length) {
                return `<p class="av-empty">${emptyText}</p>`;
            }
            return `<ul class="av-list">${items.map(item => `<li>${item}</li>`).join("")}</ul>`;
        }

        function formatQuantityDisplay(quantity) {
            const num = Number(quantity);
            if (Number.isFinite(num)) {
                if (Number.isInteger(num)) return num.toString();
                return num.toFixed(2);
            }
            return (quantity ?? 0).toString();
        }

        function compareRoomsForDisplay(a, b) {
            const orderValue = entry => {
                const key = entry?.key || canonicalizeRoomKey(entry?.name || '');
                const idx = ROOM_ORDER.findIndex(room => canonicalizeRoomKey(room) === key);
                return idx === -1 ? ROOM_ORDER.length : idx;
            };
            const diff = orderValue(a) - orderValue(b);
            if (diff !== 0) return diff;
            return (a?.name || '').localeCompare(b?.name || '');
        }

        function renderEquipmentItem(item, depth) {
            if (!item) return '';
            const qty = formatQuantityDisplay(item.quantity ?? 0);
            const qtyLabel = `<span class="av-qty">×${qty}</span>`;
            const displayName = item.displayName || item.description || item.packageName || item.rawDescription || 'Item';
            let labelContent = `<span class="av-item-label">${escapeHtml(displayName)}</span>`;
            if (item.isPackageHeader) {
                const packageBase = item.packageName || displayName;
                const packageLabel = escapeHtml(packageBase);
                const shouldShowRaw = item.rawDescription && item.rawDescription !== packageBase;
                const rawLabel = shouldShowRaw ? `<span class="av-sub">${escapeHtml(item.rawDescription)}</span>` : '';
                labelContent = `<span class="av-item-label av-package"><strong>${packageLabel}</strong>${rawLabel}</span>`;
            }
            const nextDepth = Math.min(depth + 1, 3);
            const children = Array.isArray(item.children) && item.children.length ? renderEquipmentList(item.children, nextDepth) : '';
            return `<li><div class="av-item-line">${labelContent}${qtyLabel}</div>${children}</li>`;
        }

        function renderEquipmentList(items, depth = 0) {
            if (!Array.isArray(items) || !items.length) {
                return '<p class="av-empty">No equipment items listed.</p>';
            }
            return `<ul class="av-equipment depth-${depth}">${items.map(item => renderEquipmentItem(item, depth)).join('')}</ul>`;
        }

        function renderCategoryBlock(categoryEntry) {
            if (!categoryEntry) return '';
            const items = categoryEntry.items || [];
            const content = items.length ? renderEquipmentList(items, 0) : '<p class="av-empty">No equipment items listed.</p>';
            return `<div class="av-category"><h5>${escapeHtml(categoryEntry.name || 'Equipment')}</h5>${content}</div>`;
        }

        function renderJobBlock(jobEntry) {
            if (!jobEntry) return '';
            const titleParts = [];
            if (jobEntry.name) titleParts.push(`<strong>${escapeHtml(jobEntry.name)}</strong>`);
            if (jobEntry.company) titleParts.push(`<span class="av-job-company">${escapeHtml(jobEntry.company)}</span>`);
            const header = titleParts.length ? `<div class="av-job-header">${titleParts.join(' ')}</div>` : '';
            const contacts = jobEntry.contacts ? Array.from(jobEntry.contacts.values()).filter(Boolean) : [];
            const contactsHtml = contacts.length ? `<div class="av-job-contacts">Contacts: ${contacts.map(escapeHtml).join(', ')}</div>` : '';
            const categories = Array.from(jobEntry.categories?.values?.() || []);
            const categoryHtml = categories.length ? categories.map(renderCategoryBlock).join('') : '<p class="av-empty">No AV equipment listed.</p>';
            return `<div class="av-job">${header}${contactsHtml}${categoryHtml}</div>`;
        }

        function renderRoomCard(roomEntry) {
            if (!roomEntry) return '';
            const jobs = Array.from(roomEntry.jobs?.values?.() || []);
            const jobHtml = jobs.length ? jobs.sort((a, b) => (a.name || '').localeCompare(b.name || '')).map(renderJobBlock).join('') : '<p class="av-empty">No Lighthouse jobs for this room.</p>';
            return `<div class="av-room-card"><h4>${escapeHtml(roomEntry.name || 'Room')}</h4>${jobHtml}</div>`;
        }

        function buildDailySummary(summary) {
            const jobs = Array.from(summary.jobs.values()).sort((a, b) => a.localeCompare(b));
            const contacts = Array.from(summary.contacts.values()).map(entry => ({
                name: entry.name,
                jobs: Array.from(entry.jobs.values()).sort((a, b) => a.localeCompare(b)),
            })).sort((a, b) => a.name.localeCompare(b.name));
            const gear = Array.from(summary.gearTotals.values()).map(entry => ({
                name: entry.name,
                quantity: entry.quantity || 0,
                sources: Array.from(entry.sources.values()).sort((a, b) => a.localeCompare(b)),
            })).sort((a, b) => (b.quantity || 0) - (a.quantity || 0) || a.name.localeCompare(b.name));

            const jobHtml = `<div class="av-section"><h4>Jobs</h4>${renderSimpleList(jobs, 'No AV jobs recorded.')}</div>`;
            const contactHtml = contacts.length ? `<ul class="av-list">${contacts.map(c => `<li><div><strong>${escapeHtml(c.name)}</strong></div>${c.jobs.length ? `<div>${c.jobs.map(escapeHtml).join(', ')}</div>` : ''}</li>`).join('')}</ul>` : '<p class="av-empty">No AV contacts recorded.</p>';
            const contactSection = `<div class="av-section"><h4>Contacts</h4>${contactHtml}</div>`;
            const gearHtml = gear.length ? `<ul class="av-list">${gear.map(item => `<li><div><strong>${escapeHtml(item.name)}</strong> · Qty ${formatQuantityDisplay(item.quantity)}</div>${item.sources.length ? `<div>${item.sources.map(escapeHtml).join(', ')}</div>` : ''}</li>`).join('')}</ul>` : '<p class="av-empty">No AV gear recorded.</p>';
            const gearSection = `<div class="av-section"><h4>Gear</h4>${gearHtml}</div>`;
            return `<div class="av-sections">${jobHtml}${contactSection}${gearSection}</div>`;
        }

        function renderDailyPanel(panel, summary) {
            if (!summary || !summary.avActions.length) {
                panel.innerHTML = '<p class="av-empty">No Lighthouse AV data for this date.</p>';
                return;
            }
            const selectedKey = lighthouseState.selectedRoom;
            let rooms = [];
            if (selectedKey && summary.byRoom.has(selectedKey)) {
                rooms = [summary.byRoom.get(selectedKey)];
            } else {
                rooms = Array.from(summary.byRoom.values());
            }
            rooms.sort(compareRoomsForDisplay);
            const detailHtml = rooms.length ? `<div class="av-room-grid">${rooms.map(renderRoomCard).join('')}</div>` : '<p class="av-empty">No Lighthouse AV data for this date.</p>';
            const summaryHtml = buildDailySummary(summary);
            panel.innerHTML = `${detailHtml}${summaryHtml}`;
        }

        function accumulateWeeklyItem(categoryAggregate, item, dateISO) {
            const displayName = item?.packageName || item?.displayName || item?.description || item?.rawDescription || 'Item';
            const descKey = canonicalizeText(displayName);
            const quantity = Number(item.quantity) || 0;
            if (item.isPackageHeader) {
                const pkgKey = `${descKey}|${quantity}`;
                if (!categoryAggregate.packages.has(pkgKey)) {
                    categoryAggregate.packages.set(pkgKey, { name: displayName, quantity, occurrences: new Set() });
                }
                categoryAggregate.packages.get(pkgKey).occurrences.add(dateISO);
            } else {
                if (!categoryAggregate.items.has(descKey)) {
                    categoryAggregate.items.set(descKey, { name: displayName, quantity: 0 });
                }
                categoryAggregate.items.get(descKey).quantity += quantity;
            }
            if (Array.isArray(item.children) && item.children.length) {
                item.children.forEach(child => accumulateWeeklyItem(categoryAggregate, child, dateISO));
            }
        }

        function renderWeeklyCategory(categoryAggregate) {
            const packages = Array.from(categoryAggregate.packages.values()).sort((a, b) => a.name.localeCompare(b.name));
            const items = Array.from(categoryAggregate.items.values()).sort((a, b) => (b.quantity || 0) - (a.quantity || 0) || a.name.localeCompare(b.name));
            const lines = [];
            packages.forEach(pkg => {
                const qty = formatQuantityDisplay(pkg.quantity || 0);
                const occurrenceLabel = pkg.occurrences.size > 1 ? `<span class="av-meta">${pkg.occurrences.size} days</span>` : '';
                lines.push(`<li><strong>${escapeHtml(pkg.name)}</strong><span class="av-qty">×${qty}</span>${occurrenceLabel}</li>`);
            });
            items.forEach(item => {
                const qty = formatQuantityDisplay(item.quantity || 0);
                lines.push(`<li>${escapeHtml(item.name)}<span class="av-qty">×${qty}</span></li>`);
            });
            const content = lines.length ? `<ul class="av-equipment depth-0">${lines.join('')}</ul>` : '<p class="av-empty">No equipment totals.</p>';
            return `<div class="av-category"><h5>${escapeHtml(categoryAggregate.name || 'Equipment')}</h5>${content}</div>`;
        }

        function buildWeeklySummary(aggregate) {
            const jobs = Array.from(aggregate.jobs.values()).sort((a, b) => a.localeCompare(b));
            const contacts = Array.from(aggregate.contacts.values()).map(entry => ({
                name: entry.name,
                jobs: Array.from(entry.jobs.values()).sort((a, b) => a.localeCompare(b)),
            })).sort((a, b) => a.name.localeCompare(b.name));
            const gear = Array.from(aggregate.gear.values()).map(entry => ({
                name: entry.name,
                quantity: entry.quantity || 0,
                sources: Array.from(entry.sources.values()).sort((a, b) => a.localeCompare(b)),
            })).filter(entry => !canonicalizeText(entry.name).includes('internet'))
              .sort((a, b) => (b.quantity || 0) - (a.quantity || 0) || a.name.localeCompare(b.name));
            const jobSection = `<div class="av-section"><h4>Jobs</h4>${renderSimpleList(jobs, 'No AV jobs synced this week.')}</div>`;
            const contactHtml = contacts.length ? `<ul class="av-list">${contacts.map(c => `<li><div><strong>${escapeHtml(c.name)}</strong></div>${c.jobs.length ? `<div>${c.jobs.map(escapeHtml).join(', ')}</div>` : ''}</li>`).join('')}</ul>` : '<p class="av-empty">No AV contacts synced this week.</p>';
            const contactSection = `<div class="av-section"><h4>Contacts</h4>${contactHtml}</div>`;
            const gearHtml = gear.length ? `<ul class="av-list">${gear.map(item => `<li><div><strong>${escapeHtml(item.name)}</strong> · Qty ${formatQuantityDisplay(item.quantity)}</div>${item.sources.length ? `<div>${item.sources.map(escapeHtml).join(', ')}</div>` : ''}</li>`).join('')}</ul>` : '<p class="av-empty">No AV gear synced this week.</p>';
            const gearSection = `<div class="av-section"><h4>Gear Totals</h4>${gearHtml}</div>`;
            return `<div class="av-sections">${gearSection}${contactSection}${jobSection}</div>`;
        }

        function renderWeeklyPanel(panel, weekDates) {
            const aggregate = {
                categories: new Map(),
                gear: new Map(),
                contacts: new Map(),
                jobs: new Set(),
                missing: [],
            };
            weekDates.forEach(dateISO => {
                const summary = getLighthouseSummary(dateISO);
                if (!summary) {
                    aggregate.missing.push(dateISO);
                    return;
                }
                summary.jobs.forEach(job => aggregate.jobs.add(job));
                summary.contacts.forEach((value, key) => {
                    if (!aggregate.contacts.has(key)) {
                        aggregate.contacts.set(key, { name: value.name, jobs: new Set() });
                    }
                    value.jobs.forEach(jobName => aggregate.contacts.get(key).jobs.add(jobName));
                });
                summary.gearTotals.forEach((value, key) => {
                    if (!aggregate.gear.has(key)) {
                        aggregate.gear.set(key, { name: value.name, quantity: 0, sources: new Set() });
                    }
                    aggregate.gear.get(key).quantity += value.quantity || 0;
                    value.sources.forEach(jobName => aggregate.gear.get(key).sources.add(jobName));
                });
                summary.byRoom.forEach(roomEntry => {
                    roomEntry.jobs?.forEach(jobEntry => {
                        jobEntry.categories?.forEach(categoryEntry => {
                            const catKey = canonicalizeText(categoryEntry.name) || `category-${aggregate.categories.size}`;
                            if (!aggregate.categories.has(catKey)) {
                                aggregate.categories.set(catKey, { name: categoryEntry.name, packages: new Map(), items: new Map() });
                            }
                            const catAggregate = aggregate.categories.get(catKey);
                            (categoryEntry.items || []).forEach(item => accumulateWeeklyItem(catAggregate, item, dateISO));
                        });
                    });
                });
            });

            const categoryBlocks = Array.from(aggregate.categories.values())
                .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
                .map(renderWeeklyCategory)
                .join('');
            const detailHtml = categoryBlocks ? `<div class="av-room-grid">${categoryBlocks}</div>` : '<p class="av-empty">No Lighthouse AV equipment totals for this week.</p>';
            const summaryHtml = buildWeeklySummary(aggregate);
            const missingNotice = aggregate.missing.length ? `<p class="av-empty">No Lighthouse data for: ${aggregate.missing.map(date => escapeHtml(formatLighthouseDateLabel(date))).join(', ')}</p>` : '';
            panel.innerHTML = `${detailHtml}${summaryHtml}${missingNotice}`;
            const syncedCount = weekDates.length - aggregate.missing.length;
            if (syncedCount === weekDates.length) {
                setLighthousePanelStatus('Synced for all 7 days', 'success');
            } else if (syncedCount === 0) {
                setLighthousePanelStatus('No Lighthouse data for this week', null);
            } else {
                setLighthousePanelStatus(`Synced for ${syncedCount} of 7 days`, 'syncing');
            }
        }

        function formatLighthouseDateLabel(dateISO) {
            if (!dateISO) return '';
            const dt = new Date(dateISO + 'T00:00:00');
            if (Number.isNaN(dt.getTime())) return dateISO;
            return dt.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function describeLighthouseEmptyState(summary, dateISO) {
            if (!summary) return null;
            const diag = summary.diagnostics || {};
            const matchedRoomCount = summary.byRoom instanceof Map ? summary.byRoom.size : 0;
            const canonicalMatches = diag.matchedRoomKeys instanceof Set ? diag.matchedRoomKeys.size : Array.isArray(diag.matchedRoomKeys) ? diag.matchedRoomKeys.length : 0;
            const hasMatches = matchedRoomCount > 0 || canonicalMatches > 0;
            if (diag.usedStructuredRoomActions && (diag.roomActionCount === 0 || diag.jobCount === 0)) {
                const message = 'No jobs returned by Lighthouse for this date.';
                return {
                    reason: 'no-jobs',
                    panelMessage: message,
                    panelStatus: message,
                    panelType: 'syncing',
                    statusText: 'Synced (no jobs)',
                    statusType: 'syncing',
                };
            }
            if (diag.jobCount > 0 && !hasMatches) {
                const message = 'Jobs found but no rooms matched.';
                return {
                    reason: 'no-room-match',
                    panelMessage: message,
                    panelStatus: message,
                    panelType: 'syncing',
                    statusText: 'Jobs found but no rooms matched',
                    statusType: 'syncing',
                };
            }
            const dateLabel = formatLighthouseDateLabel(dateISO);
            const message = dateLabel ? `No Lighthouse AV data for ${dateLabel}.` : 'No Lighthouse AV data for this date.';
            return {
                reason: 'no-av-data',
                panelMessage: message,
                panelStatus: message,
                panelType: null,
                statusText: 'Synced (no AV data)',
                statusType: 'syncing',
            };
        }

        async function refreshLighthousePanel() {
            const panel = document.getElementById('lighthousePanelContent');
            if (!panel) return;
            if (viewMode === 'week') {
                const ws = weekStart(currentDate);
                const weekDates = [];
                for (let i = 0; i < 7; i++) {
                    const d = new Date(ws);
                    d.setDate(ws.getDate() + i);
                    weekDates.push(toLocalISODate(d));
                }
                renderWeeklyPanel(panel, weekDates);
                return;
            }

            const dateISO = toLocalISODate(currentDate);
            const summary = getLighthouseSummary(dateISO);
            const dateLabel = formatLighthouseDateLabel(dateISO);
            if (!summary) {
                const message = dateLabel ? `Sync Lighthouse to view AV details for ${dateLabel}.` : 'Sync Lighthouse to view AV details for this date.';
                panel.innerHTML = `<p class="av-empty">${escapeHtml(message)}</p>`;
                const statusText = dateLabel ? `No Lighthouse data for ${dateLabel}` : 'No Lighthouse data for this date';
                setLighthousePanelStatus(statusText, null);
                return;
            }
            if (!summary.avActions.length) {
                const emptyState = describeLighthouseEmptyState(summary, dateISO);
                if (emptyState) {
                    panel.innerHTML = `<p class="av-empty">${escapeHtml(emptyState.panelMessage)}</p>`;
                    setLighthousePanelStatus(emptyState.panelStatus, emptyState.panelType);
                } else {
                    const fallbackMessage = dateLabel ? `No Lighthouse AV data for ${dateLabel}.` : 'No Lighthouse AV data for this date.';
                    panel.innerHTML = `<p class="av-empty">${escapeHtml(fallbackMessage)}</p>`;
                    setLighthousePanelStatus(fallbackMessage, null);
                }
                return;
            }
            renderDailyPanel(panel, summary);
            const successText = dateLabel ? `Synced for ${dateLabel}` : 'Synced';
            setLighthousePanelStatus(successText, 'success');
        }

        async function syncLighthouse(dateISO) {
            if (!LIGHTHOUSE_ENABLED || !LIGHTHOUSE_BRIDGE) {
                alert('Lighthouse sync is only available in the EventScope desktop app.');
                return null;
            }
            console.log('[Lighthouse] Sync requested for', dateISO);
            setLighthouseStatus('Syncing…', 'syncing');
            try {
                const payload = await LIGHTHOUSE_BRIDGE.getActions(dateISO);
                console.log('[Lighthouse] Raw payload snapshot:', payload);
                const payloadKeys = payload && typeof payload === 'object' ? Object.keys(payload) : [];
                console.log('[Lighthouse] Payload top-level keys:', payloadKeys);
                const resolvedDate = resolveLighthouseDateKey(payload, dateISO);
                console.log('[Lighthouse] Resolved flowsheet date:', resolvedDate);
                const structuredActions = extractStructuredRoomActions(payload);
                console.log('[Lighthouse] Structured roomActions count:', structuredActions.length);
                let payloadJobCount = 0;
                structuredActions.forEach(roomAction => {
                    payloadJobCount += extractRoomJobs(roomAction).length;
                });
                console.log('[Lighthouse] Jobs detected in payload:', payloadJobCount);
                if (!structuredActions.length) {
                    const fallbackList = listFromPayload(payload);
                    console.log('[Lighthouse] Fallback action list length:', fallbackList.length);
                }
                const summary = await saveLighthousePayload(dateISO, payload);
                const diagnostics = summary.diagnostics || {};
                const matchedRooms = diagnostics.matchedRoomKeys instanceof Set ? Array.from(diagnostics.matchedRoomKeys.values()) : (Array.isArray(diagnostics.matchedRoomKeys) ? diagnostics.matchedRoomKeys : []);
                const unmatchedRooms = Array.isArray(diagnostics.unmatchedRooms) ? diagnostics.unmatchedRooms : [];
                const totalJobsSeen = typeof diagnostics.jobsConsidered === 'number' ? diagnostics.jobsConsidered : (typeof diagnostics.jobCount === 'number' ? diagnostics.jobCount : payloadJobCount);
                const jobsMatchedForDate = typeof diagnostics.jobsMatchedDate === 'number' ? diagnostics.jobsMatchedDate : (typeof diagnostics.jobCount === 'number' ? diagnostics.jobCount : 0);
                const jobsDroppedForDate = typeof diagnostics.jobsDroppedByDate === 'number' ? diagnostics.jobsDroppedByDate : Math.max(0, totalJobsSeen - jobsMatchedForDate);
                const payloadDateForLog = diagnostics.payloadDate || resolvedDate;
                console.log(
                    `[Lighthouse] Requested ${dateISO}, payload ${payloadDateForLog || 'unknown'}, ${totalJobsSeen} jobs found, ` +
                    `${jobsMatchedForDate} matched for requested date${jobsDroppedForDate ? `, ${jobsDroppedForDate} filtered out` : ''}.`
                );
                if (diagnostics.jobsWithoutDateInfo) {
                    console.log('[Lighthouse] Jobs without explicit date info treated as matches:', diagnostics.jobsWithoutDateInfo);
                }
                if (Array.isArray(diagnostics.jobDateDiscarded) && diagnostics.jobDateDiscarded.length) {
                    const discardedSample = diagnostics.jobDateDiscarded.slice(0, 5);
                    console.log('[Lighthouse] Jobs discarded due to date mismatch:', {
                        count: diagnostics.jobDateDiscarded.length,
                        sample: discardedSample,
                    });
                }
                if (Array.isArray(diagnostics.jobDateMatches) && diagnostics.jobDateMatches.length) {
                    const matchSample = diagnostics.jobDateMatches.slice(0, 5);
                    console.log('[Lighthouse] Jobs matched by date sample:', {
                        count: diagnostics.jobDateMatches.length,
                        sample: matchSample,
                    });
                }
                console.log('[Lighthouse] Summary diagnostics:', {
                    requestedDate: diagnostics.requestedDate || dateISO,
                    storeKey: diagnostics.storeKey || resolvedDate,
                    roomActionsConsidered: diagnostics.roomActionsConsidered || 0,
                    roomActionCount: diagnostics.roomActionCount || 0,
                    jobCount: diagnostics.jobCount || 0,
                    jobsConsidered: diagnostics.jobsConsidered || 0,
                    jobsMatchedDate: diagnostics.jobsMatchedDate || diagnostics.jobCount || 0,
                    jobsDroppedByDate: diagnostics.jobsDroppedByDate || 0,
                    jobsWithoutDateInfo: diagnostics.jobsWithoutDateInfo || 0,
                    jobsWithEquipment: diagnostics.jobsWithEquipment || 0,
                    jobsWithoutEquipment: diagnostics.jobsWithoutEquipment || 0,
                    usedStructuredRoomActions: Boolean(diagnostics.usedStructuredRoomActions),
                    fallbackListLength: diagnostics.fallbackListLength || 0,
                    matchedRoomKeys: matchedRooms,
                    unmatchedRooms,
                });
                if (Array.isArray(diagnostics.canonicalization) && diagnostics.canonicalization.length) {
                    if (typeof console.table === 'function') {
                        console.table(diagnostics.canonicalization.map(entry => ({
                            roomGuid: entry.roomGuid || '',
                            rawName: entry.rawName || '',
                            canonicalName: entry.canonicalName || '',
                            canonicalKey: entry.canonicalKey || '',
                            matched: entry.matched,
                        })));
                    } else {
                        console.log('[Lighthouse] Canonicalization results:', diagnostics.canonicalization);
                    }
                } else {
                    console.log('[Lighthouse] Canonicalization results: none recorded');
                }
                const dateLabel = formatLighthouseDateLabel(dateISO);
                if (summary.avActions.length) {
                    setLighthouseStatus('Synced', 'success');
                    const successText = dateLabel ? `Synced for ${dateLabel}` : 'Synced';
                    setLighthousePanelStatus(successText, 'success');
                } else {
                    const emptyState = describeLighthouseEmptyState(summary, dateISO);
                    if (emptyState) {
                        setLighthouseStatus(emptyState.statusText, emptyState.statusType);
                        setLighthousePanelStatus(emptyState.panelStatus, emptyState.panelType);
                    } else {
                        const fallbackMessage = dateLabel ? `No Lighthouse AV data for ${dateLabel}.` : 'No Lighthouse AV data for this date.';
                        setLighthouseStatus('Synced (no AV data)', 'syncing');
                        setLighthousePanelStatus(fallbackMessage, null);
                    }
                }
                await refreshLighthousePanel();
                redraw();
                console.log('[Lighthouse] Sync completed for', dateISO);
                return summary;
            } catch (err) {
                console.error('Unable to sync Lighthouse', err);
                setLighthouseStatus('Sync failed', 'error');
                setLighthousePanelStatus('Lighthouse sync failed', 'error');
                alert('Unable to sync Lighthouse. Please try again.');
                return null;
            }
        }

        function parseDayOfEvent(str) {
            if (!str) return null;
            let d = new Date(str);
            if (isNaN(d)) d = new Date(String(str).replace(/^[A-Za-z]+,\s*/, ""));
            return isNaN(d) ? null : d;
        }

        function parseTime(str) {
            if (!str) return [0, 0];
            const parts = String(str).trim().split(" ");
            const timePart = parts[0] || "0:00";
            const mod = (parts[1] || "").toUpperCase();
            const hhmm = timePart.split(":");
            let h = Number(hhmm[0] || 0),
                m = Number(hhmm[1] || 0);
            if (mod === "PM" && h < 12) h += 12;
            if (mod === "AM" && h === 12) h = 0;
            return [h, m];
        }

        function sameDay(a, b) {
            return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
        }

        function formatAMPM(d) {
            let h = d.getHours(),
                m = d.getMinutes(),
                ampm = h >= 12 ? "PM" : "AM";
            h = h % 12;
            h = h ? h : 12;
            m = m < 10 ? "0" + m : m;
            return `${h}:${m} ${ampm}`;
        }

        function monthLabel(d) {
            return d.toLocaleString("en-US", {
                month: "long",
                year: "numeric"
            });
        }

        function weekStart(d) {
            const x = new Date(d);
            const day = x.getDay();
            x.setDate(x.getDate() - day);
            x.setHours(0, 0, 0, 0);
            return x;
        }

        function weekEnd(d) {
            const ws = weekStart(d);
            const we = new Date(ws);
            we.setDate(ws.getDate() + 6);
            we.setHours(23, 59, 59, 999);
            return we;
        }

        function shortTick(d) {
            return d.toLocaleDateString("en-US", {
                weekday: "short",
                month: "numeric",
                day: "numeric"
            });
        }

        function condenseSubs(list) {
            if (!list.length) return "";
            const m = list[0].match(/^([A-Za-z]+(?:\s[A-Za-z]+)?)\s+/);
            let prefix = m ? m[1] + " " : "";
            if (prefix && !list.every(x => x.startsWith(prefix))) prefix = "";
            if (!prefix) return list.join(", ");
            const rest = list.map(x => x.slice(prefix.length)).join(", ");
            return prefix + rest;
        }

        function normalizeRooms(raw) {
            if (!raw) return [];
            let s = String(raw).trim().replace(/\s{2,}/g, ' ');
            if (s === "The Whitley Ballroom") s = "Whitley Ballroom";
            if (s === "The Gallery") s = "Gallery";
            if (s === "Plaza") s = "Plaza Ballroom";
            if (s === "Founder's Room" || s === "Founders Room") s = "The Founders Room";
            if (s === "Legacy Ballroom I") s = "Legacy I";
            if (s === "Legacy Ballroom II") s = "Legacy II";
            if (s.toLowerCase() === "attache charge") return ["Attache Charge"];
            if (s === "Prefunction") return ["Whitley Prefunction"];
            if (s.includes("(") && s.includes(")")) {
                const inner = s.slice(s.indexOf("(") + 1, s.lastIndexOf(")")).trim();
                if (inner) return inner.split(",").map(x => x.trim().replace(/\s{2,}/g, ' '));
            }
            if (s.includes(",")) return s.split(",").map(p => p.trim().replace(/\s{2,}/g, ' '));
            return [s];
        }

        function groupRoomsToLabels(rooms) {
            const byBase = new Map();
            rooms.forEach(r => {
                const base = PARENT_MAP[r] || r;
                const isSub = !!PARENT_MAP[r];
                if (!byBase.has(base)) byBase.set(base, {
                    base,
                    subs: new Set()
                });
                if (isSub) byBase.get(base).subs.add(r);
            });
            const out = [];
            for (const {
                    base,
                    subs
                }
                of byBase.values()) {
                if (subs.size > 0) {
                    const all = SUBORDER[base] || [];
                    if (subs.size === all.length) {
                        out.push({
                            label: base,
                            base
                        });
                    } else {
                        let list = Array.from(subs);
                        if (all.length) list.sort((a, b) => all.indexOf(a) - all.indexOf(b));
                        const condensed = condenseSubs(list);
                        out.push({
                            label: `${base} (${condensed})`,
                            base
                        });
                    }
                } else out.push({
                    label: base,
                    base
                });
            }
            return out;
        }
        function toLocalISODate(value) {
            if (!value) {
                const now = new Date();
                return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
            }
            const date = value instanceof Date ? value : new Date(value);
            if (Number.isNaN(date.getTime())) {
                const fallback = new Date();
                console.warn('Invalid date passed to toLocalISODate', value);
                return `${fallback.getFullYear()}-${String(fallback.getMonth() + 1).padStart(2, '0')}-${String(fallback.getDate()).padStart(2, '0')}`;
            }
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

        // Convert "YYYY-MM-DD" into a Date at LOCAL midnight
        function fromISODateLocal(iso) {
            const [y, m, d] = iso.split("-").map(Number);
            return new Date(y, m - 1, d, 0, 0, 0, 0);
        }

        /* ======== SEARCH FILTER (timeline-only) ======== */
        function buildSuggestions() {
            const names = new Set();
            (reportA || []).forEach(r => {
                if (r["Company Name"]) names.add(r["Company Name"].trim());
                if (r["Event Name"]) names.add(r["Event Name"].trim());
            });
            suggestionsList = Array.from(names).sort((a, b) => a.localeCompare(b));
        }

        function applySearchFilter(rows) {
            if (!searchTerm) return rows;
            const q = searchTerm.toLowerCase();
            // Filter by company OR event name
            return rows.filter(ev => {
                const c = (ev["Company Name"] || "").toLowerCase();
                const e = (ev["Event Name"] || "").toLowerCase();
                return c.includes(q) || e.includes(q);
            });
        }

        /* ========= TOOLTIP FOR DAILY ========= */
        function groupTooltip(room, items, status) {
            items.sort((a, b) => a.start - b.start);
            let html = `<div style="padding:6px;">`;
            if (items[0]?.event) html += `<div style="font-weight:700; margin-bottom:4px;">${items[0].event}</div>`;
            if (status) html += `<div style="margin-bottom:6px"><span style="padding:2px 6px;border-radius:6px;background:#eef;border:1px solid #ccd">${status}</span></div>`;
            html += `<div style="font-weight:600; margin-bottom:4px;">${room}</div>`;
            items.forEach(e => {
                const time = `${formatAMPM(e.start)} – ${formatAMPM(e.end)}`;
                html += `<div><b>${e.function||""}</b> · ${time} · ${e.setup||""}</div>`;
            });
            html += `</div>`;
            return html;
        }

        /* ========= TIMELINE DRAWERS ========= */
        function drawDaily(selectedDateISO) {
            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Room"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(selectedDateISO + "T00:00:00");
            currentDate = chosen;

            const groups = {};
            let dataMin = null,
                dataMax = null;
            const rowMeta = [];

            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const status = (ev["Event Status"] || "").toString().trim();
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const rooms = normalizeRooms(ev["Function Space"]);
                const company = ev["Company Name"] || "";
                const eventName = ev["Event Name"] || "";
                const labels = groupRoomsToLabels(rooms);

                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        if (sameDay(d, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: start,
                                max: midnight
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start,
                                end: midnight
                            });
                            if (start < groups[key].min) groups[key].min = start;
                            if (midnight > groups[key].max) groups[key].max = midnight;
                            if (!dataMin || start < dataMin) dataMin = start;
                            if (!dataMax || midnight > dataMax) dataMax = midnight;
                        }
                        if (sameDay(nextDay, chosen)) {
                            const key = label + "||" + company + "||" + status + "||" + nextDay.toDateString();
                            if (!groups[key]) groups[key] = {
                                roomLabel: label,
                                base,
                                company,
                                status,
                                items: [],
                                min: nextDay,
                                max: endNext
                            };
                            groups[key].items.push({
                                event: eventName,
                                function: ev["Function Type"],
                                setup: ev["Setup Style"],
                                start: nextDay,
                                end: endNext
                            });
                            if (nextDay < groups[key].min) groups[key].min = nextDay;
                            if (endNext > groups[key].max) groups[key].max = endNext;
                            if (!dataMin || nextDay < dataMin) dataMin = nextDay;
                            if (!dataMax || endNext > dataMax) dataMax = endNext;
                        }
                    });
                    return;
                }

                if (sameDay(d, chosen)) {
                    labels.forEach(({
                        label,
                        base
                    }) => {
                        const key = label + "||" + company + "||" + status + "||" + d.toDateString();
                        if (!groups[key]) groups[key] = {
                            roomLabel: label,
                            base,
                            company,
                            status,
                            items: [],
                            min: start,
                            max: end
                        };
                        groups[key].items.push({
                            event: eventName,
                            function: ev["Function Type"],
                            setup: ev["Setup Style"],
                            start,
                            end
                        });
                        if (start < groups[key].min) groups[key].min = start;
                        if (end > groups[key].max) groups[key].max = end;
                    });
                    if (!dataMin || start < dataMin) dataMin = start;
                    if (!dataMax || end > dataMax) dataMax = end;
                }
            });

            const rows = [];
            const usedBases = new Set();
            ROOM_ORDER.forEach(roomBase => {
                Object.values(groups).forEach(g => {
                    if (g.base === roomBase && sameDay(g.min, chosen)) {
                        usedBases.add(roomBase);
                        const highlight = shouldHighlightRoomForDate(chosen, g.company, g.base);
                        const style = highlight ? LIGHTHOUSE_HIGHLIGHT_STYLE : "";
                        rows.push([g.roomLabel, g.company || g.items[0]?.event || "", groupTooltip(g.roomLabel, g.items, g.status), style, g.min, g.max]);
                        rowMeta.push({ base: g.base, company: g.company || "", label: g.roomLabel });
                    }
                });
                if (showAllRooms && !usedBases.has(roomBase)) {
                    const base = dataMin || new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 8, 0);
                    rows.push([roomBase, "", "", "color:#E5E7EB;", base, new Date(base.getTime() + 60000)]);
                    rowMeta.push(null);
                }
            });
            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No events found for this date.</p>";
                refreshLighthousePanel();
                return;
            }

            dt.addRows(rows);

            const startHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 0, 0, 0, 0);
            const endHour = new Date(chosen.getFullYear(), chosen.getMonth(), chosen.getDate(), 23, 59, 59, 999);
            const ticks = [];
            let t = new Date(startHour);
            while (t <= endHour) {
                ticks.push(new Date(t));
                t.setHours(t.getHours() + 1);
            }

            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "h a",
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: startHour,
                        max: endHour
                    }
                },
                timeline: {
                    showBarLabels: true,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });

            google.visualization.events.addListener(chart, "select", () => {
                const selection = chart.getSelection();
                if (!selection.length) {
                    lighthouseState.selectedRoom = null;
                    lighthouseState.selectedCompany = null;
                } else {
                    const meta = rowMeta[selection[0].row];
                    if (meta) {
                        lighthouseState.selectedRoom = canonicalizeRoomKey(meta.base);
                        lighthouseState.selectedCompany = canonicalizeText(meta.company);
                    } else {
                        lighthouseState.selectedRoom = null;
                        lighthouseState.selectedCompany = null;
                    }
                }
                refreshLighthousePanel();
            });

            if (lighthouseState.selectedRoom) {
                const targetRoom = lighthouseState.selectedRoom;
                const targetCompany = lighthouseState.selectedCompany;
                const index = rowMeta.findIndex(meta => meta && canonicalizeRoomKey(meta.base) === targetRoom && canonicalizeText(meta.company) === targetCompany);
                if (index >= 0) {
                    chart.setSelection([{ row: index }]);
                }
            } else {
                chart.setSelection([]);
            }

            refreshLighthousePanel();
        }

        function drawWeekly(anyDateISO) {

            const container = document.getElementById("timeline");
            const chart = new google.visualization.Timeline(container);
            const dt = new google.visualization.DataTable();
            dt.addColumn({
                type: "string",
                id: "Company"
            });
            dt.addColumn({
                type: "string",
                id: "Label"
            });
            dt.addColumn({
                type: "string",
                role: "tooltip",
                p: {
                    html: true
                }
            });
            dt.addColumn({
                type: "string",
                role: "style"
            });
            dt.addColumn({
                type: "date",
                id: "Start"
            });
            dt.addColumn({
                type: "date",
                id: "End"
            });

            const chosen = new Date(anyDateISO + "T00:00:00");
            currentDate = chosen;
            const ws = weekStart(chosen); // Sun 00:00
            const we = weekEnd(chosen); // Sat 23:59:59.999

            // Per-company occupancy by day (from filtered events)
            const perCompany = new Map(); // company -> Map(dayISO -> Set(rooms))
            const source = applySearchFilter(allEvents || []); // <-- search filter
            source.forEach(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                if (!d) return;
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                let start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm);
                let end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em);
                const company = ev["Company Name"] || "";
                const rooms = normalizeRooms(ev["Function Space"]);

                const spans = [];
                if (end < start) {
                    const midnight = new Date(start);
                    midnight.setHours(23, 59, 59, 999);
                    spans.push({
                        s: start,
                        e: midnight
                    });
                    const nextDay = new Date(d);
                    nextDay.setDate(d.getDate() + 1);
                    const endNext = new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), eh, em);
                    spans.push({
                        s: new Date(nextDay.getFullYear(), nextDay.getMonth(), nextDay.getDate(), 0, 0, 0, 0),
                        e: endNext
                    });
                } else {
                    spans.push({
                        s: start,
                        e: end
                    });
                }

                spans.forEach(({
                    s,
                    e
                }) => {
                    // iterate each day from s..e; collect rooms for any day that intersects week
                    let cursor = new Date(s);
                    while (cursor <= e) {
                        const dayStart = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 0, 0, 0, 0);
                        const dayEnd = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate(), 23, 59, 59, 999);
                        if (dayEnd >= ws && dayStart <= we) {
                            if (!perCompany.has(company)) perCompany.set(company, new Map());
                            const dayIso = toLocalISODate(dayStart);
                            if (!perCompany.get(company).has(dayIso)) perCompany.get(company).set(dayIso, new Set());
                            rooms.forEach(r => perCompany.get(company).get(dayIso).add(r));
                        }
                        cursor.setDate(cursor.getDate() + 1);
                        cursor.setHours(0, 0, 0, 0);
                    }
                });
            });

            // Compute overall in-house span per company
            const companySpans = new Map();
            for (const [company, days] of perCompany.entries()) {
                const allDates = Array.from(days.keys()).map(d => fromISODateLocal(d));
                if (allDates.length) {
                    allDates.sort((a, b) => a - b); // earliest to latest
                    companySpans.set(company, {
                        start: allDates[0],
                        end: allDates[allDates.length - 1]
                    });
                }
            }

            // Rows: each company gets 7 day segments (Sun..Sat), filled if they have rooms
            const rows = [];
            const companies = Array.from(perCompany.keys()).sort((a, b) => a.localeCompare(b));
            companies.forEach(company => {
                for (let i = 0; i < 7; i++) {
                    const d = new Date(ws);
                    d.setDate(ws.getDate() + i);
                    const dayIso = toLocalISODate(d);
                    const has = perCompany.get(company).has(dayIso) && perCompany.get(company).get(dayIso).size > 0;
                    const roomsList = has ? Array.from(perCompany.get(company).get(dayIso)).sort() : [];
                    const segStart = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
                    const segEnd = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);
                    let style = has ? "" : "color:#E5E7EB;";
                    if (has && shouldHighlightWeekly(company, dayIso)) {
                        style = LIGHTHOUSE_HIGHLIGHT_STYLE;
                    }

                    const weekRange = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
                    const span = companySpans.get(company);
                    const spanText = span ?
                        `${span.start.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${span.end.toLocaleDateString("en-US",{month:"short",day:"numeric"})}` :
                        "";

                    const tip = `
  <div style="padding:6px;max-width:260px;">
    <div style="font-weight:700;margin-bottom:4px;">${company}</div>
    <div><b>${d.toLocaleDateString("en-US",{weekday:"short", month:"short", day:"numeric"})}</b></div>
    <div style="margin:6px 0;"><i>In-house:</i> ${spanText}</div>
    <div><b>Rooms:</b> ${roomsList.join(", ")}</div>
  </div>
`.trim();


                    rows.push([company, "", tip, style, segStart, segEnd]);
                }
            });

            if (!rows.length) {
                container.innerHTML = "<p style='color:#c00; margin:12px;'>No companies intersect this week.</p>";
                refreshLighthousePanel();
                return;
            }
            dt.addRows(rows);

            // Axis ticks: always Sun..Sat, labels like "Sun 9/21"
            const ticks = [];
            for (let i = 0; i < 7; i++) {
                const d = new Date(ws);
                d.setDate(ws.getDate() + i);
                d.setHours(0, 0, 0, 0); // midnight, not noon
                ticks.push(d);
            }


            chart.draw(dt, {
                tooltip: {
                    isHtml: true,
                    trigger: "focus"
                },
                backgroundColor: {
                    fill: "#fff"
                },
                chartArea: {
                    backgroundColor: "#fff"
                },
                hAxis: {
                    ticks,
                    format: "EEE M/d", // <-- fixed: use pattern, not function
                    textStyle: {
                        color: "#000"
                    },
                    baselineColor: "#aaa",
                    gridlines: {
                        color: "#ddd"
                    },
                    minorGridlines: {
                        count: 0
                    },
                    viewWindow: {
                        min: new Date(ws),
                        max: new Date(we)
                    }
                },
                timeline: {
                    showBarLabels: false,
                    rowLabelStyle: {
                        fontSize: 13,
                        color: "#000"
                    },
                    barLabelStyle: {
                        fontSize: 11,
                        color: "#000"
                    }
                }
            });

            refreshLighthousePanel();
        }

        /* ========= CHANGE LOG =========
           (Kept as your working logic from last version.
            Only re-rendered when both reports present and Change Log tab is opened.) */
        function generateChangeLog(reportA, reportB) {
            const container = document.getElementById("changeLog");
            container.innerHTML = "";

            if (!reportA.length || !reportB.length) {
                container.innerHTML = "<p style='opacity:.8'>Upload both reports to see changes.</p>";
                return;
            }

            // Company + Event + Date + Room + Function Type + Post As
            const makeKey = ev => [
                ev["Company Name"], ev["Event Name"], ev["Day of Event"],
                ev["Function Space"], ev["Function Type"], ev["Post As"] || ""
            ].join("||");

            const mapB = new Map();
            reportB.forEach(ev => mapB.set(makeKey(ev), ev));

            const companyGroups = {};
            reportA.forEach(ev => {
                const key = makeKey(ev);
                const old = mapB.get(key);
                if (!old) return; // only overlapping entries

                const diffs = [];
                ["Start Time", "End Time", "Setup Style", "Event Status"].forEach(field => {
                    if ((ev[field] || "").trim() !== (old[field] || "").trim()) {
                        diffs.push({
                            field,
                            prev: old[field] || "",
                            newest: ev[field] || ""
                        });
                    }
                });

                if (diffs.length) {
                    const company = ev["Company Name"] || "";
                    const event = ev["Event Name"] || "";
                    const space = ev["Function Space"] || "";
                    const ftype = ev["Function Type"] || "";
                    const pas = ev["Post As"] || "";
                    if (!companyGroups[company]) companyGroups[company] = {};
                    if (!companyGroups[company][event]) companyGroups[company][event] = [];
                    companyGroups[company][event].push({
                        space,
                        ftype,
                        pas,
                        diffs,
                        date: ev["Day of Event"]
                    });
                }
            });

            if (Object.keys(companyGroups).length === 0) {
                container.innerHTML = "<p style='opacity:.7'>✅ No changes detected between the reports.</p>";
                return;
            }

            for (const company of Object.keys(companyGroups)) {
                const compHeader = document.createElement("div");
                compHeader.className = "company-header";
                compHeader.textContent = company;
                container.appendChild(compHeader);

                for (const event of Object.keys(companyGroups[company])) {
                    const evHeader = document.createElement("div");
                    evHeader.className = "event-header";
                    evHeader.textContent = event;
                    container.appendChild(evHeader);

                    companyGroups[company][event].forEach(change => {
                        const card = document.createElement("div");
                        card.className = "change-card";
                        card.innerHTML = `
            <h4>${change.space} — ${change.ftype} ${change.pas?("· "+change.pas):""}</h4>
            <div style="font-size:.8rem;color:#555;margin-bottom:4px;">${change.date}</div>
            <ul>
              ${change.diffs.map(d=>
                `<li>${d.field}:
                  <span class="change-prev">${d.prev}</span> →
                  <span class="change-new">${d.newest}</span>
                </li>`).join("")}
            </ul>`;
                        container.appendChild(card);
                    });
                }
            }
        }


        /* ========= FORECAST (unchanged) ========= */
        function renderForecast() {
            const host = document.getElementById("forecast");
            host.innerHTML = "";

            if (!reportA.length) {
                host.innerHTML = "<p style='opacity:.8'>Upload the newest report to view today’s schedule summary.</p>";
                return;
            }

            const now = new Date();
            const todayISO = toLocalISODate(now);

            const todays = reportA.filter(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                return d && toLocalISODate(d) === todayISO;
            });

            if (!todays.length) {
                host.innerHTML = "<p style='opacity:.8'>No events scheduled for today.</p>";
                return;
            }

            const entries = todays.map(ev => {
                const d = parseDayOfEvent(ev["Day of Event"]);
                const [sh, sm] = parseTime(ev["Start Time"]);
                const [eh, em] = parseTime(ev["End Time"]);
                return {
                    company: ev["Company Name"] || "",
                    event: ev["Event Name"] || "",
                    space: ev["Function Space"] || "",
                    start: new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm),
                    end: new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em),
                };
            });

            const merged = (() => {
                const map = new Map();
                entries.forEach(e => {
                    const key = `${e.company}||${e.space}`;
                    if (!map.has(key)) {
                        map.set(key, {
                            company: e.company,
                            space: e.space,
                            start: new Date(e.start),
                            end: new Date(e.end),
                            events: [e.event]
                        });
                    } else {
                        const g = map.get(key);
                        if (e.start < g.start) g.start = new Date(e.start);
                        if (e.end > g.end) g.end = new Date(e.end);
                        g.events.push(e.event);
                    }
                });
                return Array.from(map.values()).sort((a, b) => a.start - b.start);
            })();

            const companyGroups = {};
            entries.forEach(ev => {
                if (!companyGroups[ev.company]) companyGroups[ev.company] = {};
                if (!companyGroups[ev.company][ev.event]) companyGroups[ev.company][ev.event] = new Set();
                companyGroups[ev.company][ev.event].add(ev.space);
            });

            const compCard = document.createElement("div");
            compCard.className = "forecast-card";
            compCard.innerHTML = "<h3>Companies & Function Spaces</h3>";
            for (const [company, events] of Object.entries(companyGroups)) {
                const group = document.createElement("div");
                group.className = "company-group";
                group.innerHTML = `<div class="company-name">${company}</div>`;
                for (const [event, spaces] of Object.entries(events)) {
                    const evBlock = document.createElement("div");
                    evBlock.className = "event-block";
                    evBlock.innerHTML = `<div class="event-title">${event}</div><div>${Array.from(spaces).map(s=>`<span class="space-pill">${s}</span>`).join("")}</div>`;
                    group.appendChild(evBlock);
                }
                compCard.appendChild(group);
            }
            host.appendChild(compCard);

            const nowList = merged.filter(e => now >= e.start && now < e.end);
            const nextList = merged.filter(e => e.start > now);

            const happeningCard = document.createElement("div");
            happeningCard.className = "forecast-card happening";
            happeningCard.innerHTML = "<h3>What's Happening</h3>";

            const renderSection = (title, list, cls) => {
                const sec = document.createElement("div");
                sec.className = `section ${cls}`;
                sec.innerHTML = `<strong>${title}</strong>`;
                if (!list.length) {
                    sec.innerHTML += `<p style='opacity:.7;font-size:.85rem'>No events</p>`;
                } else {
                    list.forEach(e => {
                        const row = document.createElement("div");
                        row.className = "happening-row";
                        row.innerHTML = `<span><b>${e.company}</b> — ${e.space}</span><span>${formatAMPM(e.start)} – ${formatAMPM(e.end)}</span>`;
                        sec.appendChild(row);
                    });
                }
                happeningCard.appendChild(sec);
            };

            renderSection("Now", nowList, "now");
            renderSection("Next", nextList, "next");
            host.appendChild(happeningCard);

            const byRoom = {};
            entries.forEach(e => {
                (byRoom[e.space] ||= []).push(e);
            });
            const flips = [];
            Object.values(byRoom).forEach(list => {
                list.sort((a, b) => a.start - b.start);
                for (let i = 1; i < list.length; i++) {
                    const prev = list[i - 1],
                        curr = list[i];
                    const gap = (curr.start - prev.end) / 60000;
                    if (gap >= 0 && gap <= 30 && prev.company !== curr.company) {
                        flips.push({
                            room: curr.space,
                            prev,
                            curr,
                            gap
                        });
                    }
                }
            });
            if (flips.length) {
                const warn = document.createElement("div");
                warn.className = "warning-box";
                warn.innerHTML = "<h3 style='margin:0 0 8px 0;color:#facc15;'>Warnings: Quick Room Flips</h3>";
                flips.forEach(f => {
                    const box = document.createElement("div");
                    box.innerHTML = `<strong>${f.room}</strong> ${f.prev.company} (${formatAMPM(f.prev.start)} – ${formatAMPM(f.prev.end)}) → ${f.curr.company} (${formatAMPM(f.curr.start)} – ${formatAMPM(f.curr.end)})`;
                    warn.appendChild(box);
                });
                host.appendChild(warn);
            }
        }

        /* ========= PDF UPLOAD ========= */
        async function extractPdfLines(file) {
            if (!window.pdfjsLib) {
                throw new Error("PDF.js library is not available");
            }
            const data = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data }).promise;
            const lines = [];

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();
                const items = textContent.items
                    .map(item => ({
                        text: (item.str || "").trim(),
                        x: item.transform?.[4] ?? 0,
                        y: item.transform?.[5] ?? 0
                    }))
                    .filter(item => item.text);

                items.sort((a, b) => {
                    const yDiff = Math.abs(b.y - a.y);
                    if (yDiff > 2) {
                        return b.y - a.y; // top to bottom
                    }
                    return a.x - b.x; // left to right
                });

                let currentY = null;
                let parts = [];
                items.forEach(item => {
                    if (currentY === null || Math.abs(item.y - currentY) <= 2) {
                        parts.push(item.text);
                        currentY = item.y;
                    } else {
                        const normalized = parts.join(' ').replace(/\s+/g, ' ').trim();
                        if (normalized) lines.push(normalized);
                        parts = [item.text];
                        currentY = item.y;
                    }
                });
                if (parts.length) {
                    const normalized = parts.join(' ').replace(/\s+/g, ' ').trim();
                    if (normalized) lines.push(normalized);
                }
            }

            return lines;
        }

        async function loadPDF(file, target) {
            const lines = await extractPdfLines(file);
            const rows = [];

            let currentCompany = null;
            let currentEvent = null;
            let currentDateStr = null;
            let currentStatus = null;
            let inEventHeader = false;
            let inEventBody = false;
            const lastSpaceByEvent = new Map();

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) {
                    continue;
                }

                if (line.includes("Quote #:")) {
                    currentCompany = line.split("Quote #:")[0].trim();
                    inEventHeader = true;
                    inEventBody = false;
                    continue;
                }

                if (line.includes("Status:")) {
                    const statusMatch = line.match(/Status:\s*(\w+)/i);
                    if (statusMatch) {
                        currentStatus = statusMatch[1].trim();
                    }
                    continue;
                }

                if (line.includes("Folio #:")) {
                    const evMatch = line.match(/(.+?)\s+Folio #:/);
                    if (evMatch) {
                        currentEvent = evMatch[1].trim();
                        inEventHeader = true;
                        inEventBody = false;
                    }
                    continue;
                }

                if (DATE_LINE_RE.test(line)) {
                    currentDateStr = line.trim();
                    continue;
                }

                const postMatch = line.match(POST_AS_RE);
                if (postMatch && rows.length && inEventBody) {
                    const last = rows[rows.length - 1];
                    if (last["Function Space"] && !last["Post As"]) {
                        last["Post As"] = postMatch[1].trim();
                    }
                    continue;
                }
                if (postMatch && inEventHeader) {
                    continue;
                }

                const timeMatch = line.match(TIME_RANGE_RE);
                if (!timeMatch) {
                    continue;
                }

                inEventHeader = false;
                inEventBody = true;

                const startTime = cleanTimeString(timeMatch[1]);
                const endTime = cleanTimeString(timeMatch[2]);
                const functionType = detectFunctionType(line);
                const setupStyle = detectSetupStyle(line);
                let functionSpace = detectSpace(line);
                functionSpace = expandGroupedSpace(line, functionSpace);

                if (functionSpace && COUNTS_RE.test(functionSpace.trim())) {
                    functionSpace = null;
                }

                const eventKey = `${currentCompany || ""}||${currentEvent || ""}`;
                if (!functionSpace && functionType && FALLBACK_TYPES.has(functionType)) {
                    const lastSpace = lastSpaceByEvent.get(eventKey);
                    if (lastSpace) {
                        functionSpace = lastSpace;
                    }
                }

                if (!functionSpace) {
                    continue;
                }

                lastSpaceByEvent.set(eventKey, functionSpace);

                rows.push({
                    "Company Name": currentCompany || "",
                    "Event Name": currentEvent || "",
                    "Event Status": currentStatus || "",
                    "Day of Event": currentDateStr || "",
                    "Start Time": startTime,
                    "End Time": endTime,
                    "Function Type": functionType || "",
                    "Function Space": functionSpace || "",
                    "Setup Style": setupStyle || "",
                    "Post As": "",
                    "Raw Line": line
                });
            }

            ingestRows(target, rows);
            return rows;
        }

        function ingestRows(target, rows) {
            const filtered = rows.filter(r => r && r["Day of Event"]);
            if (target === "A") {
                reportA = filtered;
                allEvents = filtered;
                buildSuggestions();
                redraw();
                renderForecast();
            } else {
                reportB = filtered;
            }
            if (reportA.length && reportB.length) {
                generateChangeLog(reportA, reportB);
            }
            console.log('[Reports] Ingested', filtered.length, 'rows for', target);
        }

        async function processPdfUpload(file, target) {
            if (!file) return;
            console.log('[Reports] Processing upload', file.name, 'for', target);
            try {
                const rows = await loadPDF(file, target);
                console.log('[Reports] Parsed', rows.length, 'rows from', file.name);
                if (!rows.length) {
                    alert(`No events were recognized in ${file.name}.`);
                }
                await saveParsedReport(file, rows, target);
            } catch (err) {
                console.error(err);
                alert(`Unable to parse ${file.name}: ${err?.message || err}`);
            }
        }

        /* ========= DATE / VIEW CONTROLS ========= */
        function syncDateLabel() {
            const label = document.getElementById("dateLabel");
            if (viewMode === "day") {
                label.textContent = currentDate.toLocaleDateString("en-US", {
                    weekday: "short",
                    month: "short",
                    day: "numeric",
                    year: "numeric"
                });
            } else {
                const ws = weekStart(currentDate),
                    we = weekEnd(currentDate);
                label.textContent = `${ws.toLocaleDateString("en-US",{month:"short",day:"numeric"})} – ${we.toLocaleDateString("en-US",{month:"short",day:"numeric"})}`;
            }
        }

        function redraw() {
            if (!google?.charts) return;
            if (viewMode === "day") drawDaily(toLocalISODate(currentDate));
            else drawWeekly(toLocalISODate(currentDate));
        }

        function changeDay(offset) {
            const nd = new Date(currentDate);
            nd.setDate(currentDate.getDate() + offset);
            currentDate = nd;
            syncDateUI(currentDate);
            redraw();
        }

        /* ========= CALENDAR ========= */
        const calTable = document.getElementById("calTable");
        const calMonthLabel = document.getElementById("calMonthLabel");

        function renderCalendar(focusDate) {
            const year = focusDate.getFullYear(),
                month = focusDate.getMonth();
            calMonthLabel.textContent = monthLabel(focusDate);
            const first = new Date(year, month, 1);
            const startDay = first.getDay(); // Sun=0
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const prevMonthDays = new Date(year, month, 0).getDate();
            const cells = [];

            for (let i = 0; i < startDay; i++) {
                cells.push({
                    d: new Date(year, month - 1, prevMonthDays - startDay + 1 + i),
                    muted: true
                });
            }
            for (let d = 1; d <= daysInMonth; d++) {
                cells.push({
                    d: new Date(year, month, d),
                    muted: false
                });
            }
            while (cells.length < 42) {
                const nextDay = cells.length - (startDay + daysInMonth) + 1;
                cells.push({
                    d: new Date(year, month + 1, nextDay),
                    muted: true
                });
            }

            const ws = weekStart(currentDate),
                we = weekEnd(currentDate);

            let html = "<thead><tr>" + ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map(d => `<th>${d}</th>`).join("") + "</tr></thead><tbody>";
            for (let r = 0; r < 6; r++) {
                html += "<tr>";
                for (let c = 0; c < 7; c++) {
                    const idx = r * 7 + c,
                        cell = cells[idx];
                    const isActive = cell.d.toDateString() === currentDate.toDateString();
                    const isRealToday = (new Date()).toDateString() === cell.d.toDateString();
                    const inWeek = cell.d >= ws && cell.d <= we;
                    html += `<td class="${cell.muted?"muted":""} ${isActive?"active":""} ${isRealToday?"real-today":""} ${inWeek?"in-week":""}"
        data-y="${cell.d.getFullYear()}" data-m="${cell.d.getMonth()}" data-d="${cell.d.getDate()}">${cell.d.getDate()}</td>`;
                }
                html += "</tr>";
            }
            html += "</tbody>";
            calTable.innerHTML = html;
            calTable.parentElement.classList.add("week-highlight");

            calTable.querySelectorAll("td").forEach(td => {
                td.addEventListener("click", () => {
                    const y = +td.getAttribute("data-y"),
                        m = +td.getAttribute("data-m"),
                        d = +td.getAttribute("data-d");
                    currentDate = new Date(y, m, d);
                    syncDateUI(currentDate);
                    redraw();
                });
            });
        }

        function syncDateUI(d) {
            renderCalendar(d);
            syncDateLabel();
        }

        /* ========= SEARCH UI (autosuggest) ========= */
        function wireSearch() {
            const input = document.getElementById("timelineSearch");
            const box = document.getElementById("searchSuggest");
            const status = document.getElementById("searchStatus");
            const clearBtn = document.getElementById("clearSearch");

            function closeSuggest() {
                box.style.display = "none";
            }

            function openSuggest() {
                box.style.display = "block";
            }

            function renderSuggest() {
                const q = (input.value || "").trim().toLowerCase();
                if (!q) {
                    closeSuggest();
                    return;
                }
                const matches = suggestionsList.filter(s => s.toLowerCase().includes(q)).slice(0, 12);
                if (!matches.length) {
                    closeSuggest();
                    return;
                }
                box.innerHTML = matches.map(m => `<div data-v="${m}">${m}</div>`).join("");
                openSuggest();
                box.querySelectorAll("div").forEach(div => {
                    div.addEventListener("click", () => {
                        input.value = div.getAttribute("data-v");
                        searchTerm = input.value.trim();
                        status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                        closeSuggest();
                        redraw(); // timeline-only
                    });
                });
            }

            input.addEventListener("input", () => {
                searchTerm = input.value.trim();
                status.textContent = searchTerm ? `Filtered by: "${searchTerm}"` : "";
                renderSuggest();
                redraw();
            });
            input.addEventListener("focus", renderSuggest);
            document.addEventListener("click", (e) => {
                if (!box.contains(e.target) && e.target !== input) closeSuggest();
            });

            clearBtn.addEventListener("click", () => {
                input.value = "";
                searchTerm = "";
                status.textContent = "";
                closeSuggest();
                redraw();
            });
        }

        /* ========= EVENT HOOKS ========= */
        async function initUI() {
            document.getElementById("csvFileA").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "A");
            });
            document.getElementById("csvFileB").addEventListener("change", e => {
                const f = e.target.files[0];
                processPdfUpload(f, "B");
            });

            const selectA = document.getElementById("reportHistoryA");
            const selectB = document.getElementById("reportHistoryB");

            const lighthouseButton = document.getElementById("lighthouseSyncBtn");
            const highlightBtn = document.getElementById("highlightAVBtn");

            if (lighthouseButton) {
                lighthouseButton.addEventListener("click", async () => {
                    const targetDate = toLocalISODate(currentDate);
                    if (!LIGHTHOUSE_ENABLED || !LIGHTHOUSE_BRIDGE) {
                        alert('Lighthouse sync is only available in the EventScope desktop app.');
                        return;
                    }
                    await syncLighthouse(targetDate);
                });
                if (!LIGHTHOUSE_ENABLED) {
                    lighthouseButton.disabled = true;
                    lighthouseButton.title = "Available in the desktop app";
                }
            }

            if (highlightBtn) {
                highlightBtn.addEventListener("click", () => {
                    lighthouseState.highlightActive = !lighthouseState.highlightActive;
                    highlightBtn.classList.toggle("toggled", lighthouseState.highlightActive);
                    highlightBtn.textContent = lighthouseState.highlightActive ? "Highlight AV: On" : "Highlight AV";
                    redraw();
                });
                highlightBtn.classList.toggle("toggled", lighthouseState.highlightActive);
                highlightBtn.textContent = lighthouseState.highlightActive ? "Highlight AV: On" : "Highlight AV";
                if (!LIGHTHOUSE_ENABLED) {
                    highlightBtn.disabled = true;
                    highlightBtn.title = "Sync Lighthouse in the desktop app to enable highlighting.";
                }
            }

            if (!LIGHTHOUSE_ENABLED) {
                setLighthouseStatus('Desktop app required', 'error');
                setLighthousePanelStatus('Lighthouse sync available in desktop app', null);
            } else {
                setLighthouseStatus('Ready', null);
            }

            if (selectA) {
                selectA.addEventListener("change", async () => {
                    const option = selectA.options[selectA.selectedIndex];
                    selectA.title = option ? option.textContent : "";
                    const id = selectA.value;
                    if (!id) return;
                    const loaded = await loadReportFromHistory(id, "A");
                    if (!loaded) {
                        alert("Unable to load the selected report from history.");
                        selectA.value = "";
                        selectA.selectedIndex = 0;
                        const resetOption = selectA.options[selectA.selectedIndex];
                        selectA.title = resetOption ? resetOption.textContent : "";
                    }
                });
            }

            if (selectB) {
                selectB.addEventListener("change", async () => {
                    const option = selectB.options[selectB.selectedIndex];
                    selectB.title = option ? option.textContent : "";
                    const id = selectB.value;
                    if (!id) return;
                    const loaded = await loadReportFromHistory(id, "B");
                    if (!loaded) {
                        alert("Unable to load the selected report from history.");
                        selectB.value = "";
                        selectB.selectedIndex = 0;
                        const resetOption = selectB.options[selectB.selectedIndex];
                        selectB.title = resetOption ? resetOption.textContent : "";
                    }
                });
            }

            await initializeReportHistory();
            await loadStoredLighthouseData();

            // Segmented control
            document.querySelectorAll("#viewMode button").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll("#viewMode button").forEach(b => b.classList.remove("active"));
                    btn.classList.add("active");
                    viewMode = btn.dataset.mode;
                    if (viewMode === "week") {
                        lighthouseState.selectedRoom = null;
                        lighthouseState.selectedCompany = null;
                    }
                    syncDateUI(currentDate);
                    redraw();
                });
            });

            document.getElementById("prevDay").addEventListener("click", () => changeDay(viewMode === "day" ? -1 : -7));
            document.getElementById("nextDay").addEventListener("click", () => changeDay(viewMode === "day" ? +1 : +7));
            document.getElementById("jumpToday").addEventListener("click", () => {
                currentDate = new Date();
                syncDateUI(currentDate);
                redraw();
            });
            document.getElementById("toggleShowRooms").addEventListener("click", () => {
                showAllRooms = !showAllRooms;
                document.getElementById("toggleShowRooms").textContent = showAllRooms ? "Hide Unused Rooms" : "Show All Rooms";
                if (viewMode === "day") redraw(); // weekly ignores this
            });

            document.getElementById("calPrev").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() - 1);
                renderCalendar(d); // move focus month; selection unchanged
            });
            document.getElementById("calNext").addEventListener("click", () => {
                const d = new Date(currentDate);
                d.setMonth(d.getMonth() + 1);
                renderCalendar(d);
            });

            // Tabs
            document.querySelectorAll(".tab-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
                    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
                    btn.classList.add("active");
                    document.getElementById(btn.dataset.tab).classList.add("active");
                    if (btn.dataset.tab === "timelineTab") redraw();
                    if (btn.dataset.tab === "changeTab" && reportA.length && reportB.length) generateChangeLog(reportA, reportB);
                    if (btn.dataset.tab === "forecastTab") renderForecast();
                });
            });

            // Search
            wireSearch();

            // initial
            syncDateUI(currentDate);
            refreshLighthousePanel();
            google.charts.setOnLoadCallback(() => redraw());
        }
        window.addEventListener("resize", () => redraw());

        /* ========= BOOT ========= */
        initUI().catch(err => console.error("Failed to initialize UI", err));
    </script>






</body>

</html>